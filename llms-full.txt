# Rimitive - Complete Documentation

> A set of composable libraries for TypeScript. Compose signals, views, and behaviors into applications with fine-grained reactivity.

This document contains the complete Rimitive documentation for LLM consumption.

---

## Project Overview (README)

Composable reactive primitives for TypeScript, with an awkward name but a lot of personality ðŸŒ

Start with signals, add what you need as you go, and swap out anything you want.

```bash
npm install @rimitive/core @rimitive/signals
```

Rimitive grows with you starting from your most simple reactive use cases:

```ts
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(
  SignalModule,
  ComputedModule,
  EffectModule
);

const you = signal('ðŸ«¸');
const rimitive = signal('ðŸ«·');
const highFive = computed(() => `${you()}ðŸ’¥${rimitive()}`);

effect(() => console.log(highFive())); // ðŸ«¸ðŸ’¥ðŸ«·
```

`compose()` wires modules together into a tiny, encapsulated, reactive service, with only what you asked for. But Rimitive takes primitives to another level, so hold onto your butts!

---

## Add a view layer

If you want to add a UI, sprinkle in some UI primitives:

```ts
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { MountModule } from '@rimitive/view/deps/mount';

const { signal, computed, el, mount } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // Add these ðŸ‘‡
  createElModule(createDOMAdapter()),
  MountModule
);

const App = () => {
  const together = signal(false);

  return el('div')(
    el('p').props({
      textContent: computed(() => (together() ? 'ðŸ«¸ðŸ’¥ðŸ«·' : 'ðŸ«¸   ðŸ«·')),
    }),
    el('button').props({ onclick: () => together(!together()) })('High five!')
  );
};

document.body.appendChild(mount(App()).element!);
```

Rimitive does things _a little differently_:

1. The component function runs once
2. The DOM structure is created once
3. When `together` changes, only that one text node updates (no diffing, reconciliation, or component re-renders)

Reactivity lives in the primitives, not in components. No component re-renders! Just mounting and unmounting.

Rimitive primitives (yes it sounds absurd) are environment-agnostic, which is where adapters come into playâ€”which is why `createElModule` takes an adapter.

Rimitive ships DOM, SSR, and hydration adapters, but you can write your own for whatever you want (Canvas, WebGL, or anything tree-shaped).

But that's just the beginning. Rimitive provides common tooling that utilizes these primitives, including routing, async loading, SSR, and streamingâ€”all on-demand, swappable, extensible, and completely optional.

For the full picture, check out the [docs](https://rimitive.dev/guides/getting-started)!

---

## Packages

| Package                                                       | Description                                                                                                           |
| ------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| [`@rimitive/core`](packages/core)                             | Composition engine â€” `compose()`, `defineModule()`                                                                    |
| [`@rimitive/signals`](packages/signals)                       | Reactive primitives â€” `signal`, `computed`, `effect`, `batch`                                                         |
| [`@rimitive/view`](packages/view)                             | UI primitives â€” `el`, `map`, `match`, `portal`, `load`                                                                |
| [`@rimitive/router`](packages/router)                         | Reactive routing â€” `matches`, `navigate()`, `query`                                                                   |
| [`@rimitive/resource`](packages/resource)                     | Async data fetching with `resource()`                                                                                 |
| [`@rimitive/ssr`](packages/ssr)                               | Server-side rendering and streaming                                                                                   |
| [`@rimitive/react`](packages/react)                           | React bindings                                                                                                        |
| [`@rimitive/mcp`](packages/mcp)                               | MCP server exposing Rimitive docs to LLMs                                                                             |
| [`@rimitive/devtools-extension`](packages/devtools-extension) | Chrome DevTools extension ([download](https://github.com/hejhi/rimitive/releases?q=devtools-extension&expanded=true)) |

---

## Extending

The modules that ship with Rimitive are built with the same `defineModule()` that's available to you:

```ts
import { defineModule } from '@rimitive/core';

const LoggerModule = defineModule({
  name: 'logger',
  provides: { log: (msg: string) => console.log(`[app] ${msg}`) },
});

const { signal, log } = compose(SignalModule, LoggerModule);
```

Create your own primitives! Swap out the entire reactive system if you want, or build adapters for new renderers. See the [Custom Modules](https://rimitive.dev/guides/custom-modules/) guide.

---

## AI

Just because Rimitive is brand new shouldn't mean an AI stumbles while trying to write idiomatic Rimitive code. [`@rimitive/mcp`](packages/mcp) provides an MCP server that exposes the entire Rimitive docs as meticulously tagged, searchable tools.

If you use [Claude Code](https://claude.ai/code), there are on-demand plugins too:

| Plugin                                           | Purpose                                      |
| ------------------------------------------------ | -------------------------------------------- |
| [`rimitive-behavior`](plugins/rimitive-behavior) | Headless behaviors â€” portable reactive logic |
| [`rimitive-module`](plugins/rimitive-module)     | Custom modules with `defineModule()`         |
| [`rimitive-view`](plugins/rimitive-view)         | Views with `el`, `map`, `match`              |

---

## Inspirations

Rimitive builds on ideas from _brilliant_ people who've thought deeply about reactivity and composition:

- [alien-signals](https://github.com/stackblitz/alien-signals), [reactively](https://github.com/milomg/reactively): push-pull reactivity, graph coloring, primitives in general
- [solidjs](https://www.solidjs.com), [radix](https://www.radix-ui.com): beautiful implementations of primitives in their respective domains
- [downshift](https://www.downshift-js.com/use-select): headless, portable UI patterns
- [jotai](https://jotai.org/docs/core/atom): treating atoms as configs rather than values
- [ProseMirror](https://prosemirror.net): extensibility and determinism

---

## Status

Alpha. Tested, benchmarked, used in personal projects. Not yet battle-tested in production.

[Why Rimitive?](https://rimitive.dev/why/) â€” the story behind the project.


---

## Getting Started

<!-- @tags: getting-started, installation, setup, quickstart, hello-world, first-app -->

## Installation

```bash
npm install @rimitive/core @rimitive/signals
```

<!-- @tags: counter, example, tutorial, reactive-state, dom-rendering -->

## Your First App

Create a counter with reactive state and DOM rendering. Start by installing the deps:

```bash
npm install @rimitive/core @rimitive/signals @rimitive/view
```

Then, create the app:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(createDOMAdapter()),
  MountModule
);

const { signal, computed, el, mount } = svc;

const App = () => {
  const count = signal(0);
  const doubled = computed(() => count() * 2);

  return el('div')(
    el('h1')('Counter'),
    el('p')(computed(() => `Count: ${count()}`)),
    el('p')(computed(() => `Doubled: ${doubled()}`)),
    el('button').props({
      onclick: () => count(count() + 1)
    })('Increment')
  );
}

const app = mount(App());
document.body.appendChild(app.element!);
```

That's it! Click the button, the count updates, the DOM updates automatically.

## What Just Happened?

1. **`compose()`** wires modules together into a service
2. **`signal()`** creates reactive state â€” read with `count()`, write with `count(newValue)`
3. **`computed()`** derives values that update when dependencies change
4. **`el()`** creates DOM elements with reactive children and props
5. **`mount()`** attaches the element tree to the DOM

If you're lost already, don't worry. We'll start from the very basics. These docs also cover reactive patterns in-depth, so you can jump around if you get confused at any time.

Rimitive is as much about patterns as it is about reactive primitives and tooling, so if at any point you hate it, you can always take any patterns that inspired you elsewhere!

---

## Creating a Service

<!-- @tags: service, compose, setup, configuration, modules, dependency-injection -->

In Rimitive:
- A **service** is the result of calling `compose()`. It bundles your chosen primitives into an isolated reactive context.
- A **module** is what you provide to `compose()`. Each module provides one or more primitivesâ€”`SignalModule` provides `signal`, `ComputedModule` provides `computed`, and so on. Modules can depend on other modules, and `compose()` bundles everything up into a service where they all share the same underlying reactive graph.

A simple example:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule);
const { signal } = svc;
```

This example demonstrates `compose()`, which:
- takes modules (usually primitive modules in Rimitive)
- returns a fully reactive service with only the modules you provided (in this case, the signal primitive)

Each service has an encapsulated reactive graph inside of it. Using `svc` to represent a service is a convention you'll see used throughout these docs.

This service wouldn't do much on its ownâ€”nothing is connected to react to signal changes yet.

---

## Adding More Primitives

We can add some more primitives that _would_ react to signal updates:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(SignalModule, ComputedModule, EffectModule);
```

Then use them:

```typescript
const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => {
  console.log('Count is now:', count());
});

// ...etc
```

Reactive dependencies are automatically tracked in Rimitive, so you don't need to worry about it.

---

## Why `compose()`?

You might wonder: why not just export these functions directly?

Each `compose()` call creates an independent reactive context with no global leakage. This means:

- **Isolation**: Multiple services don't interfere with each other
- **Testing**: Fresh contexts per test, no cleanup needed
- **Tree-shaking**: Only bundle what you use
- **Extensibility**: Add [view modules](/guides/adding-a-ui), [router](/guides/adding-routing), or [custom modules](/guides/custom-modules) later

---

## Using a Service

Once you've [created a service](/guides/creating-a-service), there are a few ways to use it.

---

## Top-Level

You can safely destructure anything in Rimitive from a service, so it's common to see this:

```typescript
// myService.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(SignalModule, ComputedModule, EffectModule);
const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => {
  console.log(count(), doubled());
});
```

Great for simple scripts or when you only need a single service. In Rimitive, it's also common to export the service as well as the service type directly, which comes in handy _a lot_:

```typescript
// myService.ts

export const svc = compose(SignalModule, ComputedModule, EffectModule);
export const { signal, computed, effect, batch, el, mount } = svc;
export type Service = typeof svc;
```

---

## In a Function

Rimitive makes heavy usage of factory functions that look like components or hooks you might be used to from other frameworks:

```typescript
import { signal } from './myService.ts'

const myCounter = () => {
  const count = signal(0);
  const increment = () => count(count() + 1);

  return { count, increment };
};

const counter = myCounter();
counter.increment();
counter.count(); // 1
```

But a nuance here is that the above is **simply a factory** that instantiates reactive state and returns an api to drive it ðŸš—. In Rimitive, this pattern is called a ["behavior"](/guides/creating-a-behavior), which is conventionally prefixed with `use*` for clarity (ie `useCounter` instead of `myCounter`).

You can stop right here, if that's all you need! For plenty of apps simple apps, behaviors might be enough.

If you want to drive a reactive ui with state, Rimitive also has primitives and patterns to help you with that.

Next up though, let's talk more about the [behavior pattern](/guides/creating-a-behavior).

---

## Adding a UI

You have signals, and maybe some behaviors, so perhaps now we want to add a reactive UI on top of it.

Rimitive provides the `view` package that contains view-specific primitives, with `el()` being the foundation: `el()` is a function for creating elements. It's renderer-agnostic (DOM, native, canvas, whatever), but we'll use the DOM adapter here since that's probably the most common use case.

---

## Extending the Service

Add the view modules to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

export const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // Let's add the `el` and `mount` primitives from the `view` package, and provide the
  // DOM adapter to make DOM elements ðŸ‘‡
  createElModule(createDOMAdapter()),
  MountModule
);
export const { signal, computed, effect, el, mount } = svc;
export type Service = typeof svc;
```

Notice it's the same compose/service pattern as before, just now with more modules!

---

## Creating Elements

`el()` is curried: `el(tag)(children)`. Don't be scurred, it'll make sense, it's all just factories:

```typescript
// Just a div tag
const div = el('div')();

// An h1 with text ("Hello, World" are children)
const heading = el('h1')('Hello, World');

// a div with other `el` children
const container = el('div')(
  el('h1')('Title'),
  el('p')('Some text')
);
```

If you provided a different adapter, then you'd pass different (strongly typed!) strings (like `el('mySpecialElement')`).

---

## Props

Use `.props()` to set reactive attributes and events:

```typescript
const isDisabled = signal(false);

const button = el('button').props({
  className: 'primary',
  disabled: isDisabled,
  onclick: () => console.log('clicked'),
})('Click me');

isDisabled(true);  // button becomes disabled, class changes
```

Props are typesafe and typed based on the element. `el('button')` knows about `disabled`, `onclick`, `type`, etc. These types are driven by the adapter provided, so for the DOM you get things like `button`, whatever, but swap it out or customize the adapter and then you can get all sorts of other things, like custom elements, svg or canvas abstractions, hydration abstractions...whatever you want really.

---

## Reactive Content

Pass a computed for reactive text:

```typescript
const count = signal(0);

const display = el('div')(
  computed(() => `Count: ${count()}`)
);

count(5);  // display updates to "Count: 5"
```

---

## UI Components

The star of the show, UI components in rimitive are...just functions that return elements:

```typescript
const Greeting = (name: string) =>
  el('div')(
    el('h2')(`Hello, ${name}!`),
    el('p')('Welcome to Rimitive.')
  );

const app = el('div')(
  Greeting('Ada'),
  Greeting('Grace')
);
```

That's it, kind of anticlimactic.

---

## With Behaviors

Drive UIs with reactive behavior:

```typescript
import { svc, el, computed } from './service';
import { useCounter } from './behaviors/counter';

const Counter = (initial: number) => {
  const { count, doubled, increment, decrement, reset } = useCounter(initial);

  return el('div')(
    el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),
    el('div')(
      el('button').props({ onclick: decrement })('-'),
      el('button').props({ onclick: increment })('+'),
      el('button').props({ onclick: reset })('Reset')
    )
  );
};

const app = el('div')(
  Counter(0),
  Counter(100)
);
```

Again, `Counter` itself is not a reactive closure. It's not going to re-render. But it's quite nice in a way, isn't it? all your reactive behavior and logic contained in behavior functions, then using the api returned to drive UI specific logic?

But wait, there's more!

---

## Portable Components

Just like behaviors, components can be made portable by wrapping them in a function that receives the service:

```typescript
import type { Service } from './service';
import { counter } from './behaviors/counter';

const Counter = (svc: Service) => {
  const { el, computed } = svc;

  // The service layer is so cyute isn't it??
  const useCounter = svc(counter);

  return (initial: number) => {
    const { count, doubled, increment, decrement, reset } = useCounter(initial);

    return el('div')(
      el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),
      el('div')(
        el('button').props({ onclick: decrement })('-'),
        el('button').props({ onclick: increment })('+'),
        el('button').props({ onclick: reset })('Reset')
      )
    );
  };
};
```

Same shape as portable behaviors: `(svc) => (args) => result`. The outer function is the service layer, the inner function is the component factory.

```typescript
import { svc } from './service';

const CounterComponent = svc(Counter);

const app = el('div')(
  CounterComponent(0),
  CounterComponent(100)
);
```

Can you see what's coming? Components compose other components (or behaviors) in the service layer, just like we saw before:

```typescript
import type { Service } from './service';
import { counter } from './behaviors/counter';
import { Counter } from './Counter';

const Dashboard = (svc: Service) => {
  const { el } = svc;

  // Compose the Counter component in the service layer
  const CounterComponent = svc(Counter);

  return () =>
    el('div')(
      el('h1')('Dashboard'),
      el('div')(
        el('label')('Users: '),
        CounterComponent(0)
      ),
      el('div')(
        el('label')('Sessions: '),
        CounterComponent(100)
      )
    );
};
```

The service layer is where you wire up your dependenciesâ€”behaviors, other components, whatever you need. Then the inner function just uses them.

This is useful for testing, SSR, or sharing components across different service contexts.

---

## Mounting

Use `mount()` to actually attach to the DOM:

```typescript
const App = () => el('div')(
  el('h1')('My App')
);

const app = mount(App());
document.body.appendChild(app.element!);
```

---

## Conditional Rendering

<!-- @tags: match, conditional, show-hide, toggle, switch, if-else, visibility -->

`match()` swaps elements based on a reactive value. When the value changes, the old element is disposed and a new one takes its place.

---

## Adding the Module

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  // Add this ðŸ‘‡
  createMatchModule(adapter),
  MountModule
);

const { el, match, signal, mount } = svc;
```

---

## Show/Hide

Toggle visibility by returning `null`:

```typescript
const showMessage = signal(true);

const message = match(showMessage, (show) =>
  show ? el('div')('Hello!') : null
);

const app = el('div')(
  el('button').props({
    onclick: () => showMessage(!showMessage())
  })('Toggle'),
  message
);
```

---

## Switching Views

Switch between different element types:

```typescript
const isEditMode = signal(false);
const text = signal('Click edit to change');

const content = match(isEditMode, (editing) =>
  editing
    ? el('input').props({ value: text })()
    : el('span')(text)
);

const app = el('div')(
  content,
  el('button').props({
    onclick: () => isEditMode(!isEditMode())
  })(
    computed(() => isEditMode() ? 'Save' : 'Edit')
  )
);
```

---

## Multi-Way Switch

Use a discriminated value for multiple branches:

```typescript
type Tab = 'home' | 'settings' | 'profile';
const currentTab = signal<Tab>('home');

const tabContent = match(currentTab, (tab) => {
  switch (tab) {
    case 'home': return el('div')('Welcome home');
    case 'settings': return el('div')('Settings panel');
    case 'profile': return el('div')('Your profile');
  }
});
```

---

## Rendering Lists

<!-- @tags: map, list, array, foreach, loop, keyed-list, reconciliation, todo-list -->

`map()` renders a reactive list efficiently (_very efficiently_). When items change, it updates only what's necessary. `map()` contains ONLY the reconciliation logic required to deal with rendering dynamic lists efficiently, so again, a small bundle addition.

---

## Adding the Module

First, add the map module to your service:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMapModule } from '@rimitive/view/map';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  // map takes an adapter as well
  createMapModule(adapter),
  MountModule
);

const { el, map, signal, mount } = svc;
```

### Basic Usage

For primitive arrays (strings, numbers), just pass the array and a render function:

```typescript
const items = signal(['Apple', 'Banana', 'Cherry']);

const list = el('ul')(
  map(items, (item) => el('li')(item))
);
```

The render function receives a **reactive signal** wrapping each item. You can pass it directly as a child:

```typescript
map(items, (item) =>
  el('li')(item)  // item is a signal, cool!
)
```

When `items` updates, `map()` reconciles the DOM efficiently, adding, removing, and reordering elements as needed.

### Keyed Lists

For object arrays, provide a key function so `map()` can track identity:

```typescript
type Todo = { id: number; text: string; done: boolean };

const todos = signal<Todo[]>([
  { id: 1, text: 'Learn Rimitive', done: false },
  { id: 2, text: 'Build something', done: false },
]);

const list = el('ul')(
  map(
    todos,
    (todo) => todo.id,  // key function
    (todo) => el('li')(
      el('span')(computed(() => todo().text)),
      el('input').props({
        type: 'checkbox',
        checked: computed(() => todo().done),
      })()
    )
  )
);
```

The key function receives the plain item value and returns a unique identifier. This lets `map()` efficiently update items when the array changes.

### Reactive Item Updates

Each item is wrapped in a signal. When you update an item in the source array, the item signal updates tooâ€”no element recreation needed:

```typescript
const toggleTodo = (id: number) => {
  todos(todos().map(t =>
    t.id === id ? { ...t, done: !t.done } : t
  ));
};

// The checkbox updates reactively without recreating the <li>
```

---

## Portals

`portal()` renders content into a different DOM locationâ€”useful for modals, tooltips, and overlays that need to escape their parent's overflow or z-index context.

---

## Adding the Module

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createPortalModule } from '@rimitive/view/portal';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  createMatchModule(adapter),
  // Add this module ðŸ‘‡
  createPortalModule(adapter),
  MountModule
);

const { el, match, portal, signal, mount } = svc;
```

---

## Basic Portal

Render to `document.body` (the default):

```typescript
const showModal = signal(false);

const modal = match(showModal, (show) =>
  show
    ? portal()(
        el('div').props({ className: 'modal-backdrop' })(
          el('div').props({ className: 'modal' })(
            el('h2')('Modal Title'),
            el('p')('Modal content here...'),
            el('button').props({
              onclick: () => showModal(false)
            })('Close')
          )
        )
      )
    : null
);

const app = el('div')(
  el('button').props({
    onclick: () => showModal(true)
  })('Open Modal'),
  modal  // Rendered to body, not inside this div
);
```

---

## Custom Target

Portal to a specific element:

```typescript
// Portal to a getter
portal(() => document.getElementById('tooltip-root'))(
  el('div').props({ className: 'tooltip' })('Tooltip content')
)
```

Or use a signal ref:

```typescript
const targetRef = signal<HTMLElement | null>(null);

el('div').ref((el) => {
  targetRef(el);
  return () => targetRef(null);
})();

portal(targetRef)(tooltipContent)
```

---

## Event Handling

You've seen `onclick` in props. That works for simple cases. For more complex event handlingâ€”multiple listeners, automatic cleanup, batched updatesâ€”use `on()`.

---

## Basic Props Events

For simple click handlers, props work fine:

```typescript
const count = signal(0);

el('button').props({
  onclick: () => count(count() + 1)
})('Click me')
```

This attaches the handler directly to the element. Simple and direct.

---

## The on() Helper

`on()` provides automatic cleanup and batching. When multiple signals update in a handler, batching ensures only one re-render.

Add the on module:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule, BatchModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { OnModule } from '@rimitive/view/deps/addEventListener';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  BatchModule,
  createElModule(adapter),
  OnModule,
  MountModule
);

const { el, on, signal, mount } = svc;
```

### Using on() with .ref()

`on()` returns a lifecycle callback for use with `.ref()`:

```typescript
const count = signal(0);

const button = el('button').ref(
  on('click', () => count(count() + 1))
)('Click me');
```

When the element is removed from the DOM, the listener is automatically cleaned up.

### Multiple Listeners

Stack multiple `on()` calls:

```typescript
const input = el('input')
  .ref(
    on('focus', () => console.log('focused')),
    on('blur', () => console.log('blurred')),
    on('input', (e) => handleInput(e))
  )();
```

Each listener is independently attached and cleaned up.

---

## Input Handling

A common patternâ€”controlled inputs with `on()`:

```typescript
const text = signal('');

const input = el('input')
  .props({
    type: 'text',
    value: text,
  })
  .ref(
    on('input', (e) => text((e.target as HTMLInputElement).value))
  )();
```

The `value` prop binds the input's value to the signal. The `on('input')` handler updates the signal when the user types.

### Form Submission

Handle Enter key and form submission:

```typescript
const searchQuery = signal('');

const handleSubmit = () => {
  console.log('Searching for:', searchQuery());
  // perform search...
};

const searchInput = el('input')
  .props({
    type: 'text',
    placeholder: 'Search...',
    value: searchQuery,
  })
  .ref(
    on('input', (e) => searchQuery((e.target as HTMLInputElement).value)),
    on('keydown', (e) => {
      if (e.key === 'Enter') handleSubmit();
    })
  )();

const searchButton = el('button').ref(
  on('click', handleSubmit)
)('Search');
```

---

## Automatic Batching

When a handler updates multiple signals, `on()` batches them into a single update:

```typescript
const firstName = signal('');
const lastName = signal('');
const loading = signal(false);

const handleSubmit = () => {
  // All three updates batched into one render
  firstName('');
  lastName('');
  loading(true);
};

el('button').ref(
  on('click', handleSubmit)
)('Submit')
```

Without batching, this would trigger three separate updates. With `on()`, it's one.

### Why Batching Matters

Consider a form with derived state:

```typescript
const firstName = signal('John');
const lastName = signal('Doe');
const fullName = computed(() => `${firstName()} ${lastName()}`);

// Display updates once, not twice
el('button').ref(
  on('click', () => {
    firstName('Jane');
    lastName('Smith');
  })
)('Change Name')
```

The `fullName` computed only recalculates once after both signals update.

---

## Event Options

Pass standard addEventListener options as the third argument:

```typescript
// Capture phase
on('click', handler, { capture: true })

// Once only
on('click', handler, { once: true })

// Passive (for scroll performance)
on('scroll', handler, { passive: true })
```

---

## Creating a Behavior

<!-- @tags: behavior, hook, reusable-logic, headless, state-management, portable -->

A **behavior** is, like many things in rimitive, simply a pattern. It's a function that encapsulates reactive state, with actions to drive that state, into a reusable unit. Again, no UI or component framework, just a nice convention to encapsulate reactive logic.

---

## The Simple Approach

The easiest way to create a behavior is to import primitives directly from your service:

```typescript
// behaviors/useCounter.ts
import { signal, computed } from '../service';

// Again, use* is just a convention, this is not prescribed and not React!
export const useCounter = (initial = 0) => {
  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

Use it anywhere:

```typescript
import { useCounter } from './behaviors/useCounter';

const counter = useCounter(10);
counter.increment();
counter.count();  // 11
```

---

<!-- @tags: portable, service-injection, testable, ssr, dependency-injection -->

## The Portable Pattern

When you need behaviors that work across different contextsâ€”testing with mocks, sharing between apps, or SSRâ€”use the portable pattern. This is, generally speaking, the preferred pattern.

### The Shape

```typescript
// Remember how we exported `typeof svc` in the previous guide example?
import type { Service } from './service';

// The "portable" pattern is...just wrapping your behavior in an outer
// function that injects the service
const myPortableBehavior = (svc: Service) => (options?) => {
  // Create state
  // Return API
};
```

This silly little pattern doesn't look like much but opens up a whole world of fun possibilities. It also decouples your function from Rimitive! you could pass in whatever you want for `svc` later, as long as it matches the Service type. So from now on, we'll be working with portable functions.

### A Counter Example

```typescript
import type { Service } from './service';

const counter = ({ signal, computed }: Service) => (initial = 0) => {
  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

### Using It

```typescript
import { svc } from './service';

// Oh look! svc itself is callable and injects the svc for you! Neat!
const useCounter = svc(counter);
const c = useCounter(10);

c.count();
c.increment();
c.doubled();
```

`svc(counter)` provides (or injects) the service (and is type safe). Then you have a ready-to-use behavior bound to your service that you can name whatever you want. Again, by convention (NOT prescription) we prefix with `use*` for nice semantics and ergonomics.

---

<!-- @tags: compose-behaviors, disclosure, dropdown, service-layer, reuse -->

## Composing Behaviors

The double-function behavior pattern is quite powerful for composition. Behaviors can easily compose other behaviors. To demonstrate this, let's start with a basic portable behavior:

```typescript
const disclosure = ({ signal }: Service) => (initialOpen = false) => {
  const isOpen = signal(initialOpen);

  return {
    isOpen,
    open: () => isOpen(true),
    close: () => isOpen(false),
    toggle: () => isOpen(!isOpen()),
  };
};
```

Now, we can compose it:

```typescript
const dropdown = (svc: Service) => {
  // Another convention is to use the outer function as a "service layer", but you could
  // do this in the return function if you don't mind it running on every mount.
  const useDisclosure = svc(disclosure);

  return (options?: { initialOpen?: boolean }) => {
    const disc = useDisclosure(options?.initialOpen ?? false);

    // Add keyboard handling
    // Look ma, no memoization required!
    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      disc.toggle();
    };

    return {
      ...disc,
      onKeyDown,
    };
  };
};
```

Now `dropdown` composes `disclosure`! They both use the same behavior shape of `(svc) => (args) => api`, but one composes the other. In rimitive, we call the outer function the **service layer**. It's a convenient place to inject services a single time.

---

<!-- @tags: testing, vitest, unit-test, behavior-test -->

## Testing

Behaviors are trivial to test. Just import your service:

```typescript
import { describe, it, expect } from 'vitest';
import { svc } from './service';

describe('counter', () => {
  it('increments', () => {
    const c = svc(counter)(0);

    c.increment();
    c.increment();

    expect(c.count()).toBe(2);
  });

  it('respects initial value', () => {
    const c = svc(counter)(50);

    expect(c.count()).toBe(50);
    c.reset();
    expect(c.count()).toBe(50);
  });
});
```

Pure functions, pure tests. Again, if this is all you need, you can stop here. If you want a reactive UI and UI components, as the kids say, "let's gooooo".

---

## Adding Routing

Routing in Rimitive is simply reactive state. The router tracks the provided URL and matches it against your route definitions. You render different views by reacting to those matches.

---

## The Simplest Router

Start with just route definitions and a router:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';
import { createRouterModule } from '@rimitive/router';

// Define routes - pure data
const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
];

// Compose with router
const svc = compose(
  SignalModule,
  ComputedModule,
  // Add this ðŸ‘‡
  createRouterModule(routes)
);

const { router } = svc;
```

The router gives you reactive signals:

```typescript
router.currentPath();  // '/' or '/about'
router.matches();      // [{ id: 'home', pattern: '/', params: {}, path: '/' }]
```

Navigate programmatically:

```typescript
router.navigate('/about');
router.currentPath();  // '/about'
router.matches();      // [{ id: 'about', pattern: '/about', params: {}, path: '/about' }]
```

That's the core: routes in, reactive matches out.

---

## Rendering Routes

Use `match()` to render based on the matched route:

```typescript
// Page components
const Home = () => el('div')(
  el('h1')('Home'),
  el('p')('Welcome!')
);

const About = () => el('div')(
  el('h1')('About'),
  el('p')('Learn more about us.')
);

const NotFound = () => el('div')(
  el('h1')('404'),
  el('p')('Page not found.')
);

// Route â†’ component mapping
const pages = {
  home: Home,
  about: About,
};

// App with routing
const App = () => el('div')(
  match(router.matches, (matches) => {
    const route = matches[0];
    if (!route) return NotFound();

    const Page = pages[route.id];
    return Page ? Page() : NotFound();
  })
);

const app = mount(App());
document.body.appendChild(app.element!);
```

When `router.matches` changes, `match()` swaps the rendered component.

---

## Adding Navigation

Use `Link` for declarative navigation that works with the router:

```typescript
import { Link } from '@rimitive/router/link';

const Nav = () => el('nav')(
  Link({ href: '/' })('Home'),
  Link({ href: '/about' })('About')
);

const App = () => el('div')(
  Nav(),
  el('main')(
    match(router.matches, (matches) => {
      const route = matches[0];
      if (!route) return NotFound();
      const Page = pages[route.id];
      return Page ? Page() : NotFound();
    })
  )
);
```

`Link` renders an `<a>` tag that intercepts clicks and calls `router.navigate()` instead of doing a full page reload.

For programmatic navigation, use `router.navigate()` directly:

```typescript
const Home = () => el('div')(
  el('h1')('Home'),
  el('button').props({
    onclick: () => router.navigate('/about')
  })('Go to About')
);
```

---

## Route Parameters

Capture dynamic segments with `:param` syntax:

```typescript
const routes = [
  { id: 'home', path: '' },
  { id: 'products', path: 'products' },
  { id: 'product-detail', path: 'products/:id' },
];
```

When the URL is `/products/123`, the match includes the parameter:

```typescript
router.navigate('/products/123');
router.matches();
// [{ id: 'product-detail', pattern: '/products/:id', params: { id: '123' }, path: '/products/123' }]
```

Use the params in your component:

```typescript
const ProductDetail = (params: { id: string }) => el('div')(
  el('h1')(`Product ${params.id}`),
  el('p')('Product details here...')
);

// In the router match
match(router.matches, (matches) => {
  const route = matches[0];
  if (!route) return NotFound();

  if (route.id === 'product-detail') {
    return ProductDetail(route.params as { id: string });
  }

  const Page = pages[route.id];
  return Page ? Page() : NotFound();
});
```

---

## Query Strings

The router parses query strings into reactive signals:

```typescript
// URL: /products?sort=price&category=electronics

router.search();  // '?sort=price&category=electronics'
router.query();   // { sort: 'price', category: 'electronics' }
```

React to query changes:

```typescript
const Products = () => {
  const sortOrder = computed(() => router.query().sort || 'name');

  return el('div')(
    el('h1')('Products'),
    el('p')(computed(() => `Sorted by: ${sortOrder()}`)),
    el('button').props({
      onclick: () => router.navigate('/products?sort=price')
    })('Sort by Price')
  );
};
```

---

## Active Link Styling

Use `router.currentPath` to style the active link:

```typescript
const NavLink = (href: string, label: string) => {
  const isActive = computed(() => router.currentPath() === href);

  return Link({
    href,
    className: computed(() => isActive() ? 'nav-link active' : 'nav-link')
  })(label);
};

const Nav = () => el('nav')(
  NavLink('/', 'Home'),
  NavLink('/about', 'About'),
  NavLink('/products', 'Products')
);
```

Routes are data, and matching is reactive. Rendering is just `match()` on `router.matches`, and everything composes with the same patterns you've already learned!

---

## Loading Data

<!-- @tags: resource, fetch, async, data-loading, api, http, loading-state, error-state -->

Data loading in Rimitive is reactive. When dependencies change, data refetches. When requests overlap, stale ones get cancelled. Let's build up to that.

---

## The Manual Way

You _could_ manage async state yourself with signals and effects:

```typescript
const ProductList = (svc: Service) => {
  const { signal, effect, el } = svc;

  return () => {
    const loading = signal(true);
    const data = signal<Product[]>([]);
    const error = signal<Error | null>(null);

    effect(() => {
      loading(true);
      fetch('/api/products')
        .then(r => r.json())
        .then(items => {
          data(items);
          loading(false);
        })
        .catch(err => {
          error(err);
          loading(false);
        });
    });

    return el('div')(/* render based on loading/data/error */);
  };
};
```

This works, but you're managing three signals, handling errors, and there's no cancellation. When dependencies change mid-flight, you get race conditions.

---

## The resource() Primitive

`resource()` handles all of that. Add the resource module to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { ResourceModule } from '@rimitive/resource';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';

const adapter = createDOMAdapter();

export const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  ResourceModule,
  createElModule(adapter),
  createMatchModule(adapter)
);

export type Service = typeof svc;
```

---

## Basic Usage

Create a resource inside your component with a fetcher function:

```typescript
const ProductList = (svc: Service) => {
  const { resource, el, match } = svc;

  return () => {
    const products = resource<Product[]>((signal) =>
      fetch('/api/products', { signal }).then(r => r.json())
    );

    return el('div').ref(() => () => products.dispose())(
      match(products, (state) => {
        switch (state.status) {
          case 'pending':
            return el('div')('Loading...');
          case 'error':
            return el('div')(`Error: ${state.error}`);
          case 'ready':
            return el('ul')(
              ...state.value.map(p => el('li')(p.name))
            );
        }
      })
    );
  };
};
```

Key points:
- The fetcher receives an `AbortSignal` - pass it to `fetch()` for automatic cancellation
- Create resources **inside the factory function**, not at module level
- Call `dispose()` when the component unmounts to abort in-flight requests

### Reading State

A resource has multiple ways to read its state:

```typescript
// Full state object
products();
// { status: 'idle' }     // when enabled=false
// { status: 'pending' }
// { status: 'ready', value: [...] }
// { status: 'error', error: Error }

// Convenience accessors
products.idle();     // true when disabled
products.loading();  // true when pending
products.data();     // T | undefined
products.error();    // unknown | undefined
```

All are reactiveâ€”use them in computeds or effects.

---

<!-- @tags: reactive-fetch, auto-refetch, dependency-tracking, abort-controller, cancellation -->

## Reactive Dependencies

Here's where resources shine. Read signals inside the fetcher, and the resource refetches when they change:

```typescript
const ProductList = (svc: Service) => {
  const { signal, resource, el, match } = svc;

  return (initialCategory: string) => {
    const category = signal(initialCategory);

    const products = resource<Product[]>((signal) =>
      fetch(`/api/products?category=${category()}`, { signal })
        .then(r => r.json())
    );

    return el('div').ref(() => () => products.dispose())(
      el('div')(
        el('button').props({ onclick: () => category('electronics') })('Electronics'),
        el('button').props({ onclick: () => category('books') })('Books')
      ),
      match(products, (state) => {
        // ... render based on state
      })
    );
  };
};
```

When `category` changes:
1. The previous request is automatically aborted
2. A new fetch starts with the updated category
3. No race conditions, no stale data

### Multiple Dependencies

Track as many signals as you need:

```typescript
const ProductList = (svc: Service) => {
  const { signal, resource } = svc;

  return () => {
    const category = signal('electronics');
    const sortBy = signal('price');
    const page = signal(1);

    const products = resource<Product[]>((signal) =>
      fetch(
        `/api/products?category=${category()}&sort=${sortBy()}&page=${page()}`,
        { signal }
      ).then(r => r.json())
    );

    // Any change triggers a refetch with automatic cancellation
    // category('books');   // refetch
    // sortBy('rating');    // refetch
    // page(2);             // refetch

    return el('div').ref(() => () => products.dispose())(
      // ... render with filters and pagination controls
    );
  };
};
```

---

<!-- @tags: loading-ui, error-ui, loading-spinner, skeleton, status -->

## Rendering Resources

Use `match()` to render based on resource state:

```typescript
const UserProfile = (svc: Service) => {
  const { resource, el, match, computed } = svc;

  return (userId: string) => {
    const user = resource<User>((signal) =>
      fetch(`/api/users/${userId}`, { signal }).then(r => r.json())
    );

    return el('div').ref(() => () => user.dispose())(
      match(user, (state) => {
        switch (state.status) {
          case 'idle':
            return null; // Resource disabled
          case 'pending':
            return el('div').props({ className: 'skeleton' })('Loading profile...');
          case 'error':
            return el('div').props({ className: 'error' })(
              `Failed to load: ${state.error}`
            );
          case 'ready':
            return el('div')(
              el('h1')(state.value.name),
              el('p')(state.value.email)
            );
        }
      })
    );
  };
};
```

---

## Refetch and Dispose

### Manual Refetch

Trigger a refetch programmatically (useful for "refresh" buttons or after mutations):

```typescript
const ProductList = (svc: Service) => {
  const { resource, el, match } = svc;

  return () => {
    const products = resource<Product[]>((signal) =>
      fetch('/api/products', { signal }).then(r => r.json())
    );

    return el('div').ref(() => () => products.dispose())(
      el('button').props({ onclick: () => products.refetch() })('Refresh'),
      match(products, (state) => {
        // ... render
      })
    );
  };
};
```

### Cleanup

Always dispose resources when the component unmounts. The `.ref()` callback pattern works well:

```typescript
return el('div').ref(() => {
  // Return cleanup function
  return () => products.dispose();
})(
  // ... children
);
```

This aborts any in-flight request and stops dependency tracking.

---

## Options

### enabled

Control whether the resource fetches with the `enabled` option:

```typescript
const ProductList = (svc: Service) => {
  const { signal, resource, el } = svc;

  return (selectedId: string | null) => {
    const id = signal(selectedId);

    // Only fetch when we have an ID
    const product = resource<Product>(
      (s) => fetch(`/api/products/${id()}`, { signal: s }).then(r => r.json()),
      { enabled: () => id() !== null }
    );

    // product.idle() is true when disabled
    return el('div').ref(() => () => product.dispose())(
      product.idle()
        ? el('p')('Select a product')
        : el('p')(product.data()?.name ?? 'Loading...')
    );
  };
};
```

`enabled` accepts a boolean or a reactive function. When false, the resource stays in `idle` state. When it becomes true, fetching begins.

#### Lazy Fetching

Use `enabled` to defer fetching until a user action:

```typescript
const ReportViewer = (svc: Service) => {
  const { signal, resource, el, match } = svc;

  return (reportId: string) => {
    const shouldLoad = signal(false);

    const report = resource<Report>(
      (s) => fetch(`/api/reports/${reportId}`, { signal: s }).then(r => r.json()),
      { enabled: shouldLoad }
    );

    return el('div').ref(() => () => report.dispose())(
      match(report, (state) => {
        if (state.status === 'idle') {
          return el('button').props({ onclick: () => shouldLoad(true) })(
            'Load Report'
          );
        }
        if (state.status === 'pending') return el('p')('Loading...');
        if (state.status === 'error') return el('p')(`Error: ${state.error}`);
        return el('div')(/* render report */);
      })
    );
  };
};
```

The resource stays idle until the user clicks "Load Report", then fetches.

### flush

Control when refetches execute with the `flush` option:

```typescript
import { mt, debounce } from '@rimitive/signals/strategies';

// Defer refetches to microtask (coalesces rapid updates)
const products = resource(fetcher, { flush: mt });

// Debounce refetches (useful for search-as-you-type)
const results = resource(
  (s) => fetch(`/api/search?q=${query()}`, { signal: s }).then(r => r.json()),
  { flush: (run) => debounce(300, run) }
);
```

Without `flush`, refetches are synchronousâ€”each dependency change triggers an immediate fetch. With a flush strategy, rapid updates are coalesced.

---

## resource() vs load()

Rimitive has two primitives for async data:

| | `resource()` | `load()` |
|---|---|---|
| **Use case** | Client-side data fetching | Server-rendered data with hydration |
| **Reactive deps** | Yesâ€”refetches when signals change | Noâ€”fetches once |
| **Cancellation** | Automatic via AbortSignal | No |
| **SSR support** | No | Yesâ€”data serializes for hydration |

**Use `resource()` when:**
- Building a client-only app
- Data depends on user interaction (filters, pagination, search)
- You need automatic refetching and cancellation

**Use `load()` when:**
- You're doing SSR and want data in the initial HTML
- The data should be fetched on the server and reused on the client
- SEO or first-paint performance matters for this data

<Aside type="caution" title="SSR Note">
`resource()` starts fetching immediately when created. In SSR apps:

- Use `load()` for data that should be server-rendered
- Use `resource()` for client-side dynamic data (filters, search, user interactions)
- For client-only resources, use the `enabled` option or a flush strategy:

```typescript
// Option 1: enabled (resource stays idle on server)
const data = resource(fetcher, {
  enabled: () => typeof window !== 'undefined'
});

// Option 2: flush strategy (runs once on server, no re-runs)
const data = resource(fetcher, { flush: mt });
```
</Aside>

In an SSR app, you might use both: `load()` for the initial page data that should be server-rendered, and `resource()` for dynamic data that loads after user interaction.

See [SSR with Data Loading](/guides/ssr-loading) for `load()` usage.

---

## Server Rendering

This guide covers the practical setup for basic SSR. If you're new to SSR concepts, read [Intro to SSR](/guides/intro-to-ssr) first.

---

## Render Functions

Rimitive provides three render functions for different SSR needs:

| Function | Use Case |
|----------|----------|
| `renderToString` | Basic sync SSR â€” no async data loading |
| `renderToStringAsync` | Waits for all `load()` boundaries before returning HTML |
| `renderToStream` | Sends HTML immediately, streams data as it loads |

This guide covers `renderToString`. For async data loading, see [SSR with Data Loading](/guides/ssr-loading). For streaming, see [Streaming SSR](/guides/streaming-ssr).

---

## What You Need

For basic SSR, you need:
1. A **server adapter** that creates elements using linkedom instead of the real DOM
2. A **client hydration adapter** that walks existing DOM instead of creating new elements

---

## Shared Service

Start with creating the service a little differently than normal. This time, `createService()` will take an adapter, so both the server and client can use the same service for running:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

//                            ðŸ‘‡ New!
export function createService(adapter: Adapter<DOMAdapterConfig>) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter)
  );
}

export type Service = ReturnType<typeof createService>;
```

Now, this file can be shared with both the server and the client âœ¨

## Server Setup

`createLinkedomAdapter()` creates a server-friendly adapter powered by [linkedom](https://github.com/WebReflection/linkedom), a lightweight DOM implementation for Node.js. When `el("div")` runs on the server, it creates a linkedom element instead of a real DOM elementâ€”same structure, no browser required.

Create a fresh adapter and service for each incoming request. Reusing them across requests would cause data from one user to leak into another's response.

```typescript
// server.ts
import { createServer } from 'node:http';
import { createLinkedomAdapter, renderToString } from '@rimitive/ssr/server';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer((req, res) => {
  // Create per-request adapter and service
  const { adapter, serialize } = createLinkedomAdapter();
  const service = createService(adapter);

  // Create and render the app
  const root = App(service).create(service);
  const html = renderToString(root, serialize);

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`<!DOCTYPE html>
<html>
<body>
  <div class="app">${html}</div>
  <script src="/client.js"></script>
</body>
</html>`);
});

server.listen(3000);
```

### What happens:

1. `createLinkedomAdapter()` returns an `adapter` (for creating elements) and `serialize` (for converting individual elements to HTML)
2. `createService(adapter)` wires up your app with the server adapter
3. `App(service).create(service)` runs your app, building a linkedom element tree
4. `renderToString(root, serialize)` walks the tree and converts it to an HTML string

Finally the HTML is sent to the client (and your `<script>` tag loads the client bundle).

---

## Next Steps

- **[Client Hydration](/guides/client-hydration)** â€” Make the server-rendered HTML interactive
- **[SSR with Data Loading](/guides/ssr-loading)** â€” Fetch data during SSR with `load()`
- **[Streaming SSR](/guides/streaming-ssr)** â€” Send HTML progressively as data loads

---

## Streaming SSR

This guide builds on [SSR with Data Loading](/guides/ssr-loading). Make sure you understand `load()` and basic SSR setup first.

---

## Why Streaming?

With `renderToStringAsync`, the server waits for **all** data before sending anything. That's fine when data loads quickly, but if one API takes 3 seconds, users stare at a blank screen for 3 seconds.

**Streaming SSR** sends the page shell immediately, then streams data chunks as each `load()` boundary resolves. Users see content faster, especially when some data sources are slow.

```
SERVER
  â”‚
  â”œâ”€ App runs, creates load() boundaries with pending states
  â”œâ”€ Sends initial HTML immediately (loading UI visible)
  â”‚
  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HTML Shell â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Users see loading UI
  â”‚
  â”œâ”€ load() #1 resolves â†’ stream chunk
  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ <script>data1</script> â”€â”€â–º  UI updates
  â”‚
  â”œâ”€ load() #2 resolves â†’ stream chunk
  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ <script>data2</script> â”€â”€â–º  UI updates
  â”‚
  â””â”€ All done, close response
```

Signals update the UI. The server streams data, the client pushes it to signals, and Rimitive handles the rest.

---

## The Stream Writer

Streaming needs a way to send data from server to client as it becomes available. `createStreamWriter` generates the JavaScript for this:

```typescript
import { createStreamWriter } from '@rimitive/ssr/server';

const stream = createStreamWriter('__APP_STREAM__');

// Bootstrap code goes in <head> - sets up the receiver
stream.bootstrapCode();
// â†’ "window.__APP_STREAM__=(function(){...})();"

// Chunk code is sent as data resolves - pushes to the receiver
stream.chunkCode('stats', { users: 100 });
// â†’ "__APP_STREAM__.push(\"stats\",{\"users\":100});"
```

The receiver queues data until the client calls `connectStream()`, then forwards chunks to the loader.

---

## Server Setup

Use `renderToStream` instead of `renderToStringAsync`:

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createLinkedomAdapter,
  renderToStream,
  createStreamWriter,
} from '@rimitive/ssr/server';
import type { RefSpec } from '@rimitive/view/types';
import { createService } from './service.js';
import { App } from './App.js';

const STREAM_KEY = '__APP_STREAM__';
const stream = createStreamWriter(STREAM_KEY);

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } = createLinkedomAdapter();

  // Create service with streaming callback
  const service = createService(adapter, {
    onResolve: (id, data) => {
      // Stream each data chunk as it resolves
      res.write(`<script>${stream.chunkCode(id, data)}</script>`);
    },
  });

  // Render with pending states
  const { initialHtml, done, pendingCount } = renderToStream(
    App(service),
    {
      mount: (spec: RefSpec<unknown>) => spec.create(service),
      serialize,
      insertFragmentMarkers,
    }
  );

  // Start response immediately
  res.writeHead(200, { 'Content-Type': 'text/html' });

  // Write document head with bootstrap script
  res.write(`<!DOCTYPE html>
<html>
<head>
  <script>${stream.bootstrapCode()}</script>
</head>
<body>`);

  // Write initial HTML (with loading states)
  res.write(`<div class="app">${initialHtml}</div>`);

  // Write client script
  res.write('<script src="/client.js"></script>');

  // Wait for all data to stream
  await done;

  // Close document
  res.write('</body></html>');
  res.end();
});

server.listen(3000);
```

### What's different from async SSR:

| Async SSR | Streaming SSR |
|-----------|---------------|
| `renderToStringAsync` waits for all data | `renderToStream` returns immediately |
| One HTML response at the end | HTML shell + data chunks over time |
| No `onResolve` needed | `onResolve` streams each chunk |
| Simpler setup | More responsive UX |

---

## Service with Streaming

Add `onResolve` to your service options and pass it through to `createLoaderModule`:

```typescript
// service.ts - add to your existing ServiceOptions
export type ServiceOptions = {
  hydrationData?: Record<string, unknown>;
  onResolve?: (id: string, data: unknown) => void;  // ðŸ‘ˆ Add this
};

// Pass it through to the loader
createLoaderModule({
  initialData: options?.hydrationData,
  onResolve: options?.onResolve,  // ðŸ‘ˆ Add this
})
```

See the [SSR with Data Loading](/guides/ssr-loading) service setup for the full example.

---

## Client Setup

The client hydrates, then connects to the stream to receive data chunks:

```typescript
// client.ts
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import {
  createDOMHydrationAdapter,
  createHydrationAdapter,
  connectStream,
} from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

const STREAM_KEY = '__APP_STREAM__';

// Create hydration adapter (same as basic SSR)
const hydrationAdapter = createHydrationAdapter(
  createDOMHydrationAdapter(document.querySelector('.app')!),
  createDOMAdapter()
);

// Create service (no hydrationData - data comes via stream instead)
const service = createService(hydrationAdapter);

// Hydrate the app
App(service).create(service);

// Switch to normal DOM mode
hydrationAdapter.switchToFallback();

// Connect to the stream to receive data chunks
connectStream(service, STREAM_KEY);
```

### What happens:

1. Hydration adapter walks existing DOM, attaches reactivity
2. `switchToFallback()` switches to normal DOM mode for future updates
3. `connectStream()` flushes any queued chunks and wires up the loader to receive future chunks
4. As chunks arrive, signals update and the UI re-renders automatically

---

## Using load() with Streaming

Components use `load()` exactly the same as [basic async SSR](/guides/ssr-loading#using-load). The difference is what happens on the server:

| Basic Async SSR | Streaming SSR |
|-----------------|---------------|
| Server waits for `fetchStats` | Server sends `pending` HTML immediately |
| Full HTML sent after 2s | Skeleton UI visible instantly |
| â€” | Data chunk streams when ready |
| â€” | Signal updates, UI re-renders |

Your component code doesn't changeâ€”only the server orchestration differs.

---

## Error Handling

Errors in `load()` boundaries work the same as [basic async SSR](/guides/ssr-loading#error-handling). With streaming:

1. If a fetch fails, `onResolve` isn't called for that boundary
2. The `done` promise still resolves (one error doesn't break other boundaries)
3. The error state renders on the client via `state.error()`

For server-level errors, wrap the response:

```typescript
const server = createServer(async (req, res) => {
  try {
    // ... streaming setup
    await done;
    res.write('</body></html>');
    res.end();
  } catch (err) {
    console.error('Streaming error:', err);
    if (!res.headersSent) {
      res.writeHead(500);
      res.end('Server Error');
    } else {
      res.end(); // Headers sent, close gracefully
    }
  }
});
```

---

## Complete Example

A working streaming example with multiple `load()` boundaries that resolve at different times:

```typescript
// App.ts - Multiple load() boundaries with different speeds
export const App = (svc: Service) => {
  const { loader, match, el } = svc;

  return el('div')(
    // Fast - 100ms
    loader.load('user', fetchUser, (state) =>
      match(state.status, (s) => {
        if (s === 'pending') return el('div')('Loading user...');
        if (s === 'error') return el('div')('Error');
        return el('div')(`Welcome, ${state.data()!.name}!`);
      })
    ),

    // Slow - 3s
    loader.load('news', fetchNews, (state) =>
      match(state.status, (s) => {
        if (s === 'pending') return el('div')('Loading news...');
        if (s === 'error') return el('div')('Error');
        return el('ul')(...state.data()!.headlines.map(h => el('li')(h)));
      })
    )
  );
};
```

With streaming:
1. User sees "Loading user..." and "Loading news..." immediately
2. After 100ms, user greeting appears (first chunk streamed)
3. After 3s, news list appears (second chunk streamed)

---

## When to Use Streaming

| Use Streaming When | Use Basic Async SSR When |
|--------------------|--------------------------|
| Some data sources are slow (> 500ms) | All data loads quickly |
| Users should see content ASAP | SEO crawlers need complete HTML |
| Page has independent data regions | Simplicity matters more than speed |

---

## Custom Modules

Rimitive's composition system isn't limited to the built-in primitives. You can define your own modules with `defineModule` and compose them alongside signals, view, or anything else.

---

## Defining a Module

A module needs a `name` and a `create` function:

```typescript
import { defineModule, compose } from '@rimitive/core';

const LoggerModule = defineModule({
  name: 'logger',
  create: () => ({
    log: (msg: string) => console.log(`[LOG] ${msg}`),
    error: (msg: string) => console.error(`[ERROR] ${msg}`),
  }),
});

const svc = compose(LoggerModule);
svc.logger.log('hello');
```

The `name` becomes the key on the composed service. Whatever `create` returns becomes the value.

---

## Modules with Dependencies

Modules can depend on other modules. List them in `dependencies`, and they'll be available in `create`:

```typescript
import { defineModule, compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';

const CounterModule = defineModule({
  name: 'counter',
  dependencies: [SignalModule, ComputedModule],
  create: ({ signal, computed }) => (initial = 0) => {
    const count = signal(initial);
    const doubled = computed(() => count() * 2);
    return {
      count,
      doubled,
      increment: () => count(count() + 1),
      decrement: () => count(count() - 1),
    };
  },
});

const svc = compose(CounterModule);
const myCounter = svc.counter(10);

myCounter.count();      // 10
myCounter.increment();
myCounter.count();      // 11
myCounter.doubled();    // 22
```

Dependencies are resolved automatically. You only need to pass the modules you wantâ€”`compose()` includes transitive dependencies.

---

## Module Lifecycle

Modules can hook into lifecycle events:

```typescript
const ConnectionModule = defineModule({
  name: 'connection',
  create: () => {
    const ws = new WebSocket('wss://example.com');
    return {
      send: (msg: string) => ws.send(msg),
      socket: ws,
    };
  },
  init: (ctx) => {
    // Called before create, useful for setup
  },
  destroy: (ctx) => {
    // Called when svc.dispose() is invoked
  },
});

const svc = compose(ConnectionModule);
// ... use the connection
svc.dispose(); // triggers destroy hooks
```

---

## Beyond Reactivity

Here's the thing: `@rimitive/core` has no concept of reactivity. It's just a composition mechanism. You can use it for anything:

```typescript
import { defineModule, compose } from '@rimitive/core';

const HttpModule = defineModule({
  name: 'http',
  create: () => ({
    get: (url: string) => fetch(url).then(r => r.json()),
    post: (url: string, data: unknown) =>
      fetch(url, { method: 'POST', body: JSON.stringify(data) }).then(r => r.json()),
  }),
});

const CacheModule = defineModule({
  name: 'cache',
  create: () => {
    const store = new Map<string, unknown>();
    return {
      get: <T>(key: string): T | undefined => store.get(key) as T,
      set: <T>(key: string, value: T): void => { store.set(key, value); },
      clear: () => store.clear(),
    };
  },
});

const ApiModule = defineModule({
  name: 'api',
  dependencies: [HttpModule, CacheModule],
  create: ({ http, cache }) => ({
    async getUser(id: string) {
      const cached = cache.get<User>(`user:${id}`);
      if (cached) return cached;

      const user = await http.get(`/api/users/${id}`);
      cache.set(`user:${id}`, user);
      return user;
    },
  }),
});

const svc = compose(ApiModule);
await svc.api.getUser('123');
```

This makes `compose()` useful for any library or application architectureâ€”not just UI frameworks. You control what gets composed.

---

## Tree-Shaking

Because you explicitly compose modules, everything is fully tree-shakeable. If you don't use `EffectModule`, it won't be in your bundle. If you only need signals without a view, just compose signals:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule, ComputedModule);
// No view code bundled
```

---

## When to Create Modules

Create a module when you want to:

- **Add new primitives** to the composed service
- **Share infrastructure** (logging, http, storage) across behaviors
- **Encapsulate setup/teardown** with lifecycle hooks
- **Build your own libraries** on top of composition

For reusable reactive logic, prefer [behaviors](/guides/creating-a-behavior). Behaviors are simpler and don't require `defineModule`. Use modules when you need something that lives at the composition level.

---

## Signal Patterns

<!-- @tags: signal, updater, toggle, previous-value, debounce, async-action, derived-state -->

Signals are simpleâ€”read with `sig()`, write with `sig(value)`. But there are patterns that make them more ergonomic for common use cases.

---

## Updater Functions

Signals accept functions for updates based on the previous value:

```typescript
const count = signal(0);

// Direct update
count(5);

// Updater function: receives previous value, returns new value
count(c => c + 1);  // increment
count(c => c * 2);  // double
count(c => Math.max(0, c - 1));  // decrement, minimum 0
```

This is particularly useful for arrays and objects:

```typescript
const items = signal<Item[]>([]);

// Append
items(arr => [...arr, newItem]);

// Remove by id
items(arr => arr.filter(x => x.id !== id));

// Update one item
items(arr => arr.map(x => x.id === id ? { ...x, done: true } : x));

// Toggle a property
items(arr => arr.map(x => x.id === id ? { ...x, done: !x.done } : x));
```

---

## Derived Actions

The standard behavior pattern returns an object with state and actions:

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};

const { count, increment, decrement } = svc(counter)(0);
```

An alternative: attach actions directly to the signal:

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);

  return Object.assign(count, {
    increment: () => count(c => c + 1),
    decrement: () => count(c => c - 1),
    reset: () => count(initial),
  });
};

// Usage - no destructuring needed
const count = svc(counter)(0);

count();           // read: 0
count(5);          // write: 5
count.increment(); // action: 6
count.reset();     // action: 0
```

This works because signals are functions, and functions are objects that can have properties.

---

## Toggle

A common case of derived actionsâ€”boolean signals with on/off/toggle:

```typescript
const toggle = (svc: SignalsSvc) => (initial = false) => {
  const value = svc.signal(initial);

  return Object.assign(value, {
    on: () => value(true),
    off: () => value(false),
    toggle: () => value(v => !v),
  });
};

// Usage
const isOpen = svc(toggle)(false);

isOpen();        // false
isOpen.toggle(); // true
isOpen.off();    // false

// Still works as a normal signal
isOpen(true);    // true
```

---

## Previous Value

Track the previous value for transitions, animations, or undo:

```typescript
const withPrevious = <T>(svc: SignalsSvc) => (initial: T) => {
  const { signal, computed } = svc;

  const current = signal(initial);
  const previous = signal(initial);

  const set = (value: T) => {
    previous(current());
    current(value);
  };

  const changed = computed(() => current() !== previous());

  return { current, previous, set, changed };
};

// Usage
const page = svc(withPrevious)(1);

page.set(2);
page.current();   // 2
page.previous();  // 1
page.changed();   // true

page.set(2);
page.changed();   // false (same value)
```

For undo/redo, extend the pattern with a history stack:

```typescript
const withHistory = <T>(svc: SignalsSvc) => (initial: T, maxHistory = 10) => {
  const { signal, computed } = svc;

  const current = signal(initial);
  const past = signal<T[]>([]);
  const future = signal<T[]>([]);

  const canUndo = computed(() => past().length > 0);
  const canRedo = computed(() => future().length > 0);

  const set = (value: T) => {
    past(p => [...p.slice(-(maxHistory - 1)), current()]);
    future([]);
    current(value);
  };

  const undo = () => {
    if (!canUndo()) return;
    const prev = past();
    const last = prev[prev.length - 1];
    past(prev.slice(0, -1));
    future(f => [...f, current()]);
    current(last!);
  };

  const redo = () => {
    if (!canRedo()) return;
    const fut = future();
    const next = fut[fut.length - 1];
    future(fut.slice(0, -1));
    past(p => [...p, current()]);
    current(next!);
  };

  return { current, set, undo, redo, canUndo, canRedo };
};
```

---

## Debounced Signals

Delay signal updates until input settles:

```typescript
const debounced = <T>(svc: SignalsSvc) => (
  source: Readable<T>,
  ms: number
) => {
  const { signal, effect } = svc;

  const value = signal(source.peek());
  let timeout: number | undefined;

  effect(() => {
    const v = source();
    clearTimeout(timeout);
    timeout = window.setTimeout(() => value(v), ms);
  });

  return value;
};

// Usage
const searchInput = signal('');
const debouncedSearch = svc(debounced)(searchInput, 300);

// searchInput updates immediately on keystroke
// debouncedSearch updates 300ms after typing stops
```

A variant that debounces both reads and writes:

```typescript
const debouncedSignal = <T>(svc: SignalsSvc) => (initial: T, ms: number) => {
  const { signal, effect } = svc;

  const immediate = signal(initial);
  const debounced = signal(initial);

  let timeout: number | undefined;

  effect(() => {
    const v = immediate();
    clearTimeout(timeout);
    timeout = window.setTimeout(() => debounced(v), ms);
  });

  // Return a signal-like object that writes to immediate, reads from debounced
  const result = ((value?: T) => {
    if (arguments.length === 0) return debounced();
    immediate(value!);
  }) as Writable<T>;

  result.peek = () => debounced.peek();

  return Object.assign(result, {
    immediate,  // Access the non-debounced value if needed
  });
};
```

---

## Async Actions

For mutations that need loading and error state:

```typescript
const asyncAction = <T, Args extends unknown[]>(svc: SignalsSvc) => (
  action: (...args: Args) => Promise<T>
) => {
  const { signal } = svc;

  const pending = signal(false);
  const error = signal<Error | null>(null);
  const lastResult = signal<T | null>(null);

  const execute = async (...args: Args): Promise<T> => {
    pending(true);
    error(null);

    try {
      const result = await action(...args);
      lastResult(result);
      return result;
    } catch (e) {
      const err = e instanceof Error ? e : new Error(String(e));
      error(err);
      throw err;
    } finally {
      pending(false);
    }
  };

  return { execute, pending, error, lastResult };
};

// Usage
const saveUser = svc(asyncAction)(async (user: User) => {
  const res = await fetch('/api/users', {
    method: 'POST',
    body: JSON.stringify(user),
  });
  if (!res.ok) throw new Error('Failed to save');
  return res.json();
});

// In a component
el('button')
  .props({
    onclick: () => saveUser.execute({ name: 'Alice' }),
    disabled: saveUser.pending,
  })(
    computed(() => saveUser.pending() ? 'Saving...' : 'Save')
  );

// Show errors
match(saveUser.error, (err) =>
  err ? el('div').props({ className: 'error' })(err.message) : null
);
```

---

## Computed Collections

When working with reactive lists, pre-compute common derived views:

```typescript
const todoList = (svc: SignalsSvc) => () => {
  const { signal, computed } = svc;

  const items = signal<Todo[]>([]);

  // Pre-computed views - computed once, cached automatically
  const active = computed(() => items().filter(t => !t.done));
  const completed = computed(() => items().filter(t => t.done));

  const counts = computed(() => ({
    total: items().length,
    active: active().length,
    completed: completed().length,
  }));

  const allDone = computed(() =>
    items().length > 0 && completed().length === items().length
  );

  return {
    items,
    active,
    completed,
    counts,
    allDone,
    // Actions...
    add: (text: string) => items(arr => [...arr, { id: crypto.randomUUID(), text, done: false }]),
    toggle: (id: string) => items(arr => arr.map(t => t.id === id ? { ...t, done: !t.done } : t)),
    remove: (id: string) => items(arr => arr.filter(t => t.id !== id)),
    clear: () => items(arr => arr.filter(t => !t.done)),
  };
};
```

Consumers can read whichever view they need:

```typescript
// Only re-renders when active items change
const ActiveList = (svc: Service, todos: ReturnType<typeof todoList>) => {
  const { el, map } = svc;
  return map(todos.active, t => t.id, TodoItem);
};

// Only re-renders when counts change
const Stats = (svc: Service, todos: ReturnType<typeof todoList>) => {
  const { el, computed } = svc;
  return el('div')(
    computed(() => `${todos.counts().active} items left`)
  );
};
```

---

## Element Partial Application

Pre-bind commonly used element tags:

```typescript
const svc = compose(SignalModule, createElModule(adapter));
const { el } = svc;

// Partial application - call el() once per tag
const div = el('div');
const button = el('button');
const input = el('input');
const span = el('span');

// Use without repeating tag names
const Form = () =>
  div.props({ className: 'form' })(
    div.props({ className: 'field' })(
      input.props({ type: 'text', placeholder: 'Name' })(),
    ),
    button.props({ type: 'submit' })('Submit')
  );
```

This is especially useful in files with many elements of the same type.

---

## Service Factory

For applications that need multiple isolated instances:

```typescript
// Define service creation as a factory
const createService = () => {
  const adapter = createDOMAdapter();
  return compose(
    SignalModule, ComputedModule, EffectModule,
    createElModule(adapter),
    createMapModule(adapter),
    createMatchModule(adapter),
  );
};

// Each call creates a fresh service with its own state
const app1 = createService();
const app2 = createService();

// Mount separate instances
mount(App(app1), document.getElementById('app1')!);
mount(App(app2), document.getElementById('app2')!);
```

This is useful for:
- Embedding multiple independent widgets on a page
- Testing with isolated services
- SSR where each request needs fresh state

---

## Anti-patterns

### Don't Create Module-Level Signals

Signals created at module scope are shared across your entire application. This causes state to leak between components and makes testing difficult:

```typescript
// âŒ WRONG - module-level signal is global shared state
const count = signal(0);  // Created once when module loads

const Counter = () => {
  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
// Every Counter instance shares the same count!
```

```typescript
// âœ… CORRECT - state created per instance
const Counter = () => {
  const count = signal(0);  // Fresh state each time

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
```

### Don't Mutate Signal Values Directly

Signals hold values by reference. Mutating the value directly bypasses reactivity:

```typescript
// âŒ WRONG - mutation doesn't trigger updates
const items = signal<string[]>([]);

items().push('new item');  // Mutates the array, but signal doesn't know
items();  // Still returns the same reference - no reactive update!
```

```typescript
// âœ… CORRECT - use updater functions to create new values
const items = signal<string[]>([]);

items(arr => [...arr, 'new item']);  // New array, signal updates
```

The same applies to objects:

```typescript
// âŒ WRONG
const user = signal({ name: 'Alice', age: 30 });
user().age = 31;  // Mutation - no reactive update

// âœ… CORRECT
user(u => ({ ...u, age: 31 }));  // New object - reactive update
```

### Don't Read Signals Outside Reactive Context

Reading a signal outside of `computed` or `effect` won't track dependencies:

```typescript
// âŒ WRONG - this value won't update
const name = signal('Alice');
const greeting = `Hello, ${name()}!`;  // Read once, never updates

el('div')(greeting);  // Always shows "Hello, Alice!"
```

```typescript
// âœ… CORRECT - wrap in computed for reactive updates
const name = signal('Alice');
const greeting = computed(() => `Hello, ${name()}!`);

el('div')(greeting);  // Updates when name changes
```

### Don't Create Circular Dependencies in Computeds

Computeds that depend on each other create infinite loops:

```typescript
// âŒ WRONG - circular dependency
const a = computed(() => b() + 1);
const b = computed(() => a() + 1);  // Boom! Infinite loop
```

If you need derived values that reference each other, use signals with explicit updates:

```typescript
// âœ… CORRECT - use signals with controlled updates
const a = signal(0);
const b = signal(0);

const updateA = (value: number) => {
  a(value);
  b(value + 1);  // Explicitly update b when a changes
};
```

### Don't Return Elements from Computeds

Computeds are for deriving primitive valuesâ€”strings, numbers, booleans, objects. They can't return element specs:

```typescript
// âŒ WRONG - computed can't return elements
const content = computed(() => {
  if (showDetails()) {
    return el('div')('Details here');  // Won't work!
  }
  return el('span')('Summary');
});

return el('div')(content);  // Broken
```

For conditional rendering, use `match` instead:

```typescript
// âœ… CORRECT - use match for conditional elements
return el('div')(
  match(showDetails, (show) =>
    show
      ? el('div')('Details here')
      : el('span')('Summary')
  )
);
```

Computeds are for values. `match` is for conditional UI.

---

## Behaviors

<!-- @tags: behavior, headless, disclosure, dropdown, modal, pagination, composition -->

A **behavior** is a portable function that encapsulates reactive logic without any UI. It receives a service, returns a factory, and that factory returns an API of signals, computeds, and actions.

Think of behaviors as headless componentsâ€”all the state and logic, none of the markup.

---

## The Shape

```typescript
type SignalsSvc = {
  signal: <T>(initial: T) => Writable<T>;
  computed: <T>(fn: () => T) => Readable<T>;
  effect: (fn: () => void | (() => void)) => () => void;
};

const behaviorName = (svc: SignalsSvc) => (options?: Options) => {
  // Create reactive state
  // Define actions
  // Return the API
  return { ... };
};
```

Three levels:
1. **Service injection**: `(svc) =>` â€” receives primitives
2. **Factory**: `(options?) =>` â€” configures the instance
3. **API**: `{ ... }` â€” the reactive interface consumers use

---

## A Simple Example: Counter

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const { signal, computed } = svc;

  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

Usage with `use()`:

```typescript
const App = (svc: Service) => {
  const { el, use, computed } = svc;
  const { count, increment, decrement } = use(counter)(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: decrement })('-'),
    el('button').props({ onclick: increment })('+')
  );
};
```

The behavior handles state. The component handles rendering. Clean separation.

---

## Composing Behaviors

Behaviors can use other behaviors. This is where the pattern shines.

### Disclosure (open/close)

```typescript
const disclosure = (svc: SignalsSvc) => (initialOpen = false) => {
  const { signal, computed } = svc;
  const isOpen = signal(initialOpen);

  return {
    isOpen,
    open: () => isOpen(true),
    close: () => isOpen(false),
    toggle: () => isOpen(!isOpen()),
    // Accessibility props
    triggerProps: computed(() => ({
      'aria-expanded': String(isOpen()),
    })),
    contentProps: computed(() => ({
      hidden: !isOpen(),
    })),
  };
};
```

### Dropdown (disclosure + keyboard)

```typescript
const dropdown = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {
  const disc = disclosure(svc)(options?.initialOpen ?? false);

  // Add keyboard handling
  const onKeyDown = (e: KeyboardEvent) => {
    switch (e.key) {
      case 'Escape':
        disc.close();
        break;
      case 'Enter':
      case ' ':
        e.preventDefault();
        disc.toggle();
        break;
    }
  };

  return {
    ...disc,
    triggerProps: svc.computed(() => ({
      ...disc.triggerProps(),
      onkeydown: onKeyDown,
    })),
  };
};
```

### Modal (disclosure + focus trap + scroll lock)

```typescript
const modal = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {
  const { signal, effect } = svc;

  const disc = disclosure(svc)(options?.initialOpen ?? false);
  const previousFocus = signal<HTMLElement | null>(null);

  // Focus trap and scroll lock as an effect
  effect(() => {
    if (disc.isOpen()) {
      // Save current focus
      previousFocus(document.activeElement as HTMLElement);
      // Lock scroll
      document.body.style.overflow = 'hidden';
    } else {
      // Restore scroll
      document.body.style.overflow = '';
      // Restore focus
      previousFocus()?.focus();
    }
  });

  return {
    ...disc,
    // Close on backdrop click
    backdropProps: svc.computed(() => ({
      onclick: disc.close,
    })),
    // Prevent close when clicking modal content
    contentProps: svc.computed(() => ({
      ...disc.contentProps(),
      onclick: (e: Event) => e.stopPropagation(),
    })),
  };
};
```

Same `disclosure` behavior, three different use cases. The logic is shared; the semantics differ.

---

## Behaviors with Options

Use options for configuration that affects behavior:

```typescript
type PaginationOptions = {
  totalItems: number;
  pageSize?: number;
  initialPage?: number;
};

const pagination = (svc: SignalsSvc) => (options: PaginationOptions) => {
  const { signal, computed } = svc;

  const pageSize = options.pageSize ?? 10;
  const currentPage = signal(options.initialPage ?? 1);

  const totalPages = computed(() =>
    Math.ceil(options.totalItems / pageSize)
  );

  const hasNext = computed(() => currentPage() < totalPages());
  const hasPrev = computed(() => currentPage() > 1);

  return {
    currentPage,
    totalPages,
    hasNext,
    hasPrev,
    next: () => hasNext() && currentPage(currentPage() + 1),
    prev: () => hasPrev() && currentPage(currentPage() - 1),
    goTo: (page: number) => {
      if (page >= 1 && page <= totalPages()) {
        currentPage(page);
      }
    },
  };
};
```

---

## Behaviors with Reactive Options

When options need to be reactive, accept signals:

```typescript
import type { Readable } from '@rimitive/signals';

type SearchOptions = {
  query: Readable<string>;
  debounceMs?: number;
};

const search = (svc: SignalsSvc) => (options: SearchOptions) => {
  const { signal, computed, effect } = svc;

  const results = signal<SearchResult[]>([]);
  const isSearching = signal(false);

  let timeoutId: number | undefined;

  effect(() => {
    const q = options.query();

    clearTimeout(timeoutId);

    if (!q) {
      results([]);
      return;
    }

    isSearching(true);

    timeoutId = window.setTimeout(async () => {
      const data = await performSearch(q);
      results(data);
      isSearching(false);
    }, options.debounceMs ?? 300);
  });

  return {
    results,
    isSearching,
    resultCount: computed(() => results().length),
  };
};
```

---

## Using Behaviors in React

Behaviors work in React via `@rimitive/react`:

```typescript
import { SignalProvider, createHook, useSubscribe } from '@rimitive/react';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Create hooks from behaviors
const useCounter = createHook(counter);
const useDisclosure = createHook(disclosure);

function ReactDropdown() {
  const disc = useDisclosure(false);

  // Subscribe to signals for React re-renders
  const isOpen = useSubscribe(disc.isOpen);
  const triggerProps = useSubscribe(disc.triggerProps);
  const contentProps = useSubscribe(disc.contentProps);

  return (
    <div>
      <button {...triggerProps} onClick={disc.toggle}>
        Toggle
      </button>
      {isOpen && (
        <div {...contentProps}>
          Dropdown content
        </div>
      )}
    </div>
  );
}

// Wrap app with provider
const svc = compose(SignalModule, ComputedModule, EffectModule)();

function App() {
  return (
    <SignalProvider svc={svc}>
      <ReactDropdown />
    </SignalProvider>
  );
}
```

Same behavior, different framework. The logic stays the same.

---

## Naming Conventions

Rimitive doesn't enforce naming conventions, but here are some that work:

```typescript
// Option 1: Plain names
const counter = (svc) => ...
const disclosure = (svc) => ...

// Option 2: "use" prefix (familiar to React users)
const useCounter = (svc) => ...
const useDisclosure = (svc) => ...

// Option 3: "create" prefix (emphasizes factory nature)
const createCounter = (svc) => ...
const createDisclosure = (svc) => ...
```

---

## When to Use Behaviors

**Good candidates:**
- State that multiple components share (disclosure, selection, pagination)
- Complex state logic (forms, wizards, data fetching)
- Reusable interaction patterns (drag-and-drop, keyboard navigation)
- Anything you'd put in a custom hook in React

**Not necessary for:**
- One-off component state (just use signals directly)
- Pure presentation logic (no state to manage)
- Framework-specific integrations

---

## Testing Behaviors

Behaviors are trivial to testâ€”no DOM, no framework:

```typescript
import { describe, it, expect } from 'vitest';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

describe('counter', () => {
  const createTestSvc = () => compose(SignalModule, ComputedModule, EffectModule)();

  it('increments and decrements', () => {
    const svc = createTestSvc();
    const c = counter(svc)(5);

    expect(c.count()).toBe(5);

    c.increment();
    expect(c.count()).toBe(6);

    c.decrement();
    c.decrement();
    expect(c.count()).toBe(4);
  });

  it('computes doubled', () => {
    const svc = createTestSvc();
    const c = counter(svc)(3);

    expect(c.doubled()).toBe(6);

    c.increment();
    expect(c.doubled()).toBe(8);
  });
});
```

Pure functions, pure tests.

### Testing Behaviors with Dependencies

When a behavior depends on external services, compose with mock modules:

```typescript
import { compose, defineModule } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// A storage module your behavior depends on
const StorageModule = defineModule({
  name: 'storage',
  create: () => ({
    get: (key: string) => localStorage.getItem(key),
    set: (key: string, value: string) => localStorage.setItem(key, value),
  }),
});

type StorageImpl = { get: (key: string) => string | null; set: (key: string, value: string) => void };

// Behavior that uses storage
const persistedCounter = (svc: SignalsSvc & { storage: StorageImpl }) => (key: string) => {
  const { signal, effect, storage } = svc;

  const saved = storage.get(key);
  const count = signal(saved ? parseInt(saved, 10) : 0);

  effect(() => storage.set(key, String(count())));

  return {
    count,
    increment: () => count(count() + 1),
  };
};

// Test with mocked storage
describe('persistedCounter', () => {
  it('persists to storage', () => {
    const stored: Record<string, string> = {};

    // Create mock storage module
    const MockStorageModule = defineModule({
      name: 'storage',
      create: (): StorageImpl => ({
        get: (key: string) => stored[key] ?? null,
        set: (key: string, value: string) => { stored[key] = value; },
      }),
    });

    // Compose with mock instead of real storage
    const testSvc = compose(
      SignalModule,
      ComputedModule,
      EffectModule,
      MockStorageModule
    );

    const c = persistedCounter(testSvc)('count');
    c.increment();
    c.increment();

    expect(stored['count']).toBe('2');
  });
});
```

For module dependency chains, use `override()` to swap nested dependencies:

```typescript
const DbModule = defineModule({
  name: 'db',
  create: () => ({ query: () => fetchFromDatabase() }),
});

const UserModule = defineModule({
  name: 'user',
  dependencies: [DbModule],
  create: ({ db }) => ({ getUser: (id: string) => db.query() }),
});

// Test: swap DbModule for a mock inside UserModule
const MockDb = defineModule({
  name: 'db',
  create: () => ({ query: () => ({ id: '1', name: 'Test' }) }),
});

const testSvc = compose(override(UserModule, { db: MockDb }));
expect(testSvc.user.getUser('1').name).toBe('Test');
```

---

## Anti-patterns

### Don't Mix UI into Behaviors

Behaviors should be headlessâ€”state and logic only, no DOM:

```typescript
// âŒ WRONG - behavior creates DOM elements
const dropdown = (svc: SignalsSvc) => () => {
  const isOpen = svc.signal(false);

  return {
    isOpen,
    toggle: () => isOpen(!isOpen()),
    // Don't do this! Behaviors shouldn't create elements
    render: () => el('div')(
      el('button').props({ onclick: () => isOpen(!isOpen()) })('Toggle'),
      match(isOpen, (open) => open ? el('div')('Content') : null)
    ),
  };
};
```

```typescript
// âœ… CORRECT - behavior returns props, component renders
const dropdown = (svc: SignalsSvc) => () => {
  const isOpen = svc.signal(false);

  return {
    isOpen,
    toggle: () => isOpen(!isOpen()),
    triggerProps: svc.computed(() => ({
      'aria-expanded': String(isOpen()),
    })),
    contentProps: svc.computed(() => ({
      hidden: !isOpen(),
    })),
  };
};

// Component uses the behavior
const Dropdown = (svc: Service) => {
  const disc = svc.use(dropdown)();
  return el('div')(
    el('button').props({ ...disc.triggerProps(), onclick: disc.toggle })('Toggle'),
    match(disc.isOpen, (open) => open ? el('div').props(disc.contentProps())('Content') : null)
  );
};
```

### Don't Skip the Service Injection Layer

The double-function pattern exists for portability. Skipping it couples your behavior to a specific service:

```typescript
// âŒ WRONG - hardcoded service, not portable
import { svc } from './myService';

const counter = (initial = 0) => {
  const count = svc.signal(initial);  // Tied to this specific service
  return {
    count,
    increment: () => count(count() + 1),
  };
};
```

```typescript
// âœ… CORRECT - service injected, portable
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
  };
};

// Now works with any compatible service
const c1 = counter(productionSvc)(0);
const c2 = counter(testSvc)(0);  // Easy to test with mocks
```

### Don't Confuse Service Layer vs Factory

The service layer `(svc) =>` runs once when you call `svc.use(behavior)`. The factory `(options) =>` runs each time you create an instance. Put code in the right place:

```typescript
// âŒ WRONG - composing behaviors in the factory (runs every mount)
const dropdown = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {
  // This creates a new disclosure every time dropdown is instantiated
  const useDisclosure = svc.use(disclosure);  // Should be in service layer!
  const disc = useDisclosure(options?.initialOpen ?? false);

  return { ...disc };
};
```

```typescript
// âœ… CORRECT - compose in service layer, instantiate in factory
const dropdown = (svc: SignalsSvc) => {
  // Service layer: runs once, sets up composed behaviors
  const useDisclosure = svc.use(disclosure);

  return (options?: { initialOpen?: boolean }) => {
    // Factory: runs per instance, creates state
    const disc = useDisclosure(options?.initialOpen ?? false);

    return { ...disc };
  };
};
```

### Don't Create Side Effects Outside effect()

Side effects outside `effect()` won't be cleaned up when the behavior is disposed:

```typescript
// âŒ WRONG - side effect not tracked, never cleaned up
const keyboard = (svc: SignalsSvc) => () => {
  const pressed = svc.signal<string | null>(null);

  // This listener is never removed!
  window.addEventListener('keydown', (e) => pressed(e.key));

  return { pressed };
};
```

```typescript
// âœ… CORRECT - effect handles cleanup
const keyboard = (svc: SignalsSvc) => () => {
  const pressed = svc.signal<string | null>(null);

  svc.effect(() => {
    const handler = (e: KeyboardEvent) => pressed(e.key);
    window.addEventListener('keydown', handler);

    // Cleanup function - runs when effect re-runs or disposes
    return () => window.removeEventListener('keydown', handler);
  });

  return { pressed };
};
```

---

## Portability

<!-- @tags: portable, framework-agnostic, react, testing, ssr, adapter, cross-platform -->

Most UI logic isn't tied to a specific framework. A dropdown's open/close behavior is the same whether you're rendering to DOM, React, or a canvas. A form's validation logic doesn't care about the view layer.

Rimitive is designed around this insight. The same code can run in different contexts without modification.

---

## The Key: Depend on Contracts, Not Frameworks

A portable component depends on a **service contract**â€”a set of primitives it needsâ€”not a specific framework:

```typescript
// This component depends on { el, signal, computed }
// It doesn't know or care where those come from
const Counter = (svc: { el: ElFactory; signal: SignalFactory; computed: ComputedFactory }) => {
  const { el, signal, computed } = svc;
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('Increment')
  );
};
```

This component works with any service that provides `el`, `signal`, and `computed`â€”whether that's a DOM view service, a test service, or something custom.

---

## Portable Component Pattern

The standard pattern is a function that receives a service and returns a function that takes props:

```typescript
// (svc) => (props) => RefSpec
const Button = (svc: Service) => (props: { label: string; onClick: () => void }) => {
  const { el } = svc;

  return el('button').props({ onclick: props.onClick })(props.label);
};
```

This shape lets you:
- Partially apply the service once
- Call the resulting function multiple times with different props
- Pass the component to `use()` for ergonomic instantiation

```typescript
const App = (svc: Service) => {
  const { el, use } = svc;

  return el('div')(
    use(Button)({ label: 'Save', onClick: handleSave }),
    use(Button)({ label: 'Cancel', onClick: handleCancel })
  );
};
```

---

## Running in Different Contexts

### Rimitive DOM View

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule, BatchModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

// Create adapter and compose service
const adapter = createDOMAdapter();
const svc = compose(
  SignalModule, ComputedModule, EffectModule, BatchModule,
  createElModule(adapter), MountModule
)();

const app = Counter(svc);
document.body.appendChild(svc.mount(app).element!);
```

### Testing Without DOM

For tests, use a mock adapter or compose with test dependencies:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Minimal test service - just signals, no view layer
const testSvc = compose(SignalModule, ComputedModule, EffectModule)();

// Test a behavior directly
const { count, increment } = counter(testSvc)(0);
expect(count()).toBe(0);
increment();
expect(count()).toBe(1);
```

### React (via @rimitive/react)

Portable behaviors work in React through `createHook`:

```typescript
import { SignalProvider, createHook, useSubscribe } from '@rimitive/react';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Define a portable behavior
const counter = (svc: { signal: SignalFactory }) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};

// Turn it into a React hook
const useCounter = createHook(counter);

function ReactCounter() {
  const { count, increment } = useCounter(0);
  const value = useSubscribe(count); // Subscribe to trigger re-renders

  return <button onClick={increment}>Count: {value}</button>;
}

// Wrap your app with SignalProvider
const svc = compose(SignalModule, ComputedModule, EffectModule)();

function App() {
  return (
    <SignalProvider svc={svc}>
      <ReactCounter />
    </SignalProvider>
  );
}
```

### Custom Renderer

The same pattern works with any adapter:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { myCanvasAdapter } from './my-canvas-adapter';

const svc = compose(
  SignalModule, ComputedModule, EffectModule,
  createElModule(myCanvasAdapter)
)();

const app = Counter(svc);
// Renders to canvas instead of DOM
```

Same component, different targets.

---

## Anti-patterns

### Don't Import Framework-Specific Code Directly

Importing primitives directly couples your code to a specific setup:

```typescript
// âŒ WRONG - hardcoded dependency, not portable
import { signal } from '@rimitive/signals';

const MyComponent = () => {
  const count = signal(0);  // Can't swap this out for testing
};
```

```typescript
// âœ… CORRECT - depend on the service contract
const MyComponent = (svc: Service) => {
  const { signal } = svc;
  const count = signal(0);  // Works with any compatible service
};
```

### Don't Hardcode External Dependencies

Hardcoding URLs, API calls, or other external dependencies makes code untestable and inflexible:

```typescript
// âŒ WRONG - hardcoded URL, can't test without network
const DataList = (svc: Service) => {
  const items = svc.resource(() => fetch('/api/items'));
};
```

```typescript
// âœ… CORRECT - accept dependencies via service or props
const DataList = (svc: Service & { fetchItems: () => Promise<Item[]> }) => {
  const items = svc.resource(svc.fetchItems);
};

// Or via props
const DataList = (svc: Service) => (props: { fetchItems: () => Promise<Item[]> }) => {
  const items = svc.resource(props.fetchItems);
};
```

This lets you inject a mock fetcher in tests:

```typescript
const mockSvc = {
  ...testSvc,
  fetchItems: async () => [{ id: 1, name: 'Test' }],
};
```

---

## Portable Behaviors vs Portable Components

**Portable behaviors** return reactive state and logicâ€”no UI:

```typescript
const counter = (svc: { signal: SignalFactory }) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};
```

**Portable components** return UI specs:

```typescript
const Counter = (svc: Service) => () => {
  const { el, signal, computed } = svc;
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => count())),
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
```

Behaviors are more portable than components because they have no UI coupling. A behavior can be used in Rimitive views, React, Vue, or anywhere else that can consume signals.

---

## Type Safety

Define your service contracts with TypeScript:

```typescript
import type { SignalFactory, ComputedFactory } from '@rimitive/signals';
import type { ElFactory } from '@rimitive/view/el';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

// Minimal contract for a component
type MinimalSvc = {
  signal: SignalFactory;
  computed: ComputedFactory;
  el: ElFactory<DOMAdapterConfig>;
};

// Component declares exactly what it needs
const MyComponent = (svc: MinimalSvc) => { /* ... */ };
```

This makes dependencies explicit and enables better tree-shakingâ€”if a component only needs `signal` and `el`, it doesn't pull in `effect`, `resource`, etc.

---

## Testing Portable Code

Portable code is easy to test because you control the service:

```typescript
import { describe, it, expect } from 'vitest';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

describe('counter behavior', () => {
  it('increments count', () => {
    const svc = compose(SignalModule, ComputedModule, EffectModule)();
    const { count, increment } = counter(svc)(0);

    expect(count()).toBe(0);
    increment();
    expect(count()).toBe(1);
  });
});
```

No DOM mocking, no framework test utilitiesâ€”just functions and assertions.

---

## Shared State

<!-- @tags: context, shared-state, global-state, service-threading, theme, user, prop-drilling -->

Other frameworks have "context"â€”a way to pass values down the component tree without threading them through every intermediate component. In React, it's `createContext` and `useContext`. In Solid, it's similar.

Rimitive doesn't have a separate context primitive. It doesn't need one.

---

## The Pattern: Service Threading

In Rimitive, the **service is the context**. Components receive a service object containing the primitives they need. You can extend that service with additional state at any point in the tree.

```typescript
// Define your app-level shared state
type AppService = Service & {
  theme: Readable<'light' | 'dark'>;
  user: Readable<User | null>;
};

const App = (svc: Service) => {
  const { el, signal } = svc;

  // Create shared state
  const theme = signal<'light' | 'dark'>('light');
  const user = signal<User | null>(null);

  // Extend the service
  const appSvc: AppService = { ...svc, theme, user };

  return el('div')(
    Header(appSvc),
    Main(appSvc),
    Footer(appSvc)
  );
};
```

Child components receive the extended service and can access the shared state directly:

```typescript
const Header = (svc: AppService) => {
  const { el, computed, theme, user } = svc;

  return el('header').props({
    className: computed(() => theme() === 'dark' ? 'header-dark' : 'header-light')
  })(
    el('span')(computed(() => user()?.name ?? 'Guest'))
  );
};
```

No magic or implicit tree traversal. You can see exactly what's being passed where.

---

## Nested Overrides

Need to override a value for a subtree? Extend the service again:

```typescript
const DarkSection = (svc: AppService) => {
  const { el, signal } = svc;

  // Override theme for this subtree
  const darkSvc: AppService = { ...svc, theme: signal('dark') };

  return el('section')(
    // Everything in here sees theme = 'dark'
    ThemedCard(darkSvc),
    ThemedButton(darkSvc)
  );
};
```

---

## With Portable Components

The portable component pattern (`(svc) => (props) => spec`) works naturally with this:

```typescript
// Portable component that expects theme in service
const ThemedButton = ({ el, computed, theme }: AppService) => (props: { label: string }) => {
  return el('button').props({
    className: computed(() => `btn btn-${theme()}`)
  })(props.label);
};

// Usage with `use`
const App = ({ el, use }: AppService) => {
  return el('div')(
    use(ThemedButton)({ label: 'Click me' })
  );
};
```

When you call `use(ThemedButton)`, it passes the current service (including any extensions) to the component.

---

## TypeScript Tips

Define your extended service types explicitly:

```typescript
import type { Service } from './service';
import type { Readable } from '@rimitive/signals/types';

// Base service with your extensions
export type AppService = Service & {
  theme: Readable<'light' | 'dark'>;
  user: Readable<User | null>;
  // add more as needed
};

// For components that only need a subset
export type ThemedService = Service & {
  theme: Readable<'light' | 'dark'>;
};
```

Components declare what they need:

```typescript
// This component works with any service that has `theme`
const ThemedCard = (svc: ThemedService) => { ... };

// This one needs the full app service
const UserProfile = (svc: AppService) => { ... };
```

---

## Why Not a Context Primitive?

I considered adding one. The problem: context in other frameworks works through implicit tree traversalâ€”a component "finds" the nearest provider by walking up the tree at render time.

Rimitive components are just functions returning specs. There's no render cycle or "currently rendering" context to hook into. Any context system would either:

1. Require explicit scope passing (which is what we already have)
2. Add hidden magic that fights Rimitive's design philosophy

The service threading pattern is explicit, type-safe, and composes naturally. It's not as terse as `useContext()`, but you can always see what's happening.

---

## Anti-patterns

### Don't Use Module-Level Signals for Shared State

Creating signals at module scope seems convenient, but it causes state to leak across your entire application and makes testing nearly impossible:

```typescript
// âŒ WRONG - module-level signal is global singleton
const theme = signal<'light' | 'dark'>('light');
const user = signal<User | null>(null);

const Header = (svc: Service) => {
  // Reads global state - can't test in isolation
  return svc.el('header')(theme());
};
```

```typescript
// âœ… CORRECT - state lives in the service, threaded explicitly
const App = (svc: Service) => {
  const theme = svc.signal<'light' | 'dark'>('light');
  const user = svc.signal<User | null>(null);

  const appSvc = { ...svc, theme, user };

  return svc.el('div')(Header(appSvc));
};
```

The service threading pattern keeps state local to component trees and enables testing with isolated services.

### Don't Mutate the Service Object

Mutating the service directly instead of creating a new one causes subtle bugsâ€”all components sharing that service see the mutation:

```typescript
// âŒ WRONG - mutates shared service object
const DarkSection = (svc: AppService) => {
  svc.theme = svc.signal('dark');  // Mutates the original!
  return svc.el('section')(/* ... */);
};
```

```typescript
// âœ… CORRECT - create a new extended service
const DarkSection = (svc: AppService) => {
  const darkSvc = { ...svc, theme: svc.signal('dark') };
  return svc.el('section')(Child(darkSvc));
};
```

### Don't Skip Type Annotations for Extended Services

Without proper types, you lose the main benefit of explicit service threadingâ€”knowing exactly what's available:

```typescript
// âŒ WRONG - untyped extension loses type safety
const App = (svc: Service) => {
  const theme = svc.signal('light');
  const appSvc = { ...svc, theme };  // Type is just Service & { theme: ... }

  // Later components have no idea what's in the service
  return svc.el('div')(Header(appSvc));  // Header type is unclear
};
```

```typescript
// âœ… CORRECT - explicit service types
type AppService = Service & {
  theme: Readable<'light' | 'dark'>;
};

const App = (svc: Service) => {
  const theme = svc.signal<'light' | 'dark'>('light');
  const appSvc: AppService = { ...svc, theme };

  // Header explicitly declares what it needs
  return svc.el('div')(Header(appSvc));
};

const Header = (svc: AppService) => {
  // TypeScript knows exactly what's available
  const { el, theme } = svc;
  return el('header')(/* ... */);
};
```

### Don't Create Shared State Inside Render

Shared state should be created once and threaded through. Creating it inside component bodies means it's recreated on each instantiation:

```typescript
// âŒ WRONG - creates new signal every time component is instantiated
const ThemedSection = (svc: Service) => (props: { children: RefSpec }) => {
  // This creates a NEW theme signal for every ThemedSection instance!
  const theme = svc.signal<'light' | 'dark'>('light');
  const themedSvc = { ...svc, theme };

  return svc.el('section')(props.children);
};
```

```typescript
// âœ… CORRECT - shared state created at app level, threaded down
const App = (svc: Service) => {
  // Created once at the app level
  const theme = svc.signal<'light' | 'dark'>('light');
  const appSvc: AppService = { ...svc, theme };

  return svc.el('div')(
    ThemedSection(appSvc)({ children: /* ... */ })
  );
};

const ThemedSection = (svc: AppService) => (props: { children: RefSpec }) => {
  // Uses existing theme from service, doesn't create new one
  return svc.el('section')(props.children);
};
```

---

## Error Handling

<!-- @tags: error, error-boundary, try-catch, error-handling, async-error, effect-error, result-type -->

React has Error Boundaries. Solid has `<ErrorBoundary>`. You might expect Rimitive to have something similar.

It doesn'tâ€”because it doesn't need one.

---

## Why No Error Boundary Primitive?

In React and Solid, components are reactive functions that re-run during a render cycle. Errors can happen mid-render, and the framework needs a way to catch them and show fallback UI.

In Rimitive, components are just functions that return specs. They run once, produce a data structure, and that's it. Errors are plain JavaScript errors that propagate normally.

```typescript
const RiskyComponent = (svc: Service) => {
  const { el } = svc;

  // If this throws, it's a normal JS error
  const data = somethingThatMightThrow();

  return el('div')(data.value);
};
```

You handle it with... try/catch:

```typescript
const SafeWrapper = (svc: Service) => {
  const { el } = svc;

  try {
    return RiskyComponent(svc);
  } catch (e) {
    return el('div').props({ className: 'error' })(
      'Something went wrong'
    );
  }
};
```

---

## Handling Async Errors

For async operations, use the `resource` primitive. It tracks error state explicitly:

```typescript
const ProductList = (svc: Service) => {
  const { el, resource, match } = svc;

  const products = resource((signal) =>
    fetch('/api/products', { signal }).then(r => r.json())
  );

  return match(products, (state) => {
    if (state.status === 'pending') {
      return el('div')('Loading...');
    }
    if (state.status === 'error') {
      return el('div').props({ className: 'error' })(
        `Failed to load: ${state.error}`
      );
    }
    return el('ul')(
      ...state.value.map(p => el('li')(p.name))
    );
  });
};
```

The error state is part of the resource's reactive value.

---

## Effect Errors

Errors in effects propagate normally. If you need to catch them:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, EffectModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule, EffectModule)();
const { signal, effect } = svc;

const count = signal(0);

effect(() => {
  try {
    riskyOperation(count());
  } catch (e) {
    console.error('Effect failed:', e);
    // Handle gracefully
  }
});
```

Or wrap the risky operation in a function that returns a result type:

```typescript
type Result<T> = { ok: true; value: T } | { ok: false; error: unknown };

const safeRiskyOperation = (n: number): Result<string> => {
  try {
    return { ok: true, value: riskyOperation(n) };
  } catch (e) {
    return { ok: false, error: e };
  }
};

effect(() => {
  const result = safeRiskyOperation(count());
  if (!result.ok) {
    errorState(result.error);
  }
});
```

---

## Creating a Reusable Error Wrapper

If you want an Error Boundary-like pattern, create a behavior:

```typescript
const errorBoundary = (svc: Service) =>
  <T>(
    render: () => T,
    fallback: (error: unknown) => T
  ): T => {
    try {
      return render();
    } catch (e) {
      return fallback(e);
    }
  };

// Usage
const App = (svc: Service) => {
  const { el, use } = svc;
  const withErrorBoundary = use(errorBoundary);

  return el('div')(
    withErrorBoundary(
      () => RiskyComponent(svc),
      (e) => el('div')(`Error: ${e}`)
    )
  );
};
```

But honestly? Just use try/catch. It's JavaScript. It works.

---

## Anti-patterns

### Don't Swallow Errors Silently

Catching errors without logging or re-throwing hides bugs:

```typescript
// âŒ WRONG - error silently disappears
const LoadData = (svc: Service) => {
  const { el, signal, effect } = svc;
  const data = signal<Data | null>(null);

  effect(() => {
    try {
      data(fetchData());
    } catch (e) {
      // Silently swallowed - you'll never know it failed!
    }
  });

  return el('div')(/* ... */);
};
```

```typescript
// âœ… CORRECT - track error state, show it to users, log it
const LoadData = (svc: Service) => {
  const { el, signal, effect, match } = svc;
  const data = signal<Data | null>(null);
  const error = signal<Error | null>(null);

  effect(() => {
    try {
      error(null);
      data(fetchData());
    } catch (e) {
      console.error('Failed to load data:', e);
      error(e instanceof Error ? e : new Error(String(e)));
    }
  });

  return match(error, (err) =>
    err
      ? el('div').props({ className: 'error' })(err.message)
      : el('div')(/* render data */)
  );
};
```

### Don't Throw in Computeds Without Handling

A throwing computed breaks any effect or computed that depends on it:

```typescript
// âŒ WRONG - throws in computed, breaks dependent computations
const derived = computed(() => {
  const value = source();
  if (value < 0) {
    throw new Error('Invalid value');  // Breaks everything downstream
  }
  return value * 2;
});
```

```typescript
// âœ… CORRECT - return error state instead of throwing
type ComputedResult<T> = { ok: true; value: T } | { ok: false; error: string };

const derived = computed((): ComputedResult<number> => {
  const value = source();
  if (value < 0) {
    return { ok: false, error: 'Value must be non-negative' };
  }
  return { ok: true, value: value * 2 };
});

// Usage
match(derived, (result) =>
  result.ok
    ? el('span')(result.value)
    : el('span').props({ className: 'error' })(result.error)
);
```

### Don't Ignore Resource Error State

Resources track errors automatically. Ignoring them causes crashes:

```typescript
// âŒ WRONG - assumes data is always available
const ProductList = (svc: Service) => {
  const { el, resource, map } = svc;
  const products = resource((s) => fetchProducts(s));

  // Crashes when in error state!
  return el('ul')(
    map(products.data()!, (p) => el('li')(p.name))
  );
};
```

```typescript
// âœ… CORRECT - handle error state explicitly
const ProductList = (svc: Service) => {
  const { el, resource, match, map } = svc;
  const products = resource((s) => fetchProducts(s));

  return match(products, (state) => {
    switch (state.status) {
      case 'pending':
        return el('div')('Loading...');
      case 'error':
        return el('div').props({ className: 'error' })(
          `Failed to load: ${state.error.message}`
        );
      case 'ready':
        return el('ul')(map(state.value, (p) => el('li')(p.name)));
    }
  });
};
```

### Don't Catch and Continue Without Recovery

Catching an error but continuing as if nothing happened leads to inconsistent state:

```typescript
// âŒ WRONG - catches error but leaves state in limbo
const SaveForm = (svc: Service) => {
  const { el, signal } = svc;
  const saving = signal(false);

  const save = async () => {
    saving(true);
    try {
      await submitForm();
    } catch (e) {
      // Error caught, but saving is still true!
      console.error(e);
    }
    // Only resets if no error - state is inconsistent
    saving(false);
  };
};
```

```typescript
// âœ… CORRECT - always reset state in finally, track error separately
const SaveForm = (svc: Service) => {
  const { el, signal } = svc;
  const saving = signal(false);
  const saveError = signal<Error | null>(null);

  const save = async () => {
    saving(true);
    saveError(null);
    try {
      await submitForm();
    } catch (e) {
      saveError(e instanceof Error ? e : new Error(String(e)));
    } finally {
      saving(false);  // Always resets, regardless of success/failure
    }
  };

  return el('form')(
    match(saveError, (err) =>
      err ? el('div').props({ className: 'error' })(err.message) : null
    ),
    el('button').props({ disabled: saving })('Save')
  );
};
```

---

## Forms

Forms are one of the most common UI patterns. Rimitive doesn't have a built-in form primitiveâ€”you compose form behavior from signals and computeds.

---

## The Field Pattern

A field is state plus metadata: the value, whether it's been touched, and any validation errors.

```typescript
type FieldOptions<T> = {
  initial: T;
  validate?: (value: T) => string | null;
};

const field = <T>(svc: SignalsSvc) => (opts: FieldOptions<T>) => {
  const { signal, computed } = svc;

  const value = signal(opts.initial);
  const touched = signal(false);

  const error = computed(() => {
    if (!touched()) return null;
    return opts.validate?.(value()) ?? null;
  });

  const valid = computed(() => !error());

  return {
    value,
    touched,
    error,
    valid,
    touch: () => touched(true),
    reset: () => {
      value(opts.initial);
      touched(false);
    },
  };
};
```

Usage:

```typescript
const emailField = svc(field)({
  initial: '',
  validate: (v) => {
    if (!v) return 'Required';
    if (!v.includes('@')) return 'Invalid email';
    return null;
  },
});

// Read state
emailField.value();   // ''
emailField.touched(); // false
emailField.error();   // null (not touched yet)

// User types and blurs
emailField.value('bad');
emailField.touch();
emailField.error();   // 'Invalid email'

// User fixes it
emailField.value('user@example.com');
emailField.error();   // null
emailField.valid();   // true
```

---

## Input Binding

Bind the field to an input element:

```typescript
const EmailInput = (svc: Service) => {
  const { el, on, signal, computed } = svc;

  const email = svc(field)({
    initial: '',
    validate: (v) => v.includes('@') ? null : 'Invalid email',
  });

  return el('div')(
    el('input')
      .props({
        type: 'email',
        value: email.value,
        className: computed(() => email.error() ? 'input-error' : ''),
      })
      .ref(
        on('input', (e) => email.value((e.target as HTMLInputElement).value)),
        on('blur', () => email.touch())
      )(),
    el('span').props({
      className: 'error-message',
      hidden: computed(() => !email.error()),
    })(computed(() => email.error() ?? ''))
  );
};
```

---

## Composing Fields into Forms

A form is a collection of fields with submission logic:

```typescript
type FormOptions<T> = {
  fields: T;
  onSubmit: (values: { [K in keyof T]: T[K] extends { value: Readable<infer V> } ? V : never }) => void | Promise<void>;
};

const form = <T extends Record<string, { value: Readable<unknown>; valid: Readable<boolean>; touch: () => void }>>(
  svc: SignalsSvc
) => (opts: FormOptions<T>) => {
  const { signal, computed } = svc;

  const submitting = signal(false);
  const submitError = signal<string | null>(null);

  const valid = computed(() =>
    Object.values(opts.fields).every((f) => f.valid())
  );

  const submit = async () => {
    // Touch all fields to show errors
    Object.values(opts.fields).forEach((f) => f.touch());

    if (!valid()) return;

    submitting(true);
    submitError(null);

    try {
      const values = Object.fromEntries(
        Object.entries(opts.fields).map(([k, f]) => [k, f.value()])
      );
      await opts.onSubmit(values as Parameters<typeof opts.onSubmit>[0]);
    } catch (e) {
      submitError(e instanceof Error ? e.message : 'Submission failed');
    } finally {
      submitting(false);
    }
  };

  return {
    fields: opts.fields,
    valid,
    submitting,
    submitError,
    submit,
  };
};
```

---

## Full Form Example

```typescript
const SignupForm = (svc: Service) => {
  const { el, on, computed, match } = svc;

  // Create fields
  const email = svc(field)({
    initial: '',
    validate: (v) => {
      if (!v) return 'Email is required';
      if (!v.includes('@')) return 'Invalid email';
      return null;
    },
  });

  const password = svc(field)({
    initial: '',
    validate: (v) => {
      if (!v) return 'Password is required';
      if (v.length < 8) return 'Password must be at least 8 characters';
      return null;
    },
  });

  // Create form
  const signup = svc(form)({
    fields: { email, password },
    onSubmit: async (values) => {
      await fetch('/api/signup', {
        method: 'POST',
        body: JSON.stringify(values),
      });
    },
  });

  // Field renderer helper
  const renderField = (
    label: string,
    type: string,
    f: ReturnType<ReturnType<typeof field<string>>>
  ) => el('div').props({ className: 'field' })(
    el('label')(label),
    el('input')
      .props({
        type,
        value: f.value,
        disabled: signup.submitting,
      })
      .ref(
        on('input', (e) => f.value((e.target as HTMLInputElement).value)),
        on('blur', () => f.touch())
      )(),
    match(f.error, (err) =>
      err ? el('span').props({ className: 'error' })(err) : null
    )
  );

  return el('form')
    .props({
      onsubmit: (e: Event) => {
        e.preventDefault();
        signup.submit();
      },
    })(
      renderField('Email', 'email', email),
      renderField('Password', 'password', password),

      // Submit error
      match(signup.submitError, (err) =>
        err ? el('div').props({ className: 'submit-error' })(err) : null
      ),

      // Submit button
      el('button')
        .props({
          type: 'submit',
          disabled: computed(() => signup.submitting() || !signup.valid()),
        })(
          computed(() => signup.submitting() ? 'Signing up...' : 'Sign Up')
        )
    );
};
```

---

## Validation Patterns

### Synchronous Validation

Most validation is synchronousâ€”check the value, return an error or null:

```typescript
const required = (msg = 'Required') => (v: string) => v ? null : msg;

const minLength = (n: number) => (v: string) =>
  v.length >= n ? null : `Must be at least ${n} characters`;

const pattern = (re: RegExp, msg: string) => (v: string) =>
  re.test(v) ? null : msg;

// Compose validators
const compose = <T>(...validators: ((v: T) => string | null)[]) => (v: T) => {
  for (const validate of validators) {
    const error = validate(v);
    if (error) return error;
  }
  return null;
};

// Usage
const username = svc(field)({
  initial: '',
  validate: compose(
    required('Username is required'),
    minLength(3),
    pattern(/^[a-z0-9_]+$/, 'Only lowercase letters, numbers, and underscores')
  ),
});
```

### Async Validation

For validation that requires a server check (e.g., username availability):

```typescript
const asyncField = <T>(svc: SignalsSvc) => (opts: {
  initial: T;
  validate?: (value: T) => string | null;
  asyncValidate?: (value: T) => Promise<string | null>;
  debounceMs?: number;
}) => {
  const { signal, computed, effect } = svc;

  const base = field(svc)(opts);
  const asyncError = signal<string | null>(null);
  const validating = signal(false);

  let timeout: number | undefined;

  // Run async validation when value changes
  effect(() => {
    const v = base.value();
    const syncError = opts.validate?.(v);

    // Skip async if sync fails
    if (syncError || !opts.asyncValidate) {
      asyncError(null);
      return;
    }

    clearTimeout(timeout);
    validating(true);

    timeout = window.setTimeout(async () => {
      try {
        const err = await opts.asyncValidate!(v);
        asyncError(err);
      } finally {
        validating(false);
      }
    }, opts.debounceMs ?? 300);
  });

  return {
    ...base,
    validating,
    error: computed(() => base.error() ?? asyncError()),
    valid: computed(() => !base.error() && !asyncError() && !validating()),
  };
};

// Usage
const username = svc(asyncField)({
  initial: '',
  validate: required('Username is required'),
  asyncValidate: async (v) => {
    const res = await fetch(`/api/check-username?q=${v}`);
    const { available } = await res.json();
    return available ? null : 'Username is taken';
  },
  debounceMs: 500,
});
```

---

## Dependent Fields

When one field's validation depends on another:

```typescript
const password = svc(field)({
  initial: '',
  validate: minLength(8),
});

const confirmPassword = svc(field)({
  initial: '',
  validate: (v) => {
    if (!v) return 'Required';
    if (v !== password.value()) return 'Passwords do not match';
    return null;
  },
});
```

---

## Field Arrays

For dynamic lists of fields (e.g., adding/removing tags):

```typescript
const fieldArray = <T>(svc: SignalsSvc) => (opts: {
  initial: T[];
  validateItem?: (value: T) => string | null;
}) => {
  const { signal, computed } = svc;

  const items = signal(
    opts.initial.map((v) => field(svc)({ initial: v, validate: opts.validateItem }))
  );

  const values = computed(() => items().map((f) => f.value()));
  const valid = computed(() => items().every((f) => f.valid()));

  return {
    items,
    values,
    valid,
    add: (value: T) => {
      items([...items(), field(svc)({ initial: value, validate: opts.validateItem })]);
    },
    remove: (index: number) => {
      items(items().filter((_, i) => i !== index));
    },
  };
};

// Usage
const tags = svc(fieldArray)({
  initial: ['javascript', 'typescript'],
  validateItem: (v) => v.length > 0 ? null : 'Tag cannot be empty',
});

tags.add('react');
tags.remove(0);
tags.values(); // ['typescript', 'react']
```

---

## When to Use This Pattern

**Good for:**
- Login/signup forms
- Settings pages
- Any form with validation feedback
- Multi-step wizards

**Overkill for:**
- Simple search inputs (just use a signal)
- Forms without validation
- One-off inputs that don't need error states

---

## Anti-patterns

<!-- @tags: forms, validation, anti-pattern, touched, ux -->

### Don't Validate Before Touched

Showing errors immediatelyâ€”before the user has interactedâ€”creates a poor experience:

```typescript
// âŒ WRONG - error shows immediately, even on empty form load
const field = <T>(svc: SignalsSvc) => (opts: { initial: T; validate: (v: T) => string | null }) => {
  const value = svc.signal(opts.initial);
  const error = svc.computed(() => opts.validate(value()));  // Always validates!

  return { value, error };
};

// User sees "Email is required" before they've even clicked the field
```

```typescript
// âœ… CORRECT - only show errors after user interaction
const field = <T>(svc: SignalsSvc) => (opts: { initial: T; validate: (v: T) => string | null }) => {
  const value = svc.signal(opts.initial);
  const touched = svc.signal(false);

  const error = svc.computed(() => {
    if (!touched()) return null;  // Don't validate until touched
    return opts.validate(value());
  });

  return {
    value,
    touched,
    error,
    touch: () => touched(true),
  };
};
```

<!-- @tags: forms, field-array, anti-pattern, mutation, reactivity -->

### Don't Mutate Field Arrays Directly

Field arrays are signalsâ€”mutating them directly bypasses reactivity:

```typescript
// âŒ WRONG - direct mutation doesn't trigger updates
const tags = svc(fieldArray)({ initial: ['a', 'b'] });

tags.items().push(newField);  // Mutates array, no reactive update
tags.items().splice(0, 1);    // Same problem
```

```typescript
// âœ… CORRECT - use the provided methods
const tags = svc(fieldArray)({ initial: ['a', 'b'] });

tags.add('c');     // Proper reactive update
tags.remove(0);    // Proper reactive update

// Or if you need custom operations, create a new array:
tags.items(items => items.filter(f => f.valid()));
```

---

## Refs and DOM Access

<!-- @tags: ref, dom-access, focus, imperative, third-party, canvas, resize-observer, cleanup -->

Sometimes you need direct DOM accessâ€”for focus management, measurements, third-party library integration, or canvas drawing. Rimitive handles this with the `.ref()` method on elements.

---

## Basic Ref Usage

The `.ref()` method takes a callback that runs when the element is mounted:

```typescript
const AutofocusInput = ({ el }: Service) => {
  return el('input').ref((node) => {
    node.focus();
  })();
};
```

---

## Cleanup

Return a cleanup function from the callback:

```typescript
const ResizeObserved = (svc: Service) => {
  const { el, signal } = svc;
  const dimensions = signal({ width: 0, height: 0 });

  return el('div').ref((node) => {
    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      dimensions({ width, height });
    });

    observer.observe(node);

    // Return cleanup function
    return () => observer.disconnect();
  })(
    // ... children
  );
};
```

The cleanup runs when the element is removed from the DOM.

---

## Using Refs in Effects

If you need to access a DOM node from an effect, store it in a signal:

```typescript
const FocusOnCondition = ({ el, signal, effect }: Service) => {
  const inputRef = signal<HTMLInputElement | null>(null);
  const shouldFocus = signal(false);

  effect(() => {
    const node = inputRef();
    if (shouldFocus() && node) {
      node.focus();
    }
  });

  return el('div')(
    el('input').ref((node) => inputRef(node))(),
    el('button').props({
      onclick: () => shouldFocus(true)
    })('Focus Input')
  );
};
```

The signal-as-ref pattern works because:
- The signal holds the node reference
- Effects track the signal
- When the condition changes, the effect runs and has access to the node

---

## Passing Refs to Children

If a parent needs access to a child's DOM node, pass a callback:

```typescript
const Input = ({ el }: Service, props: { onRef?: (node: HTMLInputElement) => void }) => {
  return el('input').ref((node) => {
    props.onRef?.(node);
  })();
};

const Form = ({ el, use }: Service) => {
  let inputNode: HTMLInputElement | null = null;

  return el('form')(
    use(Input)({ onRef: (node) => { inputNode = node; } }),
    el('button').props({
      onclick: () => inputNode?.focus()
    })('Focus Input')
  );
};
```

Or with signals for reactive access:

```typescript
const Form = (svc: Service) => {
  const { el, signal, use } = svc;
  const inputRef = signal<HTMLInputElement | null>(null);

  return el('form')(
    use(Input)({ onRef: (node) => inputRef(node) }),
    el('button').props({
      onclick: () => inputRef()?.focus()
    })('Focus Input')
  );
};
```

---

## Third-Party Library Integration

Use refs to integrate non-reactive libraries:

```typescript
const Chart = (svc: Service, props: { data: Readable<ChartData> }) => {
  const { el, effect } = svc;

  return el('canvas').ref((canvas) => {
    // Initialize chart library
    const chart = new ChartLibrary(canvas, {
      data: props.data()
    });

    // Update chart when data changes
    const disposeEffect = effect(() => {
      chart.update(props.data());
    });

    // Return cleanup
    return () => {
      disposeEffect();
      chart.destroy();
    };
  })();
};
```

---

## Multiple Refs

For collections, store refs in a map:

```typescript
const ScrollableList = (svc: Service) => {
  const { el, signal, map } = svc;

  const items = signal(['a', 'b', 'c', 'd', 'e']);
  const itemRefs = new Map<string, HTMLElement>();

  const scrollToItem = (id: string) => {
    itemRefs.get(id)?.scrollIntoView({ behavior: 'smooth' });
  };

  return el('div')(
    el('div')(
      ...['a', 'b', 'c', 'd', 'e'].map(id =>
        el('button').props({ onclick: () => scrollToItem(id) })(`Go to ${id}`)
      )
    ),
    el('div').props({ style: 'height: 200px; overflow: auto' })(
      map(items, (item) =>
        el('div').props({ style: 'height: 100px' }).ref((node) => {
          itemRefs.set(item(), node);
          return () => itemRefs.delete(item());
        })(item)
      )
    )
  );
};
```

---

## Why Not `createRef()`?

Some frameworks have a standalone `createRef()` that returns an object with a `.current` property. Rimitive doesn't have this because:

1. The callback pattern is more explicit about timing
2. A signal holding the node serves the same purpose and integrates with reactivity
3. It's one less API to learn

If you want the `.current` pattern, it's trivial to create:

```typescript
const createRef = <T>() => {
  let current: T | null = null;
  return {
    get current() { return current; },
    set current(v: T | null) { current = v; },
    callback: (node: T) => { current = node; }
  };
};

// Usage
const ref = createRef<HTMLInputElement>();
el('input').ref(ref.callback)();
// later: ref.current?.focus()
```

But the signal pattern is usually better because it's reactive.

---

<!-- @tags: react, useRef, migration, local-state, element-scoped -->

## Coming from React

If you're used to React's `useRef`, here's how patterns translate:

### DOM Element Access

```tsx
// React
const inputRef = useRef<HTMLInputElement>(null);
<input ref={inputRef} />
inputRef.current?.focus();  // Might be null

// Rimitive - callback receives element directly
el('input').ref((input) => input.focus())()  // Element guaranteed to exist
```

No wrapper object, no null checking. The callback only runs when the element exists.

### Accessing Element Later

```tsx
// React
const inputRef = useRef<HTMLInputElement>(null);
const handleClick = () => inputRef.current?.focus();

// Rimitive - capture in closure
let inputEl: HTMLInputElement;
el('input').ref((el) => { inputEl = el })()
const handleClick = () => inputEl.focus();  // No null check needed
```

### Mutable Values (Non-Reactive State)

React's `useRef` is often used for values that shouldn't trigger re-renders. In Rimitive, there's no re-rendering to worry aboutâ€”just use variables:

```tsx
// React
const renderCount = useRef(0);
useEffect(() => { renderCount.current++; });

// Rimitive - just a variable
let callCount = 0;
effect(() => { callCount++; });
```

### Forwarding Refs

```tsx
// React
const Input = forwardRef<HTMLInputElement>((props, ref) => (
  <input ref={ref} {...props} />
));

// Rimitive - pass a callback
const Input = (svc: Service, onRef?: (el: HTMLInputElement) => void) =>
  svc.el('input').ref((el) => onRef?.(el))();
```

### Element-Scoped State

A powerful pattern: create signals inside `.ref()` and return an effect. The state is scoped to the element's lifecycle:

```typescript
el('div').ref((element) => {
  // Local state - created when element mounts
  const hovered = signal(false);

  element.onmouseenter = () => hovered(true);
  element.onmouseleave = () => hovered(false);

  // Effect tied to element - disposed when element unmounts
  return effect(() => {
    element.style.backgroundColor = hovered() ? 'lightblue' : 'white';
  });
})()
```

When the element is removed:
1. The effect is disposed (stops running)
2. The signal has no readers (gets garbage collected)
3. Event handlers are cleaned up with the element

This is useful for self-contained interactive elements that manage their own state.

---

## Anti-patterns

### Don't Access Refs Before Mount

Ref callbacks run at mount time. If you try to access the node synchronously or in an effect's first run, it won't exist yet:

```typescript
// âŒ WRONG - ref is null on first effect run
const FocusInput = (svc: Service) => {
  const { el, signal, effect } = svc;
  const inputRef = signal<HTMLInputElement | null>(null);

  // This runs immediately, before the ref callback
  effect(() => {
    inputRef()!.focus();  // Error! inputRef() is null
  });

  return el('input').ref((node) => inputRef(node))();
};
```

```typescript
// âœ… CORRECT - guard against null, or trigger focus differently
const FocusInput = (svc: Service) => {
  const { el, signal, effect } = svc;
  const inputRef = signal<HTMLInputElement | null>(null);

  effect(() => {
    const node = inputRef();
    if (node) {  // Guard against null
      node.focus();
    }
  });

  return el('input').ref((node) => inputRef(node))();
};

// Or focus directly in the ref callback
const FocusInput = (svc: Service) => {
  return svc.el('input').ref((node) => node.focus())();
};
```

### Don't Forget Cleanup

Refs that set up observers, listeners, or other subscriptions need cleanup to avoid memory leaks:

```typescript
// âŒ WRONG - observer never disconnected
const Measured = (svc: Service) => {
  const { el, signal } = svc;
  const size = signal({ width: 0, height: 0 });

  return el('div').ref((node) => {
    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      size({ width, height });
    });
    observer.observe(node);
    // Missing cleanup! Observer lives forever
  })();
};
```

```typescript
// âœ… CORRECT - return cleanup function
const Measured = (svc: Service) => {
  const { el, signal } = svc;
  const size = signal({ width: 0, height: 0 });

  return el('div').ref((node) => {
    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      size({ width, height });
    });
    observer.observe(node);

    return () => observer.disconnect();  // Cleanup when unmounted
  })();
};
```

### Don't Use Refs for Declarative Updates

Refs are for imperative DOM access. If you're using refs to update content that could be reactive, you're fighting the framework:

```typescript
// âŒ WRONG - imperatively updating text content via ref
const Counter = (svc: Service) => {
  const { el, signal } = svc;
  const count = signal(0);

  return el('div')(
    el('span').ref((node) => {
      // Don't do this! Manually syncing signal to DOM
      svc.effect(() => {
        node.textContent = `Count: ${count()}`;
      });
    })(),
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
```

```typescript
// âœ… CORRECT - let reactivity handle it
const Counter = (svc: Service) => {
  const { el, signal, computed } = svc;
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),  // Reactive!
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
```

---

## Composition Over Stores

<!-- @tags: store, proxy, deep-reactivity, immutable, composition, state-management, nested-state -->

SolidJS has `createStore`. Vue has `reactive()`. These provide "deep reactivity"â€”you can mutate nested properties and the framework tracks the changes automatically.

Rimitive doesn't have stores. This is intentional.

---

## Why No Stores?

Deep reactivity requires proxies. Proxies have costs:

- **Magic behavior**: Property access triggers invisible tracking. Mutations trigger invisible updates. Hard to debug.
- **Performance overhead**: Every property access goes through the proxy trap.
- **Complexity**: Edge cases around arrays, Maps, Sets, class instances, etc.
- **Encourages sprawl**: Big nested state objects instead of focused, composable units.

There's nothing saying you can't create your own primitiveâ€”it's just that rimitive doesn't ship one by default.

---

## The Alternative: Composition

Instead of one big store, compose focused behaviors:

```typescript
// Instead of this:
const store = createStore({
  user: {
    profile: { name: '', avatar: '' },
    settings: { theme: 'light', notifications: true }
  },
  cart: {
    items: [],
    total: 0
  }
});

// Do this:
const userProfile = (svc: SignalsSvc) => () => {
  const name = svc.signal('');
  const avatar = svc.signal('');
  return {
    name,
    avatar,
    setName: (n: string) => name(n),
    setAvatar: (a: string) => avatar(a),
  };
};

const userSettings = (svc: SignalsSvc) => () => {
  const theme = svc.signal<'light' | 'dark'>('light');
  const notifications = svc.signal(true);
  return {
    theme,
    notifications,
    toggleTheme: () => theme(theme() === 'light' ? 'dark' : 'light'),
  };
};

const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);
  const total = svc.computed(() =>
    items().reduce((sum, item) => sum + item.price * item.qty, 0)
  );
  return {
    items,
    total,
    addItem: (item: CartItem) => items([...items(), item]),
    removeItem: (id: string) => items(items().filter(i => i.id !== id)),
  };
};
```

Each behavior:
- Has a clear, focused purpose
- Encapsulates its own logic
- Is independently testable
- Can be composed with others
- Is portable

---

## Composing Behaviors

Behaviors can depend on other behaviors by calling them directly:

```typescript
const checkout = (svc: SignalsSvc) => () => {
  const { computed } = svc;

  // Call other behaviors directly with the service
  const c = cart(svc)();
  const profile = userProfile(svc)();

  const canCheckout = computed(() =>
    c.items().length > 0 && profile.name() !== ''
  );

  const submit = async () => {
    if (!canCheckout()) return;
    await submitOrder({
      items: c.items(),
      customer: profile.name(),
    });
  };

  return { canCheckout, submit };
};
```

---

## Working with Arrays

For reactive arrays, use a signal holding an array:

```typescript
const todoList = ({ signal }: SignalsSvc) => () => {
  const items = signal<Todo[]>([]);

  return {
    items,
    add: (text: string) => {
      items([...items(), { id: crypto.randomUUID(), text, done: false }]);
    },
    toggle: (id: string) => {
      items(items().map(t =>
        t.id === id ? { ...t, done: !t.done } : t
      ));
    },
    remove: (id: string) => {
      items(items().filter(t => t.id !== id));
    },
  };
};
```

This follows an immutable pattern which is:
- Explicit (you see the update happening)
- Debuggable (you can log the before/after)
- Predictable (no proxy magic)

---

## When You Really Want Nested Updates

If you genuinely need to update nested data, create a focused updater:

```typescript
const nestedSettings = (svc: SignalsSvc) => () => {
  const settings = svc.signal({
    display: { theme: 'light', fontSize: 14 },
    privacy: { shareData: false, analytics: true },
  });

  // Focused updaters for specific paths
  const setTheme = (theme: string) => {
    settings({
      ...settings(),
      display: { ...settings().display, theme }
    });
  };

  const setFontSize = (size: number) => {
    settings({
      ...settings(),
      display: { ...settings().display, fontSize: size }
    });
  };

  // Or a generic path updater if you really need it
  const update = <K extends keyof Settings>(
    section: K,
    updates: Partial<Settings[K]>
  ) => {
    settings({
      ...settings(),
      [section]: { ...settings()[section], ...updates }
    });
  };

  return { settings, setTheme, setFontSize, update };
};
```

---

## But I Really Want Proxies

If you're convinced you need proxy-based stores, you can build them on top of Rimitive's primitives. The signals are thereâ€”wrap them in proxies if you want.

Or use an external store library and connect it via effects:

```typescript
import { createStore } from 'some-store-library';

const externalStore = createStore({ count: 0 });

const bridged = (svc: SignalsSvc) => () => {
  const count = svc.signal(externalStore.getState().count);

  // Sync from external store to signal
  externalStore.subscribe((state) => {
    count(state.count);
  });

  return { count };
};
```

But consider: if you're reaching for proxies, you might be fighting the framework. Rimitive's composition model works best when you embrace it.

---

## Anti-patterns

### Don't Create Monolithic State Objects

Putting everything in one big signal defeats the purpose of composition:

```typescript
// âŒ WRONG - monolithic state, hard to test and maintain
const appState = signal({
  user: { name: '', avatar: '', settings: { theme: 'light', notifications: true } },
  cart: { items: [], total: 0 },
  ui: { sidebarOpen: false, modal: null },
});

// Updates become awkward
appState(s => ({
  ...s,
  user: { ...s.user, settings: { ...s.user.settings, theme: 'dark' } }
}));
```

```typescript
// âœ… CORRECT - composed behaviors with focused responsibilities
const userSettings = (svc: SignalsSvc) => () => {
  const theme = svc.signal<'light' | 'dark'>('light');
  return {
    theme,
    toggleTheme: () => theme(t => t === 'light' ? 'dark' : 'light'),
  };
};

const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);
  const total = svc.computed(() => items().reduce((sum, i) => sum + i.price, 0));
  return { items, total, /* actions */ };
};

// Each behavior is focused, testable, and composable
```

### Don't Manually Sync Derived State

Using signals for values that should be computed causes bugs when you forget to update them:

```typescript
// âŒ WRONG - manually tracking derived state
const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);
  const total = svc.signal(0);  // Manually maintained!

  const addItem = (item: CartItem) => {
    items([...items(), item]);
    total(total() + item.price);  // Must remember to update
  };

  const removeItem = (id: string) => {
    const item = items().find(i => i.id === id);
    items(items().filter(i => i.id !== id));
    // Oops! Forgot to update total
  };

  return { items, total, addItem, removeItem };
};
```

```typescript
// âœ… CORRECT - compute derived values automatically
const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);

  // Automatically stays in sync
  const total = svc.computed(() =>
    items().reduce((sum, item) => sum + item.price, 0)
  );

  return {
    items,
    total,  // Always correct, can't get out of sync
    addItem: (item: CartItem) => items([...items(), item]),
    removeItem: (id: string) => items(items().filter(i => i.id !== id)),
  };
};
```

### Don't Expose Raw Signals Without Actions

Exposing signals directly allows uncontrolled mutations from anywhere:

```typescript
// âŒ WRONG - raw signal exposure, no controlled updates
const counter = (svc: SignalsSvc) => () => {
  const count = svc.signal(0);
  return { count };  // Anyone can write anything!
};

// Elsewhere:
counter.count(-999);  // No validation, no control
counter.count('oops'); // Type error, but conceptually wrong
```

```typescript
// âœ… CORRECT - expose signals with controlled actions
const counter = (svc: SignalsSvc) => () => {
  const count = svc.signal(0);

  return {
    count,  // Read access
    increment: () => count(c => c + 1),
    decrement: () => count(c => Math.max(0, c - 1)),  // Validated
    reset: () => count(0),
  };
};
```

### Don't Tightly Couple Composed Behaviors

Behaviors should receive dependencies, not import them directly:

```typescript
// âŒ WRONG - hard dependency on specific cart implementation
import { cart } from './cart';

const checkout = (svc: SignalsSvc) => () => {
  const c = cart(svc)();  // Always uses this specific cart

  return {
    submit: () => submitOrder(c.items()),
  };
};
```

```typescript
// âœ… CORRECT - receive the cart as a parameter
type CartLike = { items: Readable<CartItem[]> };

const checkout = (svc: SignalsSvc) => (cart: CartLike) => {
  return {
    submit: () => submitOrder(cart.items()),
  };
};

// Can inject any cart implementation, including mocks for testing
const c = cart(svc)();
const ch = checkout(svc)(c);
```

---

## Async Loading States

<!-- @tags: async, loading, suspense, pending, error-state, resource, load, ssr -->

React has Suspense. Solid has `<Suspense>` and `<Show>`. These handle async loading states declaratively.

Rimitive handles async state explicitly through two primitives: `resource` for reactive data fetching with automatic refetch, and `load` for simpler async boundaries. Both use `match` for rendering. No magic, no special componentsâ€”just reactive state.

---

## The Resource Pattern

The `resource` primitive wraps async operations and exposes their state reactively:

```typescript
const ProductList = (svc: Service) => {
  const { el, resource, match } = svc;

  const products = resource((signal) =>
    fetch('/api/products', { signal }).then(r => r.json())
  );

  // products() returns { status: 'pending' | 'ready' | 'error', value?, error? }
};
```

---

## Rendering Different States

Use `match` to render based on state:

```typescript
return match(products, (state) => {
  switch (state.status) {
    case 'pending':
      return Spinner(svc);
    case 'error':
      return ErrorMessage(svc, state.error);
    case 'ready':
      return ProductGrid(svc, state.value);
  }
});
```

Or use the convenience accessors:

```typescript
return el('div')(
  match(products.loading, (loading) =>
    loading
      ? Spinner(svc)
      : match(products.error, (error) =>
          error
            ? ErrorMessage(svc, error)
            : ProductGrid(svc, products.data()!)
        )
  )
);
```

The explicit approach is more verbose but clearer about what's happening.

---

## A Show Helper

If you want something closer to Solid's `<Show>`, create a simple helper:

```typescript
const show = <T, R>(
  when: () => T | null | undefined | false,
  render: (value: T) => R,
  fallback?: () => R
): R | undefined => {
  const value = when();
  if (value) return render(value);
  return fallback?.();
};

// Usage
return el('div')(
  show(
    () => products.data(),
    (data) => ProductGrid(svc, data),
    () => Spinner(svc)
  )
);
```

But this is just a functionâ€”nothing special about it.

---

## Multiple Resources

When loading multiple resources, handle them together:

```typescript
const Dashboard = (svc: Service) => {
  const { el, resource, computed, match } = svc;

  const user = resource((s) => fetchUser(s));
  const stats = resource((s) => fetchStats(s));
  const notifications = resource((s) => fetchNotifications(s));

  // Combine loading states
  const allLoading = computed(() =>
    user.loading() || stats.loading() || notifications.loading()
  );

  const anyError = computed(() =>
    user.error() || stats.error() || notifications.error()
  );

  return match(allLoading, (loading) => {
    if (loading) return Spinner(svc);

    const error = anyError();
    if (error) return ErrorMessage(svc, error);

    return el('div')(
      UserHeader(svc, user.data()!),
      StatsPanel(svc, stats.data()!),
      NotificationList(svc, notifications.data()!)
    );
  });
};
```

---

## Dependent Resources

When one resource depends on another:

```typescript
const ProductDetail = (svc: Service) => {
  const { el, resource, computed, match } = svc;

  const productId = svc.params.id; // from router

  const product = resource((s) =>
    fetch(`/api/products/${productId()}`, { signal: s }).then(r => r.json())
  );

  // Reviews depend on product being loaded
  const reviews = resource((s) => {
    const p = product.data();
    if (!p) return Promise.resolve([]); // No product yet, return empty

    return fetch(`/api/products/${p.id}/reviews`, { signal: s })
      .then(r => r.json());
  });

  return match(product, (state) => {
    if (state.status !== 'ready') {
      return state.status === 'pending' ? Spinner(svc) : ErrorMessage(svc, state.error);
    }

    return el('div')(
      ProductInfo(svc, state.value),
      match(reviews, (reviewState) =>
        reviewState.status === 'pending'
          ? el('div')('Loading reviews...')
          : reviewState.status === 'error'
            ? el('div')('Failed to load reviews')
            : ReviewList(svc, reviewState.value)
      )
    );
  });
};
```

---

## Refetching

Resources track dependencies and refetch automatically:

```typescript
const category = signal('electronics');

const products = resource((s) =>
  fetch(`/api/products?category=${category()}`, { signal: s })
    .then(r => r.json())
);

// Change category -> products automatically refetches
category('clothing');
```

Manual refetch is also available:

```typescript
el('button').props({
  onclick: () => products.refetch()
})('Refresh')
```

---

## The Load Pattern

For simpler async boundariesâ€”especially in SSR scenariosâ€”use `load()`:

```typescript
const ProductList = (svc: Service) => {
  const { el, load, match } = svc;

  return load(
    () => fetch('/api/products').then(r => r.json()),
    (state) => match(state.status, (status) => {
      switch (status) {
        case 'pending':
          return Spinner(svc);
        case 'error':
          return ErrorMessage(svc, state.error());
        case 'ready':
          return ProductGrid(svc, state.data()!);
      }
    })
  );
};
```

The key difference: `load()` takes a fetcher and a renderer. The renderer receives a state object with reactive properties (`status`, `data`, `error`) that you read by calling them.

### When to use each

**Use `resource`** when you need:
- Automatic refetching when dependencies change
- AbortController integration for request cancellation
- A reactive value you can pass around and read anywhere

**Use `load`** when you need:
- Simple one-shot data fetching
- SSR streaming with explicit data boundaries
- Direct control over the loading UI in one place

```typescript
// load() is ideal for SSR - data and UI are co-located
const Page = (svc: Service) => {
  const { el, load, match } = svc;

  return el('main')(
    load(
      () => fetchPageData(),
      (state) => match(state.status, (status) =>
        status === 'ready'
          ? PageContent(svc, state.data()!)
          : status === 'error'
            ? ErrorFallback(svc)
            : LoadingSkeleton(svc)
      )
    )
  );
};
```

---

## Cleanup

Resources should be disposed when no longer needed:

```typescript
const ProductPanel = (svc: Service) => {
  const { el, resource } = svc;

  const products = resource((s) => fetchProducts(s));

  // Cleanup when element is removed
  return el('div').ref(() => products.dispose)(
    // ... content
  );
};
```

---

## Anti-patterns

### Don't Ignore Loading and Error States

Only rendering the "ready" case leads to a broken UI during loading or when errors occur:

```typescript
// âŒ WRONG - crashes when data isn't ready, no error handling
const ProductList = (svc: Service) => {
  const { el, resource, map } = svc;

  const products = resource((s) => fetchProducts(s));

  // products.data() is undefined while loading!
  return el('div')(
    map(products.data()!, (p) => ProductCard(svc, p))
  );
};
```

```typescript
// âœ… CORRECT - handle all states explicitly
const ProductList = (svc: Service) => {
  const { el, resource, match, map } = svc;

  const products = resource((s) => fetchProducts(s));

  return match(products, (state) => {
    switch (state.status) {
      case 'pending':
        return Spinner(svc);
      case 'error':
        return ErrorMessage(svc, state.error);
      case 'ready':
        return el('div')(
          map(state.value, (p) => ProductCard(svc, p))
        );
    }
  });
};
```

### Don't Forget Resource Cleanup

Resources keep fetching and updating until disposed. Without cleanup, they leak memory:

```typescript
// âŒ WRONG - resource lives forever, even after component unmounts
const ProductPanel = (svc: Service) => {
  const products = svc.resource((s) => fetchProducts(s));

  return svc.el('div')(/* ... */);
  // Resource never disposed!
};
```

```typescript
// âœ… CORRECT - dispose when element unmounts
const ProductPanel = (svc: Service) => {
  const products = svc.resource((s) => fetchProducts(s));

  return svc.el('div').ref(() => products.dispose)(/* ... */);
};
```

### Don't Ignore the AbortSignal

Resources pass an AbortSignal to cancel in-flight requests. Ignoring it causes race conditions when dependencies change rapidly:

```typescript
// âŒ WRONG - ignores signal, old requests may resolve after new ones
const Search = (svc: Service) => {
  const query = svc.signal('');

  const results = svc.resource(() =>  // No signal parameter!
    fetch(`/api/search?q=${query()}`).then(r => r.json())
  );
};
```

```typescript
// âœ… CORRECT - pass signal to fetch for automatic cancellation
const Search = (svc: Service) => {
  const query = svc.signal('');

  const results = svc.resource((signal) =>
    fetch(`/api/search?q=${query()}`, { signal }).then(r => r.json())
  );
};
```

When `query` changes, the previous fetch is automatically aborted.

### Don't Use Resource for Mutations

Resources are for reactive data fetching (GET). For mutations (POST, PUT, DELETE), use the `asyncAction` pattern:

```typescript
// âŒ WRONG - resource for a mutation doesn't make sense
const DeleteButton = (svc: Service) => {
  const deletion = svc.resource((s) =>
    fetch('/api/item', { method: 'DELETE', signal: s })
  );  // This fetches immediately on mount!

  return svc.el('button')(/* ??? */);
};
```

```typescript
// âœ… CORRECT - use asyncAction for imperative mutations
const DeleteButton = (svc: Service) => {
  const { el, signal } = svc;

  const pending = signal(false);
  const error = signal<Error | null>(null);

  const deleteItem = async () => {
    pending(true);
    error(null);
    try {
      await fetch('/api/item', { method: 'DELETE' });
    } catch (e) {
      error(e instanceof Error ? e : new Error(String(e)));
    } finally {
      pending(false);
    }
  };

  return el('button').props({
    onclick: deleteItem,
    disabled: pending,
  })('Delete');
};
```

### Don't Access .data() Without Checking Status

The `data()` accessor returns `undefined` until the resource is ready. Using it directly without guards causes runtime errors:

```typescript
// âŒ WRONG - data() is undefined until ready
const UserProfile = (svc: Service) => {
  const user = svc.resource((s) => fetchUser(s));

  // This crashes during loading!
  return svc.el('div')(user.data()!.name);
};
```

```typescript
// âœ… CORRECT - use match to ensure data exists
const UserProfile = (svc: Service) => {
  const { el, resource, match } = svc;
  const user = resource((s) => fetchUser(s));

  return match(user, (state) =>
    state.status === 'ready'
      ? el('div')(state.value.name)
      : state.status === 'error'
        ? el('div')('Error loading user')
        : el('div')('Loading...')
  );
};
```

---

## Package API Reference

The following sections contain API documentation from each package's README.

---

### @rimitive/core

Simple, minimal Dependency Injection through module composition. Modules declare dependencies and `compose()` wires them together.

Additional features:

- [**fork**](#forkbase-freshmodules) - fresh instances of selected modules, shares everything else
- [**transient**](#transientmodule) - fresh instance per dependent instead of shared singleton
- [**lazy**](#lazymodule) - async module initialization
- [**override**](#overridemodule-replacements) - swap dependencies for testing or configuration
- [**merge**](#mergeservice-additions) - extend context with additional properties

Works standalone or as the foundation for rimitive's reactive system.

## Architecture

This is a **Dependency Injection (DI)** system using the **Composition Root** pattern:

| Concept                   | In @rimitive/core                                                |
| ------------------------- | ---------------------------------------------------------------- |
| **Inversion of Control**  | Modules declare dependencies; they don't instantiate them        |
| **Constructor Injection** | `create(deps)` receives resolved dependencies                    |
| **Composition Root**      | `compose()` is the single place where the object graph is wired  |
| **Scopes**                | Singleton (default), transient, or lazy (async)                  |
| **Transitive Resolution** | Pass only what you need; dependencies are included automatically |
| **Async Support**         | `lazy()` wrapper for modules with async `create()`               |

Think of it like npm for runtime:

```
package.json "dependencies"  â†’  Module declares dependencies
npm install / node_modules   â†’  compose() resolves the graph
import X from 'x'            â†’  deps available by name in create()
```

## Quick Start

```typescript
import { compose, defineModule } from '@rimitive/core';

const Logger = defineModule({
  name: 'logger',
  create: () => ({
    log: (msg: string) => console.log(`[LOG] ${msg}`),
    error: (msg: string) => console.error(`[ERR] ${msg}`),
  }),
});

const Database = defineModule({
  name: 'db',
  dependencies: [Logger],
  create: ({ logger }) => ({
    query: (sql: string) => {
      logger.log(`Executing: ${sql}`);
      return []; // your db logic here
    },
  }),
});

const svc = compose(Database);

svc.db.query('SELECT * FROM users');
// [LOG] Executing: SELECT * FROM users
```

---

## compose(...modules)

Resolves the dependency graph and returns a composed service. Each module is instantiated once and shared (singleton by default).

```typescript
const svc = compose(Logger, Database, Cache);
```

Access modules as properties:

```typescript
svc.logger.log('hi');
svc.db.query('SELECT 1');
```

When you're done, clean up:

```typescript
svc.dispose();
```

---

## defineModule(definition)

Create a module:

```typescript
const Cache = defineModule({
  name: 'cache',
  create: () => {
    const store = new Map();
    return {
      get: (key: string) => store.get(key),
      set: (key: string, value: unknown) => store.set(key, value),
    };
  },
});
```

With dependencies:

```typescript
const UserService = defineModule({
  name: 'users',
  dependencies: [Database, Cache],
  create: ({ db, cache }) => ({
    getUser: (id: string) => {
      const cached = cache.get(id);
      if (cached) return cached;
      const user = db.query(`SELECT * FROM users WHERE id = ${id}`)[0];
      cache.set(id, user);
      return user;
    },
  }),
});
```

Full options:

```typescript
defineModule({
  name: 'myModule',              // becomes property on service
  create: (deps) => impl,        // factory, receives resolved deps
  dependencies: [OtherModule],   // what this module needs
  init: (ctx) => { ... },        // called on creation
  destroy: (ctx) => { ... },     // called on dispose
  instrument: (impl, instr) => impl  // wrap for debugging
});
```

---

## merge(service, additions)

Extend a service with extra properties:

```typescript
const svc = compose(Logger);
const extended = merge(svc, { env: 'production' });

extended.env; // 'production'
extended.logger; // same instance as svc.logger
```

Handy for passing context through a system:

```typescript
const App = (svc) => {
  const config = loadConfig();
  const childSvc = merge(svc, { config });
  return childSvc(Router);
};
```

---

## override(module, replacements)

Swap dependencies without changing the original module. Useful for testing or environment-specific configurations.

```typescript
import { compose, override } from '@rimitive/core';

// Production uses real database
const prodSvc = compose(UserService);

// Testing uses mock database
const MockDB = defineModule({
  name: 'db',
  create: () => ({ query: () => mockData }),
});

const testSvc = compose(override(UserService, { db: MockDB }));
```

Replacements are matched by name. If the replacement has a different name, it's aliased automatically:

```typescript
const FileLogger = defineModule({
  name: 'fileLogger', // Different name
  create: () => ({ log: writeToFile }),
});

// FileLogger is aliased to 'logger' for this composition
compose(override(App, { logger: FileLogger }));
```

---

## transient(module)

Mark a module as transient - each dependent gets a fresh instance instead of sharing a singleton.

```typescript
import { compose, defineModule, transient } from '@rimitive/core';

const Logger = transient(
  defineModule({
    name: 'logger',
    create: () => new Logger(),
  })
);

const ServiceA = defineModule({
  name: 'serviceA',
  dependencies: [Logger],
  create: ({ logger }) => {
    /* unique logger instance */
  },
});

const ServiceB = defineModule({
  name: 'serviceB',
  dependencies: [Logger],
  create: ({ logger }) => {
    /* different logger instance */
  },
});

const svc = compose(ServiceA, ServiceB);
```

Transient modules still share their singleton dependencies:

```typescript
const Config = defineModule({ name: 'config', create: () => loadConfig() });

const Logger = transient(
  defineModule({
    name: 'logger',
    dependencies: [Config],
    create: ({ config }) => new Logger(config),
  })
);

// Each Logger instance shares the same Config
```

---

## fork(base, freshModules)

Create a new composition that shares instances from an existing one, but with fresh instances of specified modules. Useful for per-request contexts, test isolation, or scoped state.

```typescript
import { compose, fork, defineModule } from '@rimitive/core';

const Config = defineModule({ name: 'config', create: () => loadConfig() });
const DbPool = defineModule({ name: 'dbPool', create: () => createPool() });
const DbConnection = defineModule({
  name: 'dbConnection',
  dependencies: [DbPool],
  create: ({ dbPool }) => dbPool.getConnection(),
});

// Long-lived root composition
const root = compose(Config, DbPool, DbConnection);

// Per-request: fresh DbConnection, inherited Config and DbPool
const requestCtx = fork(root, [DbConnection]);

requestCtx.config; // Same instance (inherited from root)
requestCtx.dbPool; // Same instance (inherited from root)
requestCtx.dbConnection; // Fresh instance (not shared with root)

// Cleanup when done - only disposes fresh instances
requestCtx.dispose();
// root is unaffected
```

Fresh modules are:

- **Re-instantiated** - new instance, not shared with the base
- **Singleton within the fork** - shared by dependents in the forked context
- **Independently disposable** - disposing the fork only cleans up its fresh instances

**Rebinding dependencies:** Pass a replacement module with the same name to swap implementations:

```typescript
const MockDb = defineModule({ name: 'db', create: () => mockDb });

// UserService now receives MockDb instead of the original
const testCtx = fork(root, [MockDb, UserService]);
```

---

## lazy(module)

Mark a module with async `create()` as lazy. Lazy modules are awaited during composition, allowing async initialization like database connections or remote config loading.

```typescript
import { compose, defineModule, lazy } from '@rimitive/core';

const DbPool = lazy(
  defineModule({
    name: 'dbPool',
    create: async () => {
      const pool = await createPool();
      await pool.connect();
      return pool;
    },
  })
);

// compose() returns a Promise when lazy modules are present
const svc = await compose(DbPool, UserService);

// After await, everything is resolved - sync access
svc.dbPool.query('SELECT 1');
```

Async modules **must** be wrapped with `lazy()` - you'll get both a type error and runtime error otherwise.

---

## Instrumentation

Add debugging to your modules:

```typescript
import {
  compose,
  createInstrumentation,
  devtoolsProvider,
} from '@rimitive/core';

const svc = compose(Logger, Database, {
  instrumentation: createInstrumentation({
    providers: [devtoolsProvider()],
  }),
});
```

Modules define how they're instrumented:

```typescript
const MyModule = defineModule({
  name: 'myModule',
  create: () => (value) => createImpl(value),
  instrument: (impl, instr) => (value) => {
    const instance = impl(value);
    instr.register(instance, 'myModule');
    return instance;
  },
});
```

---

### @rimitive/signals

Reactive primitives for rimitive. Signals, computeds, effects, and friends.

## Quick Start

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(
  SignalModule,
  ComputedModule,
  EffectModule
);

const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => console.log('Count:', count()));
// logs: "Count: 0"

count(5);
// logs: "Count: 5"
```

---

## signal

Reactive state. Read with `sig()`, write with `sig(value)`.

```typescript
const name = signal('Alice');

name(); // 'Alice'
name('Bob');
name(); // 'Bob'
name.peek(); // read without tracking
```

Updater functions work too:

```typescript
const count = signal(0);
count((c) => c + 1);

const items = signal<string[]>([]);
items((arr) => [...arr, 'new']);
```

---

## computed

Derived values. Lazy, cached, auto-tracks dependencies.

```typescript
const firstName = signal('Ada');
const lastName = signal('Lovelace');

const fullName = computed(() => `${firstName()} ${lastName()}`);

fullName(); // 'Ada Lovelace'
lastName('Byron');
fullName(); // 'Ada Byron'
```

---

## effect

Side effects when dependencies change. **Synchronous**â€”runs immediately, not next tick.

```typescript
const user = signal({ name: 'Alice', online: false });

effect(() => {
  console.log(`${user().name} is ${user().online ? 'online' : 'offline'}`);
});
// logs: "Alice is offline"

user({ ...user(), online: true });
// logs: "Alice is online"
```

Returns a dispose function:

```typescript
const dispose = effect(() => console.log(count()));
dispose(); // stops tracking
```

### Flush Strategies

By default, effects run synchronouslyâ€”the moment a dependency changes, the effect runs. Sometimes you want to defer execution. That's what flush strategies are for.

```typescript
import { mt, raf, debounce } from '@rimitive/signals/extend';

// Run on next microtask (coalesces rapid updates)
effect(mt(() => console.log(count())));

// Run on requestAnimationFrame (ideal for DOM reads/writes)
effect(raf(() => updateCanvas(data())));

// Run after 300ms of no changes
effect(debounce(300, () => search(query())));
```

| Strategy | Use case |
|----------|----------|
| `mt(fn)` | Batch multiple synchronous signal updates into one effect run |
| `raf(fn)` | DOM measurements, canvas rendering, animations |
| `debounce(ms, fn)` | User input, search boxes, expensive operations |

Without a strategy, effects are synchronous. Wrap your effect function in a strategy to control timing.

---

## batch

Group updates into a single notification.

```typescript
import { BatchModule } from '@rimitive/signals/extend';

const { signal, effect, batch } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  BatchModule
);

const a = signal(1);
const b = signal(2);

effect(() => console.log(a() + b()));
// logs: 3

batch(() => {
  a(10);
  b(20);
});
// logs: 30 (once, not twice)
```

---

## subscribe

Subscribe without creating a reactive context.

```typescript
import { SubscribeModule } from '@rimitive/signals/extend';

const { signal, subscribe } = compose(SignalModule, SubscribeModule);

const count = signal(0);
const unsubscribe = subscribe(count, (value) => {
  console.log('Count changed to:', value);
});

count(1); // logs: "Count changed to: 1"
unsubscribe();
```

---

## untrack

Read signals without tracking.

```typescript
import { UntrackModule } from '@rimitive/signals/extend';

const { signal, computed, untrack } = compose(
  SignalModule,
  ComputedModule,
  UntrackModule
);

const a = signal(1);
const b = signal(2);

// Only tracks `a`, not `b`
const result = computed(() => a() + untrack(() => b()));

result(); // 3
b(10);
result(); // still 3 (b not tracked)
a(5);
result(); // 15 (recomputes, reads current b)
```

---

### @rimitive/view

Reactive UI primitives for rimitive. Elements, lists, conditionals, portals.

## Quick Start

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const { signal, computed, el, mount } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  MountModule
);

const count = signal(0);

const App = () =>
  el('div')(
    el('p')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count((c) => c + 1) })('Increment')
  );

document.body.appendChild(mount(App()).element!);
```

---

## el

Creates element specs. Specs are inert blueprintsâ€”they become real DOM when mounted.

```typescript
el('div')('Hello');

el('button').props({ disabled: true, className: 'btn' })('Click');

// Reactive props
el('p').props({ textContent: computed(() => `Count: ${count()}`) })();

// Lifecycle via ref
el('input')
  .ref((elem) => elem.focus())
  .ref((elem) => {
    elem.addEventListener('input', handler);
    return () => elem.removeEventListener('input', handler);
  })();
```

Partial application for reusable tags:

```typescript
const div = el('div');
const button = el('button');

const App = () =>
  div.props({ className: 'app' })(
    button.props({ onclick: handleClick })('Submit')
  );
```

---

## map

Reactive lists with keyed reconciliation.

```typescript
import { createMapModule } from '@rimitive/view/map';

const { signal, el, map } = compose(...modules, createMapModule(adapter));

const items = signal([
  { id: 1, text: 'First' },
  { id: 2, text: 'Second' },
]);

// Key function required for objects
map(
  items,
  (item) => item.id,
  (item) => el('li')(computed(() => item().text))
);

// Primitives don't need keys
const tags = signal(['a', 'b', 'c']);
map(tags, (tag) => el('span')(tag));
```

The render callback receives a reactive `item`â€”call `item()` to read.

---

## match

Conditional rendering. Switches views when the reactive value changes.

```typescript
import { createMatchModule } from '@rimitive/view/match';

const { signal, match } = compose(...modules, createMatchModule(adapter));

const tab = signal<'home' | 'settings'>('home');

match(tab, (current) => (current === 'home' ? HomePage() : SettingsPage()));

// Conditional show/hide
const showModal = signal(false);
match(showModal, (show) => (show ? Modal() : null));
```

---

## portal

Renders content into a different DOM location.

```typescript
import { createPortalModule } from '@rimitive/view/portal';

const { portal } = compose(...modules, createPortalModule(adapter));

// Portal to document.body (default)
portal()(el('div').props({ className: 'modal' })('Content'));

// Portal to specific element
portal(() => document.getElementById('tooltips'))(Tooltip());
```

---

## load

Async loading boundaries.

```typescript
import { LoadModule } from '@rimitive/view/load';

const { load, el } = compose(...modules, LoadModule);

load({
  loader: async () => {
    const data = await fetch('/api/data').then((r) => r.json());
    return DataView(data);
  },
  loading: () => el('div')('Loading...'),
  error: (err) => el('div')(`Error: ${err.message}`),
});
```

---

## mount

Creates real DOM from specs.

```typescript
import { MountModule } from '@rimitive/view/deps/mount';

const { mount } = compose(...modules, MountModule);

const ref = mount(App());
document.body.appendChild(ref.element!);

// Cleanup
ref.dispose?.();
```

---

## Adapters

View modules take an adapter for renderer-agnostic operation.

```typescript
// DOM (browser)
import { createDOMAdapter } from '@rimitive/view/adapters/dom';

// Test (no DOM required)
import { createTestAdapter } from '@rimitive/view/adapters/test';

// Custom (Canvas, WebGL, etc.)
import type { Adapter } from '@rimitive/view/adapter';

const myAdapter: Adapter<MyConfig> = {
  createNode: (tag, props) => { ... },
  setAttribute: (element, key, value) => { ... },
  insertBefore: (parent, node, anchor) => { ... },
  removeChild: (parent, node) => { ... },
  createTextNode: (text) => { ... },
  createComment: (text) => { ... },
};
```

---

## Specs vs Elements

**Specs** are dataâ€”inert descriptions of what to render:

```typescript
const spec = el('div')('Hello'); // Just data, no DOM
```

**Elements** are created when specs are mounted:

```typescript
const ref = mount(spec); // Now it's real DOM
document.body.appendChild(ref.element!);
```

This separation enables SSR, testing without a DOM, and composition before mounting.

---

### @rimitive/router

Routing as reactive state. The router provides signals (`matches`, `currentPath`), not renderingâ€”use `match()` from `@rimitive/view` to render.

## Quick Start

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createRouterModule, Link } from '@rimitive/router';

const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
  {
    id: 'products',
    path: 'products',
    children: [{ id: 'product-detail', path: ':id' }],
  },
];

const adapter = createDOMAdapter();

const { router, match, el } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  createMatchModule(adapter),
  createRouterModule(routes)
);
```

---

## Routes

Routes are plain objects with `id`, `path`, and optional `children`. Dynamic segments use `:param`:

```typescript
const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
  {
    id: 'products',
    path: 'products',
    children: [
      { id: 'product-list', path: '' },
      { id: 'product-detail', path: ':id' },
    ],
  },
];
```

---

## Rendering

`router.matches` is a reactive signal of matched routes. Use `match()` to render:

```typescript
const pages = {
  home: () => el('div')('Home Page'),
  about: () => el('div')('About Page'),
  'product-detail': (params) => el('div')(`Product ${params.id}`),
};

const App = () =>
  match(router.matches, (matches) => {
    const route = matches[0];
    if (!route) return el('div')('404 Not Found');

    const Page = pages[route.id];
    return Page ? Page(route.params) : el('div')('Unknown route');
  });
```

For nested routes, `matches` contains the full hierarchy:

```typescript
// URL: /products/123
router.matches();
// [
//   { id: 'products', path: '/products', params: {} },
//   { id: 'product-detail', path: '/products/123', params: { id: '123' } }
// ]
```

---

## Navigation

```typescript
router.navigate('/products/456');
router.back();
router.forward();
```

---

## Link

`Link` renders anchors with client-side navigation:

```typescript
import { Link } from '@rimitive/router';

Link({ href: '/about' })('About Us');
Link({ href: '/products', className: 'nav-link' })('Products');

// Dynamic href
Link({ href: computed(() => `/products/${productId()}`) })('View Product');
```

Modifier keys (Cmd/Ctrl+click) open new tabs. External URLs pass through unchanged.

---

## Location Signals

```typescript
// URL: /products?sort=price&filter=new#section-1

router.pathname(); // '/products'
router.search();   // '?sort=price&filter=new'
router.hash();     // '#section-1'
router.query();    // { sort: 'price', filter: 'new' }
```

---

## SSR

Pass `initialPath` for server-side rendering:

```typescript
const svc = compose(
  ...modules,
  createRouterModule(routes, { initialPath: req.url })
);
```

Works without `window`â€”uses the provided path and skips browser history APIs.

---

### @rimitive/resource

Reactive async data fetching. Automatic dependency tracking, cancellation, and race condition handling.

## Quick Start

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';
import { ResourceModule } from '@rimitive/resource';

const { signal, resource } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  ResourceModule
);

const products = resource((signal) =>
  fetch('/api/products', { signal }).then((r) => r.json())
);

// Full state (discriminated union)
products(); // { status: 'pending' | 'ready' | 'error', ... }

// Convenience accessors
products.loading(); // boolean
products.data(); // T | undefined
products.error(); // unknown | undefined
```

---

## Reactive Dependencies

Read signals inside the fetcher. Changes trigger automatic refetch with cancellation:

```typescript
const categoryId = signal(1);

const products = resource((signal) =>
  fetch(`/api/products?category=${categoryId()}`, { signal }).then((r) =>
    r.json()
  )
);

// Initial fetch: /api/products?category=1

categoryId(2);
// Aborts previous request, fetches /api/products?category=2
```

The fetcher receives an `AbortSignal`â€”pass it to `fetch()` for automatic cancellation when dependencies change or on dispose.

---

## Manual Control

```typescript
// Refetch after a mutation
await saveProduct(newProduct);
products.refetch();

// Cleanup (aborts in-flight request)
products.dispose();
```

In components, dispose via ref cleanup:

```typescript
const ProductList = () => {
  const products = resource((signal) =>
    fetch('/api/products', { signal }).then((r) => r.json())
  );

  return el('div').ref(() => () => products.dispose())();
  // ... render products
};
```

---

## Rendering

Use `match()` to render different states:

```typescript
const ProductList = () =>
  match(products, (state) => {
    switch (state.status) {
      case 'pending':
        return el('div')('Loading...');
      case 'error':
        return el('div')(
          `Error: ${state.error}`,
          el('button').props({ onclick: () => products.refetch() })('Retry')
        );
      case 'ready':
        return el('ul')(
          map(
            state.value,
            (p) => p.id,
            (product) => el('li')(computed(() => product().name))
          )
        );
    }
  });
```

---

### @rimitive/ssr

Server-side rendering and hydration. Effects are synchronous and run on the serverâ€”your reactive code works the same in both environments.

## Quick Start

### Server

```typescript
import { createServer } from 'node:http';
import {
  createLinkedomAdapter,
  renderToStringAsync,
} from '@rimitive/ssr/server';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } =
    createLinkedomAdapter();
  const service = createService(adapter);

  const html = await renderToStringAsync(App(service), {
    svc: service,
    mount: (spec) => spec.create(service),
    serialize,
    insertFragmentMarkers,
  });

  const loaderData = service.loader.getData();

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`
    <!DOCTYPE html>
    <html>
    <head>
      <script>window.__LOADER_DATA__ = ${JSON.stringify(loaderData)}</script>
    </head>
    <body>
      <div class="app">${html}</div>
      <script src="/client.js"></script>
    </body>
    </html>
  `);
});

server.listen(3000);
```

### Client

```typescript
import { createClientAdapter } from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

const adapter = createClientAdapter(document.querySelector('.app')!);
const ssrData = window.__LOADER_DATA__;
const service = createService(adapter, { hydrationData: ssrData });

App(service).create(service);
adapter.activate(); // Switch to normal DOM mode
```

---

## Shared Service

Your service factory takes an adapter, so server and client use the same components:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: { hydrationData?: Record<string, unknown>; onResolve?: (id: string, data: unknown) => void }
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    createLoaderModule({
      initialData: options?.hydrationData,
      onResolve: options?.onResolve,
    })
  );
}
```

---

## Loading Data

`load()` creates async boundaries. The `id` is how the client matches server-rendered data during hydration:

```typescript
const UserProfile = (svc: Service) => {
  const { loader, match, el } = svc;

  return loader.load(
    'user-profile', // ID for hydration
    () => fetch('/api/user').then((r) => r.json()),
    (state) =>
      match(state.status, (status) => {
        switch (status) {
          case 'pending':
            return el('div')('Loading...');
          case 'error':
            return el('div')(`Error: ${state.error()}`);
          case 'ready':
            return el('div')(
              el('h1')(state.data()!.name),
              el('p')(state.data()!.email)
            );
        }
      })
  );
};
```

---

## Streaming

Send HTML immediately, stream data as it loads:

### Server

```typescript
import {
  createLinkedomAdapter,
  renderToStream,
  createStreamWriter,
} from '@rimitive/ssr/server';

const stream = createStreamWriter('__APP_STREAM__');

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } =
    createLinkedomAdapter();

  const service = createService(adapter, {
    onResolve: (id, data) => {
      res.write(`<script>${stream.chunkCode(id, data)}</script>`);
    },
  });

  const { initialHtml, done } = renderToStream(App(service), {
    mount: (spec) => spec.create(service),
    serialize,
    insertFragmentMarkers,
  });

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.write(`<!DOCTYPE html>
<html>
<head><script>${stream.bootstrapCode()}</script></head>
<body>
  <div class="app">${initialHtml}</div>
  <script src="/client.js"></script>`);

  await done;
  res.end('</body></html>');
});
```

### Client

```typescript
import { createClientAdapter, connectStream } from '@rimitive/ssr/client';

const adapter = createClientAdapter(document.querySelector('.app')!);
const service = createService(adapter);

App(service).create(service);
adapter.activate();
connectStream(service, '__APP_STREAM__');
```

---

## Browser-Only Code

Effects and refs run on the server. Guard browser-specific code:

```typescript
el('input').ref((el) => {
  if (typeof window === 'undefined') return;
  el.focus();
})();
```

**Needs guards:** `focus()`, `blur()`, `scrollIntoView()`, `getBoundingClientRect()`, `window`, `localStorage`

**Works without guards:** Event handlers (`onclick`), basic DOM properties (`className`, `textContent`)

---

## Package Reference

- [@rimitive/core](https://github.com/hejhi/rimitive/tree/main/packages/rimitive): Core composition (`compose`, `defineModule`, `merge`)
- [@rimitive/signals](https://github.com/hejhi/rimitive/tree/main/packages/signals): Reactive primitives (`signal`, `computed`, `effect`, `batch`)
- [@rimitive/view](https://github.com/hejhi/rimitive/tree/main/packages/view): UI primitives (`el`, `map`, `match`, `portal`, `load`)
- [@rimitive/router](https://github.com/hejhi/rimitive/tree/main/packages/router): Reactive routing (`matches`, `navigate()`, `query`)
- [@rimitive/resource](https://github.com/hejhi/rimitive/tree/main/packages/resource): Async data fetching with `resource()`
- [@rimitive/ssr](https://github.com/hejhi/rimitive/tree/main/packages/ssr): Server-side rendering and streaming
- [@rimitive/react](https://github.com/hejhi/rimitive/tree/main/packages/react): React bindings
