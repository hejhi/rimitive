# Rimitive - Complete Documentation

> A set of composable libraries for TypeScript. Compose signals, views, and behaviors into applications with fine-grained reactivity.

This document contains the complete Rimitive documentation for LLM consumption.

---

## Project Overview (README)

Type-safe reactive primitives, atomic tooling, and compositional patterns you can use anywhere:

- Add signals to your no-build vanilla js project
- Build a headless design system with portable, reactive UI logic
- Write UI components for any javascript environment or platform
- Create a full stack SSR-with-streaming app

All constructed on a foundation of reactive primitives. Rimitive is built for low commitment and no framework lock-in. Take as much or as little of it as you want, and easily customize, extend, or replace along the way.

## Quickstart

### Install and Create a Service

```bash
npm install @rimitive/core @rimitive/signals
```

Rimitive allows you to create isolated reactive services (with no leakage or pollution of global state) through composition:

```ts
import { compose } from '@rimitive/core';

// 1. Import the modules you want to use
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';

// 2. Create a reactive service for your app or portable component
const { signal, computed, effect } = compose(
  SignalModule,
  ComputedModule,
  EffectModule
);

// 3. Use it wherever you want, no build or transpilation required
const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => console.log(doubled())); // logs: 0

count(1); // logs: 2
count(2); // logs: 4
```

If that's what you came for, you can stop here and use this in your vanilla js app or use/write bindings to bring Rimitive signals to other frameworks!

### Add Some UI

If you don't want to opt-in to a reactive framework like React, you can use Rimitive to tack on only the UI you need, complete with **fine-grained reactivity**:

```bash
npm install @rimitive/view
```

```ts
import { createElModule } from '@rimitive/view/el';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { MountModule } from '@rimitive/view/deps/mount';

const { signal, computed, el, mount } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // ðŸ‘‡ As easy as adding some new modules or module factories to your service
  createElModule(createDOMAdapter()),
  MountModule
);

const Counter = () => {
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('Increment')
  );
};

document.body.appendChild(mount(Counter()).element!);
```

Fun fact: UI "components" in Rimitive are just a functionâ€”they never re-render. They return a **spec** of a UI that can be mounted and unmounted...that's it. No build or transpilation required!

### Create Some Behaviors

A **behavior** is a pattern for encapsulating reactive state and actions into a reusable function (inspired by [SAM](https://sam.js.org/) and [downshift](https://www.downshift-js.com/)):

```ts
const useDisclosure = (initialOpen = false) => {
  const isOpen = signal(initialOpen);

  return {
    isOpen,
    open: () => isOpen(true),
    close: () => isOpen(false),
    toggle: () => isOpen(!isOpen()),
  };
};

// Use it anywhere
const disc = useDisclosure();
disc.open();
```

`use*` is just a naming convention; it doesn't confer any reactive superpowers like other frameworks, and there's no rules. This is just a pattern.

### Composition and Portability

Instead of directly importing from a shared service, you can wrap functions for service injection:

```ts
// Instead of importing directly...
const useDisclosure = (initialOpen = false) => {
  const isOpen = signal(initialOpen); // signal comes from somewhere
  // ...
};

// ...receive what you need
const disclosure =
  ({ signal }: Service) =>
  (initialOpen = false) => {
    const isOpen = signal(initialOpen);
    // ...
  };

// Then wire it up
const useDisclosure = svc(counter); // svc provides signal, computed, etc.
```

The same pattern works for components and ergonomic composition:

```ts
const dropdown = (svc: Service) => {
  // Compose other components or behaviors in the service closure
  // Runs a single time (not on every mount/unmount)
  const useDisclosure = svc(disclosure);

  return (options?: { initialOpen?: boolean }) => {
    const disc = useDisclosure(options?.initialOpen ?? false);

    // Add keyboard handling
    // Look ma, no memoization required! Remember? No re-rendering?
    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      disc.toggle();
    };

    return {
      ...disc,
      onKeyDown,
    };
  };
};

// Wire it up
const Dropdown = svc(dropdown);
const app = svc.mount(Dropdown());
```

Typing is a breeze:

```ts
export const svc = compose(SignalModule, ComputedModule);
export type Service = typeof svc;

const myComponent = ({ signal, computed }: Service) => {
  return () => // ...
};
```

Now you're a Rimitive expert! Everything else simply builds on top of this. Routing, data fetching, even SSR (with or without streaming)â€”they all work the same way. This just demonstrates the beginnings of what's possible with Rimitive.

---

## The stack

Rimitive is intentionally layered, allowing you to opt-in only as needed.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Domain Tooling                         â”‚
â”‚  view (el, map), router, resource, etc  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Adapters                               â”‚
â”‚  DOM, SSR, canvas, your own             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Reactive Core                          â”‚
â”‚  signal, computed, effect, etc          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- **Reactive core** â€” `signal`, `computed`, `effect`, etc. The foundation everything else is built with.
- **Domain tooling** â€” `el`, `map`, etc for views, `matches` for routing, `resource` for data. Each domain provides (but does not prescribe) tools built on the reactive core. Create your own!
- **Adapters** â€” Plug in where you want it to run, and the types flow through. DOM, SSR, logic-only (for hydration or testing), or roll your own. Any UI that can be modeled as a tree can have an adapter.

Each layer is tiny, opt-in, swappable, and extensible. Use just the signals, plug in only the views you need later, or bring behaviors to other frameworks like React.

---

## Packages

| Package                                   | Layer          | What it does                         |
| ----------------------------------------- | -------------- | ------------------------------------ |
| [`@rimitive/core`](packages/core)         | Core           | Wires modules together â€” `compose()` |
| [`@rimitive/signals`](packages/signals)   | Reactive core  | `signal`, `computed`, `effect`       |
| [`@rimitive/view`](packages/view)         | Domain tooling | View layer â€” `el`, `map`, `match`    |
| [`@rimitive/router`](packages/router)     | Domain tooling | Routing â€” `matches`, `navigate()`    |
| [`@rimitive/resource`](packages/resource) | Domain tooling | Async data fetching                  |
| [`@rimitive/ssr`](packages/ssr)           | Adapters       | Server-side rendering and streaming  |
| [`@rimitive/react`](packages/react)       | Bindings       | Use Rimitive behaviors in React      |

Start with `@rimitive/core` and `@rimitive/signals`. Add the rest as you need them.

## Advanced

### Adapters

Same code, different targets:

```ts
createElModule(createDOMAdapter()); // Browser
createElModule(createParse5Adapter()); // Server (SSR)
createElModule(myCanvasAdapter()); // Your own
```

### Extending

Create your own modules with `defineModule()`:

```ts
import { defineModule } from '@rimitive/core';

const LoggerModule = defineModule({
  name: 'logger',
  provides: { log: (msg: string) => console.log(`[app] ${msg}`) },
});

const { signal, log } = compose(SignalModule, LoggerModule);
```

See [Custom Modules](https://rimitive.dev/guides/custom-modules/) for the full picture.

---

## Status

Alpha. Tested, benchmarked, used in personal projects. Not yet battle-tested in production.

[Why Rimitive?](https://rimitive.dev/why/) â€” the story behind the project.

[Get started â†’](https://rimitive.dev/guides/getting-started)


---

## Adding a UI

## Extending the Service

You have signals and behaviors, so perhaps now we want to layer on some reactive UI.

Rimitive provides the `view` package that contains view-specific modules, with `el()` being the foundation: `el()` is a function for creating elements. It's renderer-agnostic (DOM, native, canvas, whatever), but we'll use the DOM adapter here since that's probably the most common use case.

Add the view modules to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

export const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // Let's add the `el` and `mount` modules from the `view` package, and provide the
  // DOM adapter to make DOM elements ðŸ‘‡
  createElModule(createDOMAdapter()),
  MountModule
);
export type Service = typeof svc;
```

Notice it's the same compose/service pattern as before, just now with more modules!

---

## Creating Elements

`el()` is curried: `el(tag)(children)`. It's all just factories:

```typescript
// A div tag
el('div')();

// An h1 with text ("Hello, World" are children)
el('h1')('Hello, World');

// A div with `el` children
el('div')(
  el('h1')('Title'),
  el('p')('Some text')
);
```

If you provided a different adapter, then you'd pass different (strongly typed!) strings (like `el("mySpecialElement")`). `el` returns a UI **spec** with a stable reference to the underlying elementâ€”it doesn't "re-render".

---

## Props

Use `.props()` to set reactive attributes and events:

```typescript
const isDisabled = signal(false);

const button = el('button').props({
  className: 'primary',
  disabled: isDisabled,
  onclick: () => console.log('clicked'),
})('Click me');

isDisabled(true);  // button becomes disabled, class changes
```

Props are type-safe, driven by the adapter provided.

---

## Reactive Content

Pass a computed for reactive text:

```typescript
const count = signal(0);

const display = el('div')(
  computed(() => `Count: ${count()}`)
);

count(5);  // display updates to "Count: 5"
```

---

## UI Components

The star of the show, UI components in Rimitive are...just functions that return UI specs:

```typescript
const Greeting = (name: string) =>
  el('div')(
    el('h2')(`Hello, ${name}!`),
    el('p')('Welcome to Rimitive.')
  );

const DoubleGreeting = () => el('div')(
  Greeting('Ada'),
  Greeting('Grace')
);
```

That's it, kind of anticlimactic. Here's a working example:

---

## Wrapping Components in Service Functions

Just like behaviors, components can be wrapped in a service function for portability:

```typescript
import type { Service } from './service';
import { counter } from './behaviors/counter';

const Counter = (svc: Service) => {
  const { el, computed } = svc;

  // The service function is so cyute isn't it??
  const useCounter = svc(counter);

  return (initial: number) => {
    const { count, doubled, increment, decrement, reset } = useCounter(initial);

    return el('div')(
      el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),
      el('div')(
        el('button').props({ onclick: decrement })('-'),
        el('button').props({ onclick: increment })('+'),
        el('button').props({ onclick: reset })('Reset')
      )
    );
  };
};

// Components can compose other components in the service function
const Counters = (svc: Service) => {
  const { el } = svc;
  const CounterComponent = svc(Counter);

  return () =>
    el('div')(
      CounterComponent(0),
      CounterComponent(100)
    );
};
```

Same shape as portable behaviors: `(svc) => (args) => result`. This is useful for testing, SSR, or sharing components across different service contexts.

---

## Mounting

Use `mount()` to actually attach to the DOM:

```typescript
const App = () => el('div')(
  el('h1')('My App')
);

const app = mount(App());
document.body.appendChild(app.element!);
```

---

## Adding Routing

Routing in Rimitive is simply reactive state. The router tracks the provided URL and matches it against your route definitions. You render different views by reacting to those matches.

---

## The Simplest Router

Start with just route definitions and a router:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';
import { createRouterModule } from '@rimitive/router';

// Define routes - pure data
const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
];

// Compose with router
const svc = compose(
  SignalModule,
  ComputedModule,
  // Add this ðŸ‘‡
  createRouterModule(routes)
);

const { router } = svc;
```

The router gives you reactive signals:

```typescript
router.currentPath();  // '/' or '/about'
router.matches();      // [{ id: 'home', pattern: '/', params: {}, path: '/' }]
```

Navigate programmatically:

```typescript
router.navigate('/about');
router.currentPath();  // '/about'
router.matches();      // [{ id: 'about', pattern: '/about', params: {}, path: '/about' }]
```

That's the core: routes in, reactive matches out.

---

## Rendering Routes

Use `match()` to render based on the matched route:

```typescript
// Page components
const Home = ({ el }: Service) => () => el('div')(
  el('h1')('Home'),
  el('p')('Welcome!')
);

const About = ({ el }: Service) => () => el('div')(
  el('h1')('About'),
  el('p')('Learn more about us.')
);

const NotFound = ({ el }: Service) => () => el('div')(
  el('h1')('404'),
  el('p')('Page not found.')
);

// App with routing
const App = (svc: Service) => () => {
  const { el, match, router } = svc;
  const HomePage = svc(Home);
  const AboutPage = svc(About);
  const NotFoundPage = svc(NotFound);

  const pages: Record<string, () => ReturnType<typeof el>> = {
    home: HomePage,
    about: AboutPage,
  };

  return el('div')(
    match(router.matches, (matches) => {
      const route = matches[0];
      if (!route) return NotFoundPage();

      const Page = pages[route.id];
      return Page ? Page() : NotFoundPage();
    })
  );
};

const AppComponent = svc(App);
const app = mount(AppComponent());
document.body.appendChild(app.element!);
```

When `router.matches` changes, `match()` swaps the rendered component.

---

## Adding Navigation

Use `Link` for declarative navigation that works with the router:

```typescript
import { createLinkModule } from '@rimitive/router/link';

// Add to service composition
const svc = compose(
  // ... other modules
  createLinkModule()
);

const Nav = ({ el, Link }: Service) => () => el('nav')(
  Link({ href: '/' })('Home'),
  Link({ href: '/about' })('About')
);

const App = (svc: Service) => () => {
  const { el, match, router } = svc;
  const NavComponent = svc(Nav);
  const NotFoundPage = svc(NotFound);

  // ... page setup from earlier

  return el('div')(
    NavComponent(),
    el('main')(
      match(router.matches, (matches) => {
        const route = matches[0];
        if (!route) return NotFoundPage();
        const Page = pages[route.id];
        return Page ? Page() : NotFoundPage();
      })
    )
  );
};
```

`Link` renders an `<a>` tag that intercepts clicks and calls `router.navigate()` instead of doing a full page reload.

For programmatic navigation, use `router.navigate()` directly:

```typescript
const Home = ({ el, router }: Service) => () => el('div')(
  el('h1')('Home'),
  el('button').props({
    onclick: () => router.navigate('/about')
  })('Go to About')
);
```

---

## Route Parameters

Capture dynamic segments with `:param` syntax:

```typescript
const routes = [
  { id: 'home', path: '' },
  { id: 'products', path: 'products' },
  { id: 'product-detail', path: 'products/:id' },
];
```

When the URL is `/products/123`, the match includes the parameter:

```typescript
router.navigate('/products/123');
router.matches();
// [{ id: 'product-detail', pattern: '/products/:id', params: { id: '123' }, path: '/products/123' }]
```

Use the params in your component:

```typescript
const ProductDetail = ({ el }: Service) => (params: { id: string }) => el('div')(
  el('h1')(`Product ${params.id}`),
  el('p')('Product details here...')
);

// In the App component's router match
const ProductDetailPage = svc(ProductDetail);

match(router.matches, (matches) => {
  const route = matches[0];
  if (!route) return NotFoundPage();

  if (route.id === 'product-detail') {
    return ProductDetailPage(route.params as { id: string });
  }

  const Page = pages[route.id];
  return Page ? Page() : NotFoundPage();
});
```

---

## Query Strings

The router parses query strings into reactive signals:

```typescript
// URL: /products?sort=price&category=electronics

router.search();  // '?sort=price&category=electronics'
router.query();   // { sort: 'price', category: 'electronics' }
```

React to query changes:

```typescript
const Products = ({ el, computed, router }: Service) => () => {
  const sortOrder = computed(() => router.query().sort || 'name');

  return el('div')(
    el('h1')('Products'),
    el('p')(computed(() => `Sorted by: ${sortOrder()}`)),
    el('button').props({
      onclick: () => router.navigate('/products?sort=price')
    })('Sort by Price')
  );
};
```

---

## Active Link Styling

Use `router.currentPath` to style the active link:

```typescript
const NavLink = ({ computed, router, Link }: Service) => (href: string, label: string) => {
  const isActive = computed(() => router.currentPath() === href);

  return Link({
    href,
    className: computed(() => isActive() ? 'nav-link active' : 'nav-link')
  })(label);
};

const Nav = (svc: Service) => () => {
  const { el } = svc;
  const navLink = svc(NavLink);

  return el('nav')(
    navLink('/', 'Home'),
    navLink('/about', 'About'),
    navLink('/products', 'Products')
  );
};
```

Routes are data, and matching is reactive. Rendering is just `match()` on `router.matches`, and everything composes with the same patterns you've already learned!

---

## Client Hydration

This guide covers hydrating server-rendered HTML on the client. Read [Server Rendering](/guides/server-rendering) first to set up the server side.

---

## What is Hydration?

The browser already has HTML on screen from the serverâ€”now we need to make it interactive. Instead of creating new DOM elements (which would cause a flash), the hydration adapter _walks_ the existing DOM and attaches your event listeners and reactive bindings.

After hydration completes, we fall back to a normal DOM adapter for subsequent updates.

---

## Setting Up Hydration

The key is `createHydrationAdapter()`, which takes a hydration adapter as the first argument and the fallback DOM adapter as the second:

```typescript
// client.ts
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import {
  createDOMHydrationAdapter,
  createHydrationAdapter,
} from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

// ðŸ‘‡ Create hydration adapter that walks existing DOM
const hydrationAdapter = createHydrationAdapter(
  createDOMHydrationAdapter(document.querySelector('.app')!),
  // Falls back after hydration!
  createDOMAdapter()
);

// Create your service as usual on the client
const service = createService(hydrationAdapter);

// Hydrate - walks existing DOM, wires up reactivity
App(service).create(service);

// Switch to the fallback normal DOM mode for future updates
hydrationAdapter.switchToFallback();
```

### What happens:

1. `createDOMHydrationAdapter` wraps the existing `.app` elementâ€”it will walk the DOM instead of creating new elements
2. `createHydrationAdapter` combines it with a normal `createDOMAdapter()` to use after hydration
3. `App(service).create(service)` runs your app, but instead of building DOM, it attaches signals and event listeners to what's already there
4. `switchToFallback()` switches to the normal adapterâ€”future updates create/modify DOM elements as usual

---

## Browser-Only Code

If you have browser-specific code that might run on the server (focus, scroll, animate, etc.), add guards:

```typescript
el('input').ref((el) => {
  if (typeof window !== 'undefined') el.focus();
})()
```

---

If you have no asynchronous data to fetch and load on the server, this might be enough for your use case and you can stop here. Otherwise, onwards to async.

## Next Steps

This covers basic hydration for synchronous SSR. For async data:

- **[SSR with Data Loading](/guides/ssr-loading)** â€” Fetch data during SSR with `load()`
- **[Streaming SSR](/guides/streaming-ssr)** â€” Send HTML progressively as data loads

---

## Creating a Behavior

<!-- @tags: behavior, hook, reusable-logic, headless, state-management, portable -->

A **behavior** is a pattern for encapsulating reactive state and actions into a reusable function (inspired by [SAM](https://sam.js.org/) and [downshift](https://www.downshift-js.com/)).

---

## The Simple Approach

The easiest way to create a behavior is to import directly from your service:

```typescript
// behaviors/useCounter.ts
import { signal, computed } from '../service';

// Again, use* is just a convention, this is not prescribed and not React!
export const useCounter = (initial = 0) => {
  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

Use it anywhere:

```typescript
import { useCounter } from './behaviors/useCounter';

const counter = useCounter(10);
counter.increment();
counter.count();  // 11
```

---

<!-- @tags: portable, service-injection, testable, ssr, dependency-injection -->

## Using a Service Wrapper for Portability

When you need behaviors that work across different contextsâ€”testing with mocks, sharing between apps, or SSRâ€”use the portable pattern. This is, generally speaking, the preferred pattern.

```typescript
// Remember how we exported `typeof svc` in the previous guide example?
import type { Service } from './service';

const myBehavior = (svc: Service) => {
  // This would be called during composition like `const useMyBehavior = svc(myBehavior)`.
  // This is colloquially known as the **service function** or **service closure**. 
  // It's also where you'd compose other behaviors or components.
  return (options?) => // ...
}
```

This silly little pattern doesn't look like much but opens up a whole world of fun possibilities. It also decouples your function from Rimitive! you could pass in whatever you want for `svc` later, as long as it matches the Service type. So from now on, we'll be working with portable functions.

### A Counter Example

```typescript
import type { Service } from './service';

const counter = ({ signal, computed }: Service) => (initial = 0) => {
  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

### Using It

```typescript
import { svc } from './service';

// As mentioned before, `svc` itself is callable, injects the service, and returns the inner component
const useCounter = svc(counter);
const c = useCounter(10);

c.count();
c.increment();
c.doubled();
```

`svc(counter)` provides (or injects) the service, and is type-safe. Then you have a ready-to-use behavior or component bound to your service.

---

<!-- @tags: compose-behaviors, disclosure, dropdown, service-layer, reuse -->

## Composing Behaviors

Behaviors ergonomically compose other behaviors. To demonstrate this, let's start with a basic portable behavior:

```typescript
const disclosure = ({ signal }: Service) => (initialOpen = false) => {
  const isOpen = signal(initialOpen);

  return {
    isOpen,
    open: () => isOpen(true),
    close: () => isOpen(false),
    toggle: () => isOpen(!isOpen()),
  };
};
```

Now, we can compose it:

```typescript
const dropdown = (svc: Service) => {
  // Utilize the service closure as a space to compose
  const useDisclosure = svc(disclosure);

  return (options?: { initialOpen?: boolean }) => {
    const disc = useDisclosure(options?.initialOpen ?? false);

    // Add keyboard handling
    // Look ma, no memoization required!
    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      disc.toggle();
    };

    return {
      ...disc,
      onKeyDown,
    };
  };
};
```

Now `dropdown` composes `disclosure`! They both use the same behavior shape of `(svc) => (args) => api`, but one composes the other. The outer service function is a convenient place to inject services a single time.

---

<!-- @tags: testing, vitest, unit-test, behavior-test -->

## Testing

Behaviors are trivial to test. Just import your service:

```typescript
import { describe, it, expect } from 'vitest';
import { svc } from './service';

describe('counter', () => {
  it('increments', () => {
    const c = svc(counter)(0);

    c.increment();
    c.increment();

    expect(c.count()).toBe(2);
  });

  it('respects initial value', () => {
    const c = svc(counter)(50);

    expect(c.count()).toBe(50);
    c.reset();
    expect(c.count()).toBe(50);
  });
});
```

Pure functions, pure tests. Again, if this is all you need, you can stop here. If you want a reactive UI and UI components, as the kids say, "let's gooooo".

---

## Creating a Service

<!-- @tags: service, compose, setup, configuration, modules, dependency-injection -->

To use Rimitive, start by creating a **reactive service**. Services and modules are constructs of our flyweight dependency injection (DI) system in [`core`](https://github.com/hejhi/rimitive/packages/core) (the DI system, which can be used outside of Rimitive as well).

The simplest example of a reactive service:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule);
const { signal } = svc;
```

- A **service** is the result of calling `compose()`. It bundles selected modules into an isolated reactive context.
- A **module** is what you provide to `compose()`. Modules can depend on other modules, and `compose()` bundles everything up into a service where they all share the same underlying reactive graph.

Using `svc` to represent a service is a convention you'll see used throughout these docs.

This service wouldn't do much on its ownâ€”nothing is connected to react to signal changes yet.

---

## Adding More Modules

We can add some more modules that _would_ react to signal updates:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(SignalModule, ComputedModule, EffectModule);
```

Then use them:

```ts
const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => {
  console.log('Count is now:', count());
});

// ...etc
```

Reactive dependencies are automatically tracked in Rimitive, so you don't need to worry about it.

---

## Why `compose()`?

Each `compose()` call creates an independent reactive context with no global leakage. This means:

- **Isolation**: Multiple services don't interfere with each other
- **Testing**: Fresh contexts per test, no cleanup needed
- **Tree-shaking**: Only bundle what you use
- **Extensibility**: Add [view modules](/guides/adding-a-ui), [router](/guides/adding-routing), or [custom modules](/guides/custom-modules) later

---

## Custom Modules

You can define your own modules with `defineModule` and compose them alongside signals, view, or anything else.

---

## Defining a Module

A module needs a `name` and a `create` function:

```typescript
import { defineModule, compose } from '@rimitive/core';

const LoggerModule = defineModule({
  name: 'logger',
  create: () => ({
    log: (msg: string) => console.log(`[LOG] ${msg}`),
    error: (msg: string) => console.error(`[ERROR] ${msg}`),
  }),
});

const svc = compose(LoggerModule);
svc.logger.log('hello');
```

The `name` becomes the key on the composed service. Whatever `create` returns becomes the value.

---

## Modules with Dependencies

Modules can depend on other modules. List them in `dependencies`, and they'll be available in `create`:

```typescript
import { defineModule, compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';

const CounterModule = defineModule({
  name: 'counter',
  dependencies: [SignalModule, ComputedModule],
  create: ({ signal, computed }) => (initial = 0) => {
    const count = signal(initial);
    const doubled = computed(() => count() * 2);
    return {
      count,
      doubled,
      increment: () => count(count() + 1),
      decrement: () => count(count() - 1),
    };
  },
});

const svc = compose(CounterModule);
const myCounter = svc.counter(10);

myCounter.count();      // 10
myCounter.increment();
myCounter.count();      // 11
myCounter.doubled();    // 22
```

Dependencies are resolved automatically. You only need to pass the modules you wantâ€”`compose()` includes transitive dependencies.

---

## Module Lifecycle

Modules can hook into lifecycle events:

```typescript
const ConnectionModule = defineModule({
  name: 'connection',
  create: () => {
    const ws = new WebSocket('wss://example.com');
    return {
      send: (msg: string) => ws.send(msg),
      socket: ws,
    };
  },
  init: (ctx) => {
    // Called before create, useful for setup
  },
  destroy: (ctx) => {
    // Called when svc.dispose() is invoked
  },
});

const svc = compose(ConnectionModule);
// ... use the connection
svc.dispose(); // triggers destroy hooks
```

---

## Beyond Reactivity

Here's the thing: `@rimitive/core` has no concept of reactivity. It's just a composition mechanism. You can use it for anything:

```typescript
import { defineModule, compose } from '@rimitive/core';

const HttpModule = defineModule({
  name: 'http',
  create: () => ({
    get: (url: string) => fetch(url).then(r => r.json()),
    post: (url: string, data: unknown) =>
      fetch(url, { method: 'POST', body: JSON.stringify(data) }).then(r => r.json()),
  }),
});

const CacheModule = defineModule({
  name: 'cache',
  create: () => {
    const store = new Map<string, unknown>();
    return {
      get: <T>(key: string): T | undefined => store.get(key) as T,
      set: <T>(key: string, value: T): void => { store.set(key, value); },
      clear: () => store.clear(),
    };
  },
});

const ApiModule = defineModule({
  name: 'api',
  dependencies: [HttpModule, CacheModule],
  create: ({ http, cache }) => ({
    async getUser(id: string) {
      const cached = cache.get<User>(`user:${id}`);
      if (cached) return cached;

      const user = await http.get(`/api/users/${id}`);
      cache.set(`user:${id}`, user);
      return user;
    },
  }),
});

const svc = compose(ApiModule);
await svc.api.getUser('123');
```

This makes `compose()` useful for any library or application architectureâ€”not just UI frameworks. You control what gets composed.

---

## Tree-Shaking

Because you explicitly compose modules, everything is fully tree-shakeable. If you don't use `EffectModule`, it won't be in your bundle. If you only need signals without a view, just compose signals:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule, ComputedModule);
// No view code bundled
```

---

## When to Create Modules

Create a module when you want to:

- **Add new modules** to a composed service
- **Share infrastructure** (logging, http, storage) across behaviors
- **Encapsulate setup/teardown** with lifecycle hooks
- **Build your own libraries** on top of composition

For reusable reactive logic, prefer [behaviors](/guides/creating-a-behavior). Behaviors are simpler and don't require `defineModule`. Use modules when you need something that lives at the composition level.

---

## Getting Started

<!-- @tags: getting-started, installation, setup, quickstart, hello-world, first-app -->

## Installation

```bash
npm install @rimitive/core @rimitive/signals
```

<!-- @tags: counter, example, tutorial, reactive-state, dom-rendering -->

## Your First App

Create a counter with reactive state and DOM rendering. Start by installing the deps:

```bash
npm install @rimitive/core @rimitive/signals @rimitive/view
```

Then, create the app:

That's it! Click the button, the count updates, the DOM updates automatically.

## What Just Happened?

1. **`compose()`** wires modules together into a service
2. **`signal()`** creates reactive state â€” read with `count()`, write with `count(newValue)`
3. **`computed()`** derives values that update when dependencies change
4. **`el()`** creates DOM elements with reactive children and props
5. **`mount()`** attaches the element tree to the DOM

If you're lost already, don't worry. We'll start from the very basics. These docs also cover reactive patterns in-depth, so you can jump around if you get confused at any time.

Rimitive is as much about patterns as it is about reactive modules and tooling, so if at any point you hate it, you can always take any patterns that inspired you elsewhere!

---

## Intro to SSR

Server-side rendering (SSR) renders your app to HTML on the server before sending it to the browser. Instead of shipping an empty `<div id="app">` and waiting for JavaScript to build the page, users see content immediately.

---

## Why SSR?

**Faster first paint.** Users see content before JavaScript loads. On slow connections or devices, this difference is significant.

**SEO.** Search engines index the HTML you send. Client-rendered apps require crawlers to execute JavaScript, which not all do well.

**Social sharing.** Link previews (OpenGraph, Twitter cards) scrape your HTML. SSR ensures they get real content.

**When to skip SSR:** Internal tools, dashboards, and apps behind auth often don't need SSR. The added complexity isn't worth it if SEO and initial load time aren't priorities.

---

## What is SSR?

Your app runs twice: once on the server, once on the client. The following questions break down what that means.

### _Why_ execute it on the server to begin with?

- Reactive apps generate dynamic, interactive content, but at the end of the day for web apps, the output that the user sees and interacts with is HTML
- The server can be used to execute your app and generate the _exact HTML_ structure your app would have otherwise output in the browser on load
- That server-generated HTML can be serialized and sent to the client when a user visits a page, rendering the HTML old-school styleâ€”just like a PHP site would render HTML, except that it was _actually_ generated from executing your app on the server
- When the page loads in the client, the user sees the _identical HTML output_ they would have seen after your app loads in the client, but before the js even loadsâ€”_identical_ is the key word hereâ€”if it's _not_ identical, then that results in a hydration mismatch (described later)
- This provides an instantaneous load time for the user

A static HTML page is obviously not what you want. Somehow, your app needs to "catch up" to the rendered HTML, and take back ownership over the markup to make it interactive. That's what we call **hydration**.

### How does it run on the server?

Your app is JavaScript, and JavaScript can run on the server. For view modules like `el`, Rimitive lets you swap in a server-friendly adapter that generates markup without a real DOM.

The out-of-the-box server adapter is powered by [`parse5`](https://github.com/inikulin/parse5), a lightweight HTML parser. When `el("div")` runs on the server, it creates a parse5 element instead of a real DOM element. This lets parse5 render your app's HTML structure the same way the browser would.

That generated HTML structure is then serialized into a string and sent to the client.

### What about browser APIs and events?

Browser and DOM events aren't supported on the server, and browser-specific APIs won't work. You'll need to add guards for code that touches these:

```typescript
el('input').ref((el) => {
  if (typeof window !== 'undefined') el.focus();
})()
```

In an ideal world, imperative DOM work is contained within refs, making it easy to guard.

### What about fetched data?

Rimitive supports data fetching during SSR with the `load()` module.

### What is Hydration?

When the browser receives SSR HTML, it displays it immediatelyâ€”but it's static. Buttons don't work, inputs don't respond. The page needs JavaScript to become interactive.

**Hydration** is the process of making that static HTML interactive. Instead of throwing away the HTML and rebuilding the DOM from scratch (which would cause a flash), hydration walks the existing DOM and attaches your app's event listeners and reactive bindings.

Rimitive provides a hydration adapter that you plug into `createElModule()`. During hydration, this adapter walks the existing DOM elements instead of creating new ones, wiring up your signals and event handlers to what's already there.

---

## The Mental Model

1. **Server renders your app** â€” using a server adapter that creates parse5 elements
2. **HTML is serialized and sent** â€” the client receives fully-rendered markup
3. **Browser displays HTML immediately** â€” users see content before JS loads
4. **Client JavaScript loads** â€” your app code runs again
5. **Hydration walks the DOM** â€” attaches reactivity to existing elements
6. **App is interactive** â€” future updates use normal DOM operations

The server and client must produce _identical_ HTML. If they don't, you get a hydration mismatch error.

---

## Next Steps

Ready to implement? Continue to the practical guides:

- **[Server Rendering](/guides/server-rendering)** â€” Set up basic SSR with adapters
- **[SSR with Data Loading](/guides/ssr-loading)** â€” Fetch data during SSR with `load()`
- **[Streaming SSR](/guides/streaming-ssr)** â€” Send HTML progressively as data loads

---

## Loading Data

<!-- @tags: resource, fetch, async, data-loading, api, http, loading-state, error-state -->

Data loading in Rimitive is reactive. When dependencies change, data refetches. When requests overlap, stale ones get cancelled. Let's build up to that.

---

## The Manual Way

You _could_ manage async state yourself with signals and effects, but you'd likely end up manually setting loading, error, and data states as signals, as well as cancellation. When dependencies change mid-flight, if you're not careful, you could also end up with race conditions.

---

## Using resource()

`resource()` handles all of this in a tiny module. Add the resource module to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { ResourceModule } from '@rimitive/resource';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';

const adapter = createDOMAdapter();

export const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  ResourceModule,
  createElModule(adapter),
  createMatchModule(adapter)
);

export type Service = typeof svc;
```

---

## Basic Usage

Create a resource inside your component with a fetcher function:

```typescript
const ProductList = ({ resource, el, match }: Service) => {
  return () => {
    const products = resource<Product[]>((signal) =>
      fetch('/api/products', { signal }).then(r => r.json())
    );

    return el('div').ref(() => products.dispose)(
      match(products, (state) => {
        switch (state.status) {
          case 'pending':
            return el('div')('Loading...');
          case 'error':
            return el('div')(`Error: ${state.error}`);
          case 'ready':
            return el('ul')(
              ...state.value.map(p => el('li')(p.name))
            );
        }
      })
    );
  };
};
```

Notice that:
- the fetcher receives an `AbortSignal` - pass it to `fetch()` for automatic cancellation
- we create resources **inside the component function**, not at module level
- we call `dispose()` when the component unmounts to abort in-flight requests

### Reading State

A resource has multiple ways to read its state:

```typescript
// Full state object
products();
// { status: 'idle' }     // when enabled=false
// { status: 'pending' }
// { status: 'ready', value: [...] }
// { status: 'error', error: Error }

// Convenience accessors
products.idle();     // true when disabled
products.loading();  // true when pending
products.data();     // T | undefined
products.error();    // unknown | undefined
```

All are reactiveâ€”use them in computeds or effects.

---

<!-- @tags: reactive-fetch, auto-refetch, dependency-tracking, abort-controller, cancellation -->

## Reactive Dependencies

Here's where resources shine. Read signals inside the fetcher, and the resource refetches when they change:

```typescript
const ProductList = (svc: Service) => {
  const { signal, resource, el, match } = svc;

  return (initialCategory: string) => {
    const category = signal(initialCategory);

    const products = resource<Product[]>((signal) =>
      fetch(`/api/products?category=${category()}`, { signal })
        .then(r => r.json())
    );

    return el('div').ref(() => () => products.dispose())(
      el('div')(
        el('button').props({ onclick: () => category('electronics') })('Electronics'),
        el('button').props({ onclick: () => category('books') })('Books')
      ),
      match(products, (state) => {
        // ... render based on state
      })
    );
  };
};
```

When `category` changes:
1. The previous request is automatically aborted
2. A new fetch starts with the updated category
3. No race conditions, no stale data

### Multiple Dependencies

Track as many signals as you need:

```typescript
const ProductList = (svc: Service) => {
  const { signal, resource } = svc;

  return () => {
    const category = signal('electronics');
    const sortBy = signal('price');
    const page = signal(1);

    const products = resource<Product[]>((signal) =>
      fetch(
        `/api/products?category=${category()}&sort=${sortBy()}&page=${page()}`,
        { signal }
      ).then(r => r.json())
    );

    // Any change triggers a refetch with automatic cancellation
    // category('books');   // refetch
    // sortBy('rating');    // refetch
    // page(2);             // refetch

    return el('div').ref(() => () => products.dispose())(
      // ... render with filters and pagination controls
    );
  };
};
```

---

<!-- @tags: loading-ui, error-ui, loading-spinner, skeleton, status -->

## Rendering Resources

Use `match()` to render based on resource state:

```typescript
const UserProfile = (svc: Service) => {
  const { resource, el, match, computed } = svc;

  return (userId: string) => {
    const user = resource<User>((signal) =>
      fetch(`/api/users/${userId}`, { signal }).then(r => r.json())
    );

    return el('div').ref(() => () => user.dispose())(
      match(user, (state) => {
        switch (state.status) {
          case 'idle':
            return null; // Resource disabled
          case 'pending':
            return el('div').props({ className: 'skeleton' })('Loading profile...');
          case 'error':
            return el('div').props({ className: 'error' })(
              `Failed to load: ${state.error}`
            );
          case 'ready':
            return el('div')(
              el('h1')(state.value.name),
              el('p')(state.value.email)
            );
        }
      })
    );
  };
};
```

---

## Refetch and Dispose

### Manual Refetch

Trigger a refetch programmatically (useful for "refresh" buttons or after mutations):

```typescript
const ProductList = (svc: Service) => {
  const { resource, el, match } = svc;

  return () => {
    const products = resource<Product[]>((signal) =>
      fetch('/api/products', { signal }).then(r => r.json())
    );

    return el('div').ref(() => () => products.dispose())(
      el('button').props({ onclick: () => products.refetch() })('Refresh'),
      match(products, (state) => {
        // ... render
      })
    );
  };
};
```

### Cleanup

Always dispose resources when the component unmounts. The `.ref()` callback pattern works well:

```typescript
return el('div').ref(() => {
  // Return cleanup function
  return () => products.dispose();
})(
  // ... children
);
```

This aborts any in-flight request and stops dependency tracking.

---

## Options

### enabled

Control whether the resource fetches with the `enabled` option:

```typescript
const ProductList = (svc: Service) => {
  const { signal, resource, el } = svc;

  return (selectedId: string | null) => {
    const id = signal(selectedId);

    // Only fetch when we have an ID
    const product = resource<Product>(
      (s) => fetch(`/api/products/${id()}`, { signal: s }).then(r => r.json()),
      { enabled: () => id() !== null }
    );

    // product.idle() is true when disabled
    return el('div').ref(() => () => product.dispose())(
      product.idle()
        ? el('p')('Select a product')
        : el('p')(product.data()?.name ?? 'Loading...')
    );
  };
};
```

`enabled` accepts a boolean or a reactive function. When false, the resource stays in `idle` state. When it becomes true, fetching begins.

#### Lazy Fetching

Use `enabled` to defer fetching until a user action:

```typescript
const ReportViewer = (svc: Service) => {
  const { signal, resource, el, match } = svc;

  return (reportId: string) => {
    const shouldLoad = signal(false);

    const report = resource<Report>(
      (s) => fetch(`/api/reports/${reportId}`, { signal: s }).then(r => r.json()),
      { enabled: shouldLoad }
    );

    return el('div').ref(() => () => report.dispose())(
      match(report, (state) => {
        if (state.status === 'idle') {
          return el('button').props({ onclick: () => shouldLoad(true) })(
            'Load Report'
          );
        }
        if (state.status === 'pending') return el('p')('Loading...');
        if (state.status === 'error') return el('p')(`Error: ${state.error}`);
        return el('div')(/* render report */);
      })
    );
  };
};
```

The resource stays idle until the user clicks "Load Report", then fetches.

### flush

Control when refetches execute with the `flush` option:

```typescript
import { mt, debounce } from '@rimitive/signals/strategies';

// Defer refetches to microtask (coalesces rapid updates)
const products = resource(fetcher, { flush: mt });

// Debounce refetches (useful for search-as-you-type)
const results = resource(
  (s) => fetch(`/api/search?q=${query()}`, { signal: s }).then(r => r.json()),
  { flush: (run) => debounce(300, run) }
);
```

Without `flush`, refetches are synchronousâ€”each dependency change triggers an immediate fetch. With a flush strategy, rapid updates are coalesced.

---

## resource() vs load()

Rimitive has two modules for async data:

| | `resource()` | `load()` |
|---|---|---|
| **Use case** | Client-side data fetching | Server-rendered data with hydration |
| **Reactive deps** | Yesâ€”refetches when signals change | Noâ€”fetches once |
| **Cancellation** | Automatic via AbortSignal | No |
| **SSR support** | No | Yesâ€”data serializes for hydration |

**Use `resource()` when:**
- Building a client-only app
- Data depends on user interaction (filters, pagination, search)
- You need automatic refetching and cancellation

**Use `load()` when:**
- You're doing SSR and want data in the initial HTML
- The data should be fetched on the server and reused on the client
- SEO or first-paint performance matters for this data

<Aside type="caution" title="SSR Note">
`resource()` starts fetching immediately when created. In SSR apps:

- Use `load()` for data that should be server-rendered
- Use `resource()` for client-side dynamic data (filters, search, user interactions)
- For client-only resources, use the `enabled` option or a flush strategy:

```typescript
// Option 1: enabled (resource stays idle on server)
const data = resource(fetcher, {
  enabled: () => typeof window !== 'undefined'
});

// Option 2: flush strategy (runs once on server, no re-runs)
const data = resource(fetcher, { flush: mt });
```
</Aside>

In an SSR app, you might use both: `load()` for the initial page data that should be server-rendered, and `resource()` for dynamic data that loads after user interaction.

See [SSR with Data Loading](/guides/ssr-loading) for `load()` usage.

---

## Refs and DOM Access

<!-- @tags: ref, dom-access, focus, imperative, third-party, canvas, resize-observer, cleanup -->

Sometimes you need direct DOM accessâ€”for focus management, measurements, third-party library integration, or canvas drawing. Rimitive handles this with the `.ref()` method on elements.

---

## Basic Ref Usage

The `.ref()` method takes a callback that runs when the element is mounted:

```typescript
const AutofocusInput = ({ el }: Service) => () => {
  return el('input').ref((node) => {
    node.focus();
  })();
};
```

---

## Cleanup

Return a cleanup function from the callback:

```typescript
const ResizeObserved = ({ el, signal }: Service) => () => {
  const dimensions = signal({ width: 0, height: 0 });

  return el('div').ref((node) => {
    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      dimensions({ width, height });
    });

    observer.observe(node);

    // Return cleanup function
    return () => observer.disconnect();
  })(
    // ... children
  );
};
```

The cleanup runs when the element is removed from the DOM.

---

## Passing Refs to Children

If a parent needs access to a child's DOM node, pass a callback:

```typescript
const input = ({ el }: Service) => (props: { onRef?: (node: HTMLInputElement) => void }) => {
  return el('input').ref((node) => {
    props.onRef?.(node);
  })();
};

const Form = (svc: Service) => () => {
  const { el } = svc;
  const Input = svc(input);  // Wired component gets PascalCase
  let inputNode: HTMLInputElement | null = null;

  return el('form')(
    Input({ onRef: (node) => { inputNode = node; } }),
    el('button').props({
      onclick: () => inputNode?.focus()
    })('Focus Input')
  );
};
```

Or with signals for reactive access:

```typescript
const Form = (svc: Service) => () => {
  const { el, signal } = svc;
  const Input = svc(input);
  const inputRef = signal<HTMLInputElement | null>(null);

  return el('form')(
    Input({ onRef: (node) => inputRef(node) }),
    el('button').props({
      onclick: () => inputRef()?.focus()
    })('Focus Input')
  );
};
```

---

## Third-Party Library Integration

Use refs to integrate non-reactive libraries:

```typescript
const Chart = ({ el, effect }: Service) => (props: { data: Readable<ChartData> }) => {
  return el('canvas').ref((canvas) => {
    // Initialize chart library
    const chart = new ChartLibrary(canvas, {
      data: props.data()
    });

    // Update chart when data changes
    const disposeEffect = effect(() => {
      chart.update(props.data());
    });

    // Return cleanup
    return () => {
      disposeEffect();
      chart.destroy();
    };
  })();
};
```

---

## Multiple Refs

For collections, store refs in a map:

```typescript
const ScrollableList = ({ el, signal, map }: Service) => () => {
  const items = signal(['a', 'b', 'c', 'd', 'e']);
  const itemRefs = new Map<string, HTMLElement>();

  const scrollToItem = (id: string) => {
    itemRefs.get(id)?.scrollIntoView({ behavior: 'smooth' });
  };

  return el('div')(
    el('div')(
      ...['a', 'b', 'c', 'd', 'e'].map(id =>
        el('button').props({ onclick: () => scrollToItem(id) })(`Go to ${id}`)
      )
    ),
    el('div').props({ style: 'height: 200px; overflow: auto' })(
      map(items, (item) =>
        el('div').props({ style: 'height: 100px' }).ref((node) => {
          itemRefs.set(item(), node);
          return () => itemRefs.delete(item());
        })(item)
      )
    )
  );
};
```

---

## Anti-patterns

### Don't Forget Cleanup

Refs that set up observers, listeners, or other subscriptions need cleanup to avoid memory leaks:

```typescript
// âŒ WRONG - observer never disconnected
const Measured = (svc: Service) => () => {
  const { el, signal } = svc;
  const size = signal({ width: 0, height: 0 });

  return el('div').ref((node) => {
    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      size({ width, height });
    });
    observer.observe(node);
    // Missing cleanup! Observer lives forever
  })();
};
```

```typescript
// âœ… CORRECT - return cleanup function
const Measured = (svc: Service) => () => {
  const { el, signal } = svc;
  const size = signal({ width: 0, height: 0 });

  return el('div').ref((node) => {
    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      size({ width, height });
    });
    observer.observe(node);

    return () => observer.disconnect();  // Cleanup when unmounted
  })();
};
```

---

## Server Rendering

This guide covers the practical setup for basic SSR. If you're new to SSR concepts, read [Intro to SSR](/guides/intro-to-ssr) first.

---

## Render Functions

Rimitive provides three render functions for different SSR needs:

| Function | Use Case |
|----------|----------|
| `renderToString` | Basic sync SSR â€” no async data loading |
| `renderToStringAsync` | Waits for all `load()` boundaries before returning HTML |
| `renderToStream` | Sends HTML immediately, streams data as it loads |

This guide covers `renderToString`. For async data loading, see [SSR with Data Loading](/guides/ssr-loading). For streaming, see [Streaming SSR](/guides/streaming-ssr).

---

## What You Need

For basic SSR, you need:
1. A **server adapter** that creates elements using parse5 instead of the real DOM
2. A **client hydration adapter** that walks existing DOM instead of creating new elements

---

## Shared Service

Start with creating the service a little differently than normal. This time, `createService()` will take an adapter, so both the server and client can use the same service for running:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

//                            ðŸ‘‡ New!
export function createService(adapter: Adapter<DOMAdapterConfig>) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter)
  );
}

export type Service = ReturnType<typeof createService>;
```

Now, this file can be shared with both the server and the client âœ¨

## Server Setup

`createParse5Adapter()` creates a server-friendly adapter powered by [parse5](https://github.com/inikulin/parse5), a lightweight HTML parser for Node.js. When `el("div")` runs on the server, it creates a parse5 element instead of a real DOM elementâ€”same structure, no browser required.

Create a fresh adapter and service for each incoming request. Reusing them across requests would cause data from one user to leak into another's response.

```typescript
// server.ts
import { createServer } from 'node:http';
import { createParse5Adapter, renderToString } from '@rimitive/ssr/server';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer((req, res) => {
  // Create per-request adapter and service
  const { adapter, serialize } = createParse5Adapter();
  const service = createService(adapter);

  // Create and render the app
  const root = App(service).create(service);
  const html = renderToString(root, serialize);

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`<!DOCTYPE html>
<html>
<body>
  <div class="app">${html}</div>
  <script src="/client.js"></script>
</body>
</html>`);
});

server.listen(3000);
```

### What happens:

1. `createParse5Adapter()` returns an `adapter` (for creating elements) and `serialize` (for converting individual elements to HTML)
2. `createService(adapter)` wires up your app with the server adapter
3. `App(service).create(service)` runs your app, building a parse5 element tree
4. `renderToString(root, serialize)` walks the tree and converts it to an HTML string

Finally the HTML is sent to the client (and your `<script>` tag loads the client bundle).

---

## Next Steps

- **[Client Hydration](/guides/client-hydration)** â€” Make the server-rendered HTML interactive
- **[SSR with Data Loading](/guides/ssr-loading)** â€” Fetch data during SSR with `load()`
- **[Streaming SSR](/guides/streaming-ssr)** â€” Send HTML progressively as data loads

---

## SSR with Data Loading

This guide builds on [Server Rendering](/guides/server-rendering) and [Client Hydration](/guides/client-hydration). Read those first.

---

## What's Different?

Basic SSR renders static content. But when you need data from an API or database, you need:

1. A way to load data into your app that works both on the client and server (`load()`)
2. A server render function that also waits for the data when run on the server (`renderToStringAsync`)
3. A way to pass that data to the client to provide **back** into your app (`hydrationData`), which completes the cycle by providing it back into the respective `load()` instance (and thus hydrating them) ðŸ”„

Rimitive provides a module called `load()` for this. You wrap the parts of your UI that need async data, Rimitive handles fetching on the server, serializes the results, and hydrates the client without refetching.

```
SERVER
  â”‚
  â”œâ”€ App runs, hits load() calls
  â”œâ”€ Fetches data, waits for all
  â”œâ”€ Renders HTML with fetched data
  â”œâ”€ Packs fetched data into a <script> tag
  â”‚
  â–¼
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HTML + Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º
  â”‚
  â–¼
CLIENT
  â”‚
  â”œâ”€ Displays HTML (instant)
  â”œâ”€ Loads JS, reads packed data
  â”œâ”€ App runs, load() finds respective cached data
  â””â”€ Hydrates without refetching or re-rendering âœ“
  â”‚
  ðŸŽ‰ UI interactive!
```

---
## 1. Service Setup

The first step is to setup the shared service. Update your shared service to include `createLoaderModule`:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export type ServiceOptions = {
  hydrationData?: Record<string, unknown>;
};

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: ServiceOptions
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    // ðŸ‘‡ Add this
    createLoaderModule({
      initialData: options?.hydrationData,
    })
  );
}

export type Service = ReturnType<typeof createService>;
```

The `initialData` option receives all the data fetched during SSR as a key/value map. When each `load()` runs on the client, it checks this map firstâ€”if it finds data for its ID, it skips it's initial fetch-and-render, and uses the cached value instead. This prevents hydration mismatches and duplicate requests.

---

### Using load()

`load()` takes three arguments:

| Argument | Purpose |
|----------|---------|
| `id` | Unique string identifier. The client uses this to find matching data from SSR. |
| `fetcher` | Async function that returns your data. Runs on server, skipped on client if data exists. |
| `render` | Function that receives loading state and returns UI. |

```typescript
const UserProfile = ({ loader, match, el }: Service) => () => {
  return loader.load(
    'user-profile',
    () => fetch('/api/user').then(r => r.json()),
    (state) =>
      match(state.status, (status) => {
        switch (status) {
          case 'pending':
            return el('div')('Loading...');
          case 'error':
            return el('div')(`Error: ${state.error()}`);
          case 'ready':
            const user = state.data()!;
            return el('div')(
              el('h1')(user.name),
              el('p')(user.email)
            );
        }
      })
  );
};
```

### The State Object

| Property | Type | Description |
|----------|------|-------------|
| `state.status` | `'pending' \| 'ready' \| 'error'` | Current loading state |
| `state.data()` | `T \| undefined` | Your data (it's a signalâ€”call it) |
| `state.error()` | `unknown \| undefined` | The error, if any |

---

## 2. Server Setup

With async, we use `renderToStringAsync` instead of calling `serialize()` directly. It waits for all `load()` calls to resolve before returning HTML.

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createParse5Adapter,
  renderToStringAsync,
  safeJsonStringify,
} from '@rimitive/ssr/server';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } = createParse5Adapter();
  const service = createService(adapter);

  // Render and wait for all load() boundaries
  const html = await renderToStringAsync(App(service), {
    svc: service,
    mount: (spec) => spec.create(service),
    serialize,
    insertFragmentMarkers,
  });

  // Collect fetched data from all the loader calls that occurred during render
  // (collected by the loader)
  const loaderData = service.loader.getData();

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`<!DOCTYPE html>
<html>
<head>
  <script>window.__RIMITIVE_DATA__ = ${safeJsonStringify(loaderData)}</script>
</head>
<body>
  <div class="app">${html}</div>
  <script src="/client.js"></script>
</body>
</html>`);
});

server.listen(3000);
```

### What's new:

1. **`renderToStringAsync`** â€” Waits for all `load()` fetchers to complete
2. **`insertFragmentMarkers`** â€” Adds markers around `load()` boundaries for hydration
3. **`service.loader.getData()`** â€” Returns a map of all fetched data (ID â†’ data)
4. **`safeJsonStringify`** â€” Safely embeds JSON in HTML (prevents XSS from `</script>` in data)

---

## 3. Client Setup

Pass the embedded data (`window.__RIMITIVE_DATA__`, or whatever you decide to call it) to your service as `hydrationData`:

```typescript
// client.ts
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import {
  createDOMHydrationAdapter,
  createHydrationAdapter,
} from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

const hydrationAdapter = createHydrationAdapter(
  createDOMHydrationAdapter(document.querySelector('.app')!),
  createDOMAdapter()
);

// ðŸ‘‡ Pass the SSR data to the service
const ssrData = window.__RIMITIVE_DATA__;
//             Remember from step 1? Here's where we pass the data ðŸ‘‡
const service = createService(hydrationAdapter, { hydrationData: ssrData });

App(service).create(service);
hydrationAdapter.switchToFallback();
```

When `load('user-profile', ...)` runs during hydration, it finds the corresponding `'user-profile'` id in `hydrationData` and uses that data immediatelyâ€”no fetch, no loading state, no mismatch.

---

## Error Handling

### Errors in load() Boundaries

If a fetcher throws, `load()` catches it and renders the respective error state:

```typescript
loader.load(
  'might-fail',
  async () => {
    const res = await fetch('/api/flaky');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  },
  (state) =>
    match(state.status, (status) => {
      switch (status) {
        case 'pending':
          return el('div')('Loading...');
        case 'error':
          return el('div').class('error')(`Failed: ${state.error()}`);
        case 'ready':
          return DataView(state.data()!);
      }
    })
);
```

The error is serialized tooâ€”the client receives the error UI already rendered.

### Server-Level Errors

For errors outside `load()` boundaries, wrap `renderToStringAsync`:

```typescript
try {
  const html = await renderToStringAsync(App(service), options);
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(html);
} catch (err) {
  console.error('SSR failed:', err);
  res.writeHead(500);
  res.end('Internal Server Error');
}
```

---

## Next Steps

With `renderToStringAsync`, the server waits for _all_ data before responding. That's great for pages where you want to render everything up-front for good SEO and fast load times. For pages with slow or independent data sources, you might want to send HTML progressively:

- **[Streaming SSR](/guides/streaming-ssr)** â€” Send the shell immediately, stream data as it loads

---

## Streaming SSR

This guide builds on [SSR with Data Loading](/guides/ssr-loading). Make sure you understand `load()` and basic SSR setup first.

---

## Why Streaming?

With `renderToStringAsync`, the server waits for **all** data before sending anything. That's fine when data loads quickly, but if one API takes 3 seconds, users stare at a blank screen for 3 seconds.

**Streaming SSR** sends the page shell immediately, then streams data chunks as each `load()` boundary resolves. Users see content faster, especially when some data sources are slow.

```
SERVER
  â”‚
  â”œâ”€ App runs, creates load() boundaries with pending states
  â”œâ”€ Sends initial HTML immediately (loading UI visible)
  â”‚
  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ HTML Shell â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Users see loading UI
  â”‚
  â”œâ”€ load() #1 resolves â†’ stream chunk
  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ <script>data1</script> â”€â”€â–º  UI updates
  â”‚
  â”œâ”€ load() #2 resolves â†’ stream chunk
  â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ <script>data2</script> â”€â”€â–º  UI updates
  â”‚
  â””â”€ All done, close response
```

Signals update the UI. The server streams data, the client pushes it to signals, and Rimitive handles the rest.

---

## The Stream Writer

Streaming needs a way to send data from server to client as it becomes available. `createStreamWriter` generates the JavaScript for this:

```typescript
import { createStreamWriter } from '@rimitive/ssr/server';

const stream = createStreamWriter('__APP_STREAM__');

// Bootstrap code goes in <head> - sets up the receiver
stream.bootstrapCode();
// â†’ "window.__APP_STREAM__=(function(){...})();"

// Chunk code is sent as data resolves - pushes to the receiver
stream.chunkCode('stats', { users: 100 });
// â†’ "__APP_STREAM__.push(\"stats\",{\"users\":100});"
```

The receiver queues data until the client calls `connectStream()`, then forwards chunks to the loader.

---

## Server Setup

Use `renderToStream` instead of `renderToStringAsync`:

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createParse5Adapter,
  renderToStream,
  createStreamWriter,
} from '@rimitive/ssr/server';
import type { RefSpec } from '@rimitive/view/types';
import { createService } from './service.js';
import { App } from './App.js';

const STREAM_KEY = '__APP_STREAM__';
const stream = createStreamWriter(STREAM_KEY);

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } = createParse5Adapter();

  // Create service with streaming callback
  const service = createService(adapter, {
    onResolve: (id, data) => {
      // Stream each data chunk as it resolves
      res.write(`<script>${stream.chunkCode(id, data)}</script>`);
    },
  });

  // Render with pending states
  const { initialHtml, done, pendingCount } = renderToStream(
    App(service),
    {
      mount: (spec: RefSpec<unknown>) => spec.create(service),
      serialize,
      insertFragmentMarkers,
    }
  );

  // Start response immediately
  res.writeHead(200, { 'Content-Type': 'text/html' });

  // Write document head with bootstrap script
  res.write(`<!DOCTYPE html>
<html>
<head>
  <script>${stream.bootstrapCode()}</script>
</head>
<body>`);

  // Write initial HTML (with loading states)
  res.write(`<div class="app">${initialHtml}</div>`);

  // Write client script
  res.write('<script src="/client.js"></script>');

  // Wait for all data to stream
  await done;

  // Close document
  res.write('</body></html>');
  res.end();
});

server.listen(3000);
```

### What's different from async SSR:

| Async SSR | Streaming SSR |
|-----------|---------------|
| `renderToStringAsync` waits for all data | `renderToStream` returns immediately |
| One HTML response at the end | HTML shell + data chunks over time |
| No `onResolve` needed | `onResolve` streams each chunk |
| Simpler setup | More responsive UX |

---

## Service with Streaming

Add `onResolve` to your service options and pass it through to `createLoaderModule`:

```typescript
// service.ts - add to your existing ServiceOptions
export type ServiceOptions = {
  hydrationData?: Record<string, unknown>;
  onResolve?: (id: string, data: unknown) => void;  // ðŸ‘ˆ Add this
};

// Pass it through to the loader
createLoaderModule({
  initialData: options?.hydrationData,
  onResolve: options?.onResolve,  // ðŸ‘ˆ Add this
})
```

See the [SSR with Data Loading](/guides/ssr-loading) service setup for the full example.

---

## Client Setup

The client hydrates, then connects to the stream to receive data chunks:

```typescript
// client.ts
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import {
  createDOMHydrationAdapter,
  createHydrationAdapter,
  connectStream,
} from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

const STREAM_KEY = '__APP_STREAM__';

// Create hydration adapter (same as basic SSR)
const hydrationAdapter = createHydrationAdapter(
  createDOMHydrationAdapter(document.querySelector('.app')!),
  createDOMAdapter()
);

// Create service (no hydrationData - data comes via stream instead)
const service = createService(hydrationAdapter);

// Hydrate the app
App(service).create(service);

// Switch to normal DOM mode
hydrationAdapter.switchToFallback();

// Connect to the stream to receive data chunks
connectStream(service, STREAM_KEY);
```

### What happens:

1. Hydration adapter walks existing DOM, attaches reactivity
2. `switchToFallback()` switches to normal DOM mode for future updates
3. `connectStream()` flushes any queued chunks and wires up the loader to receive future chunks
4. As chunks arrive, signals update and the UI re-renders automatically

---

## Using load() with Streaming

Components use `load()` exactly the same as [basic async SSR](/guides/ssr-loading#using-load). The difference is what happens on the server:

| Basic Async SSR | Streaming SSR |
|-----------------|---------------|
| Server waits for `fetchStats` | Server sends `pending` HTML immediately |
| Full HTML sent after 2s | Skeleton UI visible instantly |
| â€” | Data chunk streams when ready |
| â€” | Signal updates, UI re-renders |

Your component code doesn't changeâ€”only the server orchestration differs.

---

## Error Handling

Errors in `load()` boundaries work the same as [basic async SSR](/guides/ssr-loading#error-handling). With streaming:

1. If a fetch fails, `onResolve` isn't called for that boundary
2. The `done` promise still resolves (one error doesn't break other boundaries)
3. The error state renders on the client via `state.error()`

For server-level errors, wrap the response:

```typescript
const server = createServer(async (req, res) => {
  try {
    // ... streaming setup
    await done;
    res.write('</body></html>');
    res.end();
  } catch (err) {
    console.error('Streaming error:', err);
    if (!res.headersSent) {
      res.writeHead(500);
      res.end('Server Error');
    } else {
      res.end(); // Headers sent, close gracefully
    }
  }
});
```

---

## Complete Example

A working streaming example with multiple `load()` boundaries that resolve at different times:

```typescript
// App.ts - Multiple load() boundaries with different speeds
export const App = (svc: Service) => () => {
  const { loader, match, el } = svc;

  return el('div')(
    // Fast - 100ms
    loader.load('user', fetchUser, (state) =>
      match(state.status, (s) => {
        if (s === 'pending') return el('div')('Loading user...');
        if (s === 'error') return el('div')('Error');
        return el('div')(`Welcome, ${state.data()!.name}!`);
      })
    ),

    // Slow - 3s
    loader.load('news', fetchNews, (state) =>
      match(state.status, (s) => {
        if (s === 'pending') return el('div')('Loading news...');
        if (s === 'error') return el('div')('Error');
        return el('ul')(...state.data()!.headlines.map(h => el('li')(h)));
      })
    )
  );
};
```

With streaming:
1. User sees "Loading user..." and "Loading news..." immediately
2. After 100ms, user greeting appears (first chunk streamed)
3. After 3s, news list appears (second chunk streamed)

---

## When to Use Streaming

| Use Streaming When | Use Basic Async SSR When |
|--------------------|--------------------------|
| Some data sources are slow (> 500ms) | All data loads quickly |
| Users should see content ASAP | SEO crawlers need complete HTML |
| Page has independent data regions | Simplicity matters more than speed |

---

## Using a Service

Once you've [created a service](/guides/creating-a-service), there are a few ways to use it.

---

## Exporting a Service

You can safely destructure anything in Rimitive from a service, so for simpler use cases, you can export the return of a service:

```typescript
// myService.ts

export const { signal, computed } = compose(SignalModule, ComputedModule);
```

But `svc` is also call-able. So it's more idiomatic to export the service and service type if you're looking for a more durable pattern:

```typescript
// myService.ts

export const svc = compose(SignalModule, ComputedModule);
export type Service = typeof svc;
```

For now though, we'll continue exporting the destructured parts for simplicity.

---

## In a Function

Rimitive makes heavy usage of factory functions that look like components or hooks you might be used to from other frameworks:

```typescript
import { signal } from './myService.ts'

const useCounter = () => {
  const count = signal(0);
  const increment = () => count(count() + 1);

  return { count, increment };
};

const counter = useCounter();
counter.increment();
counter.count(); // 1
```

A nuance here is that the above is **a plain function** that instantiates reactive state and returns an api to drive it ðŸš—. In Rimitive, this pattern is called a ["behavior"](/guides/creating-a-behavior), which is conventionally prefixed with `use*` for clarity (ie `useCounter` instead of `myCounter` or something).

You can stop right here, if that's all you need! For plenty of apps simple apps, direct service exports and simple behaviors might be enough.

If you want to drive a reactive ui with state, Rimitive also has modules and patterns to help you with that.

Next up though, let's talk more about the [behavior pattern](/guides/creating-a-behavior).

---

## batch()

The `batch()` function groups multiple signal updates so that dependents only run once, after all updates complete.

## Syntax

```typescript
const result = batch(fn)
```

### Parameters

**`fn`**
: A function that performs multiple signal writes.

### Return value

Whatever `fn` returns.

## Description

Normally, each signal write immediately notifies dependents. When updating multiple signals, this can cause redundant recalculations:

```typescript
const a = signal(1);
const b = signal(2);
const sum = computed(() => a() + b());

effect(() => console.log('Sum:', sum()));
// logs: "Sum: 3"

a(10);  // logs: "Sum: 12"
b(20);  // logs: "Sum: 30"
// Effect ran twice!
```

With `batch()`, updates are deferred until the batch completes:

```typescript
batch(() => {
  a(10);
  b(20);
});
// logs: "Sum: 30" (once)
```

### Nested batches

Batches can nest. Updates only flush when the outermost batch completes:

```typescript
batch(() => {
  a(10);
  batch(() => {
    b(20);
    c(30);
  });
  d(40);
});
// All effects run once, after all updates
```

### Return values

`batch()` returns whatever your function returns:

```typescript
const total = batch(() => {
  count(count() + 1);
  return count();
});
```

## Examples

### Form reset

```typescript
const name = signal('');
const email = signal('');
const phone = signal('');

const reset = () => {
  batch(() => {
    name('');
    email('');
    phone('');
  });
};
```

### Bulk data update

```typescript
const items = signal<Item[]>([]);
const selectedId = signal<string | null>(null);
const filter = signal('all');

const loadData = async () => {
  const data = await fetchItems();

  batch(() => {
    items(data.items);
    selectedId(data.defaultSelected);
    filter('all');
  });
};
```

### State machine transition

```typescript
const status = signal<'idle' | 'loading' | 'error' | 'success'>('idle');
const data = signal<Data | null>(null);
const error = signal<Error | null>(null);

const setSuccess = (result: Data) => {
  batch(() => {
    status('success');
    data(result);
    error(null);
  });
};

const setError = (err: Error) => {
  batch(() => {
    status('error');
    data(null);
    error(err);
  });
};
```

## See also

- [signal()](/signals/signal) â€” Create reactive state
- [effect()](/signals/effect) â€” Flush strategies like `mt()` also batch updates

---

## Signal Benchmarks

Performance is a core focus of Rimitive. We regularly benchmark against other popular reactive libraries to ensure competitive performance.

## Framework Comparison

These benchmarks measure core signal operations like reading, writing, and propagating changes through dependency graphs.

## Methodology

- Benchmarks run using [mitata](https://github.com/evanwashere/mitata) with garbage collection enabled
- Each benchmark runs multiple iterations to ensure statistical significance
- Results show median time per operation (lower is better)
- Ratios compare against Rimitive (1.00x = same speed)

---

## computed()

The `computed()` function creates a derived value that updates automatically when its dependencies change. Computeds are lazy â€” they only recalculate when read.

## Syntax

```typescript
const derived = computed(fn)
```

### Parameters

**`fn`**
: A function that computes the derived value. Any signals read inside this function become dependencies.

### Return value

A `Readable<T>` â€” a read-only reactive value:

- **`derived()`** â€” Returns the current computed value, tracking this read as a dependency
- **`derived.peek()`** â€” Returns the current value without tracking

## Description

Computeds derive values from other reactive state. When you read signals inside a computed, those reads are tracked. When any dependency changes, the computed is marked stale and will recalculate on the next read.

```typescript
const firstName = signal('Ada');
const lastName = signal('Lovelace');

const fullName = computed(() => `${firstName()} ${lastName()}`);

fullName();  // "Ada Lovelace"

firstName('Grace');
fullName();  // "Grace Lovelace"
```

### Lazy evaluation

Computeds don't recalculate immediately when dependencies change. They wait until someone reads them:

```typescript
const count = signal(0);
const doubled = computed(() => {
  console.log('calculating...');
  return count() * 2;
});

count(1);  // Nothing logged yet
count(2);  // Still nothing
doubled(); // logs "calculating...", returns 4
doubled(); // No log â€” cached
```

This makes computeds efficient even in complex dependency graphs.

### Caching

Once computed, the value is cached until a dependency changes:

```typescript
const items = signal([1, 2, 3, 4, 5]);
const sum = computed(() => items().reduce((a, b) => a + b, 0));

sum();  // Calculates: 15
sum();  // Cached: 15
sum();  // Cached: 15

items([1, 2, 3]);
sum();  // Recalculates: 6
```

### Composing computeds

Computeds can depend on other computeds:

```typescript
const items = signal([1, 2, 3]);
const count = computed(() => items().length);
const sum = computed(() => items().reduce((a, b) => a + b, 0));
const average = computed(() => count() > 0 ? sum() / count() : 0);

average();  // 2
items([10, 20]);
average();  // 15
```

The dependency graph is tracked automatically â€” no manual wiring needed.

## Examples

### Filtered list

```typescript
const todos = signal([
  { id: 1, text: 'Learn', done: true },
  { id: 2, text: 'Build', done: false },
]);

const active = computed(() => todos().filter(t => !t.done));
const completed = computed(() => todos().filter(t => t.done));
const counts = computed(() => ({
  active: active().length,
  completed: completed().length,
  total: todos().length,
}));
```

### Expensive calculations

```typescript
const data = signal(largeDataset);

const processed = computed(() => {
  // Only runs when data changes
  return data()
    .filter(expensiveFilter)
    .map(expensiveTransform)
    .sort(expensiveSort);
});
```

### Conditional dependencies

```typescript
const showDetails = signal(false);
const user = signal({ name: 'Alice', bio: 'Long bio...' });

const display = computed(() => {
  if (showDetails()) {
    // Only depends on user when showDetails is true
    return `${user().name}: ${user().bio}`;
  }
  return user().name;
});
```

## Anti-patterns

### Don't mutate state in computeds

Computeds should be pure â€” no side effects:

```typescript
// BAD â€” side effect in computed
const doubled = computed(() => {
  console.log('computing');  // side effect
  otherSignal(count() * 2);  // mutation!
  return count() * 2;
});

// GOOD â€” pure computation
const doubled = computed(() => count() * 2);
```

### Don't create circular dependencies

```typescript
// BAD â€” infinite loop
const a = computed(() => b() + 1);
const b = computed(() => a() + 1);
```

### Don't return elements from computeds

Computeds return values, not DOM elements. Use `match()` for conditional rendering:

```typescript
// BAD â€” computed can't return elements
const content = computed(() =>
  show() ? el('div')('Yes') : el('div')('No')
);

// GOOD â€” use match for conditional elements
match(show, (s) => s ? el('div')('Yes') : el('div')('No'))
```

## See also

- [signal()](/signals/signal) â€” Create reactive state
- [effect()](/signals/effect) â€” Run side effects when values change

---

## effect()

The `effect()` function runs code when its dependencies change. Unlike `computed()`, effects are for side effects â€” DOM updates, logging, API calls, etc.

## Syntax

```typescript
const dispose = effect(fn)
const dispose = effect(flushStrategy)
```

### Parameters

**`fn`**
: A function to run. Any signals read inside become dependencies. Can optionally return a cleanup function.

**`flushStrategy`**
: A flush strategy wrapper like `mt(fn)`, `raf(fn)`, or `debounce(ms, fn)`. See [Flush Strategies](#flush-strategies).

### Return value

A `dispose` function that stops the effect and runs any cleanup.

## Description

Effects run immediately when created, then re-run whenever their dependencies change. They're **synchronous** by default â€” when a signal changes, the effect runs before the next line of code.

```typescript
const count = signal(0);

effect(() => {
  console.log('Count is:', count());
});
// logs: "Count is: 0"

count(1);
// logs: "Count is: 1"

count(2);
// logs: "Count is: 2"
```

### Cleanup

Return a function from your effect to clean up before the next run:

```typescript
const userId = signal(1);

effect(() => {
  const id = userId();
  const controller = new AbortController();

  fetch(`/api/user/${id}`, { signal: controller.signal })
    .then(r => r.json())
    .then(user => console.log(user));

  return () => controller.abort();
});
```

Cleanup runs:
- Before each re-run (when dependencies change)
- When the effect is disposed

### Disposal

Call the returned function to stop the effect:

```typescript
const dispose = effect(() => {
  console.log('Count:', count());
});

count(1);  // logs
count(2);  // logs

dispose();

count(3);  // nothing â€” effect stopped
```

Disposal also runs any cleanup function one final time.

## Flush Strategies

By default, effects run synchronously. Use flush strategies to control timing:

```typescript
import { mt, raf, debounce } from '@rimitive/signals/extend';
```

### mt (microtask)

Defers to the next microtask. Multiple synchronous updates trigger one effect run:

```typescript
const a = signal(1);
const b = signal(2);

effect(mt(() => {
  console.log('Sum:', a() + b());
}));
// logs: "Sum: 3"

a(10);
b(20);
// logs: "Sum: 30" (once, not twice)
```

### raf (requestAnimationFrame)

Defers to the next animation frame. Ideal for DOM work:

```typescript
effect(raf(() => {
  canvas.width = width();
  canvas.height = height();
  ctx.fillRect(0, 0, width(), height());
}));
```

### debounce(ms, fn)

Waits until dependencies stop changing for the specified duration:

```typescript
const query = signal('');

effect(debounce(300, () => {
  performSearch(query());
}));
```

### When to use each

| Strategy | Use case |
|----------|----------|
| (none) | Immediate response, single dependency, predictable sync behavior |
| `mt(fn)` | Multiple signals updating together, coalesce into one run |
| `raf(fn)` | DOM work, canvas, animations |
| `debounce(ms, fn)` | User input, search, expensive operations |

## Examples

### Sync to localStorage

```typescript
const theme = signal('dark');

effect(() => {
  localStorage.setItem('theme', theme());
});
```

### WebSocket connection

```typescript
const roomId = signal('general');

effect(() => {
  const id = roomId();
  const ws = new WebSocket(`wss://chat.example.com/${id}`);

  ws.onmessage = (e) => {
    messages([...messages(), JSON.parse(e.data)]);
  };

  return () => ws.close();
});
```

### Animation loop

```typescript
const x = signal(0);
const y = signal(0);

effect(raf(() => {
  element.style.transform = `translate(${x()}px, ${y()}px)`;
}));
```

### With element lifecycle

Return an effect from `.ref()` to tie it to an element's lifetime:

```typescript
el('canvas')
  .ref((canvas) =>
    effect(() => {
      const ctx = canvas.getContext('2d');
      drawScene(ctx, sceneData());
    })
  )()
```

The effect disposes automatically when the element is removed.

## Anti-patterns

### Don't mutate signals you read

```typescript
// BAD â€” infinite loop
effect(() => {
  count(count() + 1);
});
```

### Don't use for derived state

```typescript
// BAD â€” use computed instead
const total = signal(0);
effect(() => {
  total(items().reduce((a, b) => a + b, 0));
});

// GOOD
const total = computed(() => items().reduce((a, b) => a + b, 0));
```

### Don't forget cleanup

```typescript
// BAD â€” leaks connections
effect(() => {
  const ws = new WebSocket(url());
  ws.onmessage = handleMessage;
});

// GOOD
effect(() => {
  const ws = new WebSocket(url());
  ws.onmessage = handleMessage;
  return () => ws.close();
});
```

## See also

- [signal()](/signals/signal) â€” Create reactive state
- [computed()](/signals/computed) â€” Derive values (prefer over effect for derived state)
- [batch()](/signals/batch) â€” Batch multiple updates

---

## signal()

The `signal()` function creates reactive state. Read with `sig()`, write with `sig(value)`.

## Syntax

```typescript
const sig = signal(initialValue)
```

### Parameters

**`initialValue`**
: The initial value of the signal. Can be any type.

### Return value

A `SignalFunction<T>` â€” a callable function with the following behavior:

- **`sig()`** â€” Returns the current value and tracks this read as a dependency
- **`sig(newValue)`** â€” Sets a new value and notifies all dependents
- **`sig.peek()`** â€” Returns the current value without tracking

## Description

Signals are the foundation of Rimitive's reactivity. When you read a signal inside a `computed()` or `effect()`, that read is tracked. When the signal's value changes, all dependents are notified and re-run.

```typescript
const count = signal(0);

// Reading
count();        // 0 (tracked if inside computed/effect)
count.peek();   // 0 (never tracked)

// Writing
count(5);             // sets to 5
count(count() + 1);   // read then write
```

### Reactive tracking

Reads are only tracked inside reactive contexts â€” `computed()` and `effect()`. Reading a signal in plain JavaScript doesn't create any subscription:

```typescript
const name = signal('Alice');

// Not reactive â€” this string is computed once, never updates
const greeting = `Hello, ${name()}!`;

// Reactive â€” recomputes when name changes
const greeting = computed(() => `Hello, ${name()}!`);
```

### Untracked reads with peek()

Use `peek()` when you need the current value without creating a dependency:

```typescript
effect(() => {
  // This effect only re-runs when `trigger` changes,
  // not when `count` changes
  if (trigger()) {
    console.log('Count is:', count.peek());
  }
});
```

Common use cases for `peek()`:
- Event handlers where you need the current value but don't want reactivity
- Breaking circular dependencies
- Performance optimization when you know a re-run isn't needed

## Examples

### Counter

```typescript
const count = signal(0);
const doubled = computed(() => count() * 2);

count();        // 0
doubled();      // 0

count(5);
count();        // 5
doubled();      // 10

count(count() + 1);
count();        // 6
doubled();      // 12
```

### Form state

```typescript
const form = signal({
  name: '',
  email: '',
  valid: false,
});

// Update one field
form({ ...form(), name: 'Alice' });

// Derived validation
const isValid = computed(() => {
  const { name, email } = form();
  return name.length > 0 && email.includes('@');
});
```

### Toggle pattern

```typescript
const isOpen = signal(false);

// Toggle
isOpen(!isOpen());

// Or create a helper
const toggle = () => isOpen(!isOpen());
```

## See also

- [computed()](/signals/computed) â€” Derive values from signals
- [effect()](/signals/effect) â€” Run side effects when signals change
- [Signal Patterns](/patterns/signal-patterns) â€” Common patterns for working with signals

---

## subscribe()

The `subscribe()` function calls a callback when source dependencies change. Unlike `effect()`, it separates the tracked source from the untracked callback.

## Syntax

```typescript
const unsubscribe = subscribe(source, callback)
```

### Parameters

**`source`**
: A function that reads signals. These reads are tracked as dependencies.

**`callback`**
: A function called with the source's return value. Signal reads here are **not** tracked.

### Return value

An `unsubscribe` function that stops the subscription.

## Description

`subscribe()` provides fine-grained control over what triggers re-runs. The source function determines dependencies; the callback can read any signals without creating subscriptions:

```typescript
const count = signal(0);
const multiplier = signal(2);

subscribe(
  () => count(),                    // tracked
  (value) => console.log(value * multiplier())  // NOT tracked
);

count(5);       // logs: 10
multiplier(3);  // no log â€” multiplier isn't a dependency
count(6);       // logs: 18
```

### vs effect()

With `effect()`, all signal reads create dependencies:

```typescript
// Effect: re-runs when a OR b changes
effect(() => {
  console.log(a() + b());
});

// Subscribe: re-runs only when a changes
subscribe(
  () => a(),
  (val) => console.log(val + b())
);
```

### Initial call

Like effects, `subscribe()` calls the callback immediately with the initial value:

```typescript
const count = signal(0);

subscribe(
  () => count(),
  (value) => console.log('Count:', value)
);
// logs: "Count: 0"

count(1);
// logs: "Count: 1"
```

### Unsubscribing

Call the returned function to stop the subscription:

```typescript
const unsubscribe = subscribe(
  () => count(),
  (value) => console.log(value)
);

count(1);  // logs: 1
unsubscribe();
count(2);  // nothing
```

## Examples

### External system sync

Sync to an external system only when specific signals change:

```typescript
const userId = signal('user-1');
const settings = signal({ theme: 'dark' });

// Only re-sync when userId changes, not settings
subscribe(
  () => userId(),
  (id) => {
    externalSystem.setUser(id);
    externalSystem.applySettings(settings());  // read but not tracked
  }
);
```

### Debounced search with stable config

```typescript
const query = signal('');
const config = signal({ limit: 10 });

subscribe(
  () => query(),
  (q) => {
    // config changes don't trigger new searches
    fetch(`/search?q=${q}&limit=${config().limit}`);
  }
);
```

### Computed source

The source can be any reactive expression:

```typescript
const items = signal([1, 2, 3]);
const filter = signal('all');

subscribe(
  () => {
    // Both items and filter are dependencies
    const all = items();
    return filter() === 'all' ? all : all.filter(x => x > 2);
  },
  (filtered) => {
    renderList(filtered);
  }
);
```

## See also

- [effect()](/signals/effect) â€” Simpler API when you want all reads tracked
- [computed()](/signals/computed) â€” For derived values, not side effects

---

## untrack()

The `untrack()` function executes code without tracking signal reads as dependencies.

## Syntax

```typescript
const result = untrack(fn)
```

### Parameters

**`fn`**
: A function to execute. Signal reads inside this function won't be tracked.

### Return value

Whatever `fn` returns.

## Description

Normally, reading a signal inside `computed()` or `effect()` creates a dependency. With `untrack()`, you can read signals without subscribing to their changes:

```typescript
const a = signal(1);
const b = signal(2);

const sum = computed(() => {
  // Depends on `a`, but NOT on `b`
  return a() + untrack(() => b());
});

sum();  // 3

a(10);
sum();  // 12 (recomputed because `a` changed)

b(20);
sum();  // 12 (not recomputed â€” `b` isn't a dependency)
```

### vs peek()

Both `untrack()` and `peek()` avoid tracking, but they serve different purposes:

- **`sig.peek()`** â€” Read a single signal without tracking
- **`untrack(fn)`** â€” Execute a block of code without tracking any reads

```typescript
// These are equivalent for a single signal
const x = untrack(() => count());
const x = count.peek();

// untrack is better for multiple reads
const { a, b, c } = untrack(() => ({
  a: sigA(),
  b: sigB(),
  c: sigC(),
}));
```

## Examples

### Conditional dependency

Only depend on some signals based on a condition:

```typescript
const useCache = signal(true);
const cache = signal({});
const fetchData = signal(() => { ... });

const data = computed(() => {
  if (useCache()) {
    // Only track cache when useCache is true
    return cache();
  }
  // Don't track fetchData â€” just call it
  return untrack(() => fetchData()());
});
```

### Logging without dependency

Log values without creating dependencies:

```typescript
effect(() => {
  const value = importantSignal();

  // Log other context without depending on it
  untrack(() => {
    console.log('Context:', otherSignal(), anotherSignal());
  });

  doSomethingWith(value);
});
```

### Breaking circular patterns

Avoid infinite loops when an effect needs to read and write the same signal:

```typescript
effect(() => {
  const trigger = someTrigger();

  // Read count without creating a dependency
  const current = untrack(() => count());

  if (trigger && current < 10) {
    count(current + 1);
  }
});
```

## See also

- [signal()](/signals/signal) â€” `peek()` for single-signal untracked reads
- [effect()](/signals/effect) â€” Where tracking matters most
- [computed()](/signals/computed) â€” Derived values with automatic tracking

---

## View Benchmarks

These benchmarks measure the propagation overhead of each view primitive compared to pure signals. The view layer is designed to add minimal overhead on top of the reactive core.

---

## el()

The `el()` function creates element specs â€” blueprints for DOM elements with reactive props and children.

## Syntax

```typescript
el(tag)
el(tag).props(props)
el(tag).props(props).ref(...callbacks)
el(tag)(children)
el(tag).props(props)(children)
```

### Parameters

**`tag`**
: The element tag name. For the DOM adapter, this is any valid HTML tag (`'div'`, `'button'`, `'input'`, etc.).

**`props`** (optional)
: An object of attributes, properties, and event handlers. Values can be static or reactive.

**`callbacks`** (optional)
: Lifecycle callbacks passed to `.ref()`. Called with the element when created, return a cleanup function for disposal.

**`children`** (optional)
: Child content â€” strings, numbers, reactive values, or other element specs.

### Return value

An `ElementSpec` â€” an inert blueprint that becomes a real element when mounted or created.

## Description

`el()` is curried and chainable:

```typescript
// Just a tag
el('div')

// With props
el('div').props({ className: 'container' })

// With children
el('div')('Hello')

// Full chain
el('button')
  .props({ onclick: handleClick })
  .ref(callback)
  ('Click me')
```

### Elements never re-render

Unlike virtual DOM frameworks, `el()` creates a stable element once. The element itself doesn't re-render â€” only individual props and text nodes update when their reactive values change:

```typescript
const count = signal(0);

// This element is created once
// Only the text "Count: X" updates when count changes
const display = el('div')(
  computed(() => `Count: ${count()}`)
);
```

### Reactive props

Props can be static values or reactive (signals/computeds):

```typescript
const isDisabled = signal(false);
const label = computed(() => isDisabled() ? 'Disabled' : 'Click me');

el('button').props({
  className: 'btn',           // static
  disabled: isDisabled,       // reactive
  onclick: () => doSomething() // event handler
})(label)                      // reactive child
```

### Children

The final call accepts any number of children:

```typescript
el('div')(
  'Text content',
  el('span')('Nested element'),
  computed(() => `Dynamic: ${value()}`),
  someCondition && el('p')('Conditional')
)
```

Children can be:
- Strings and numbers (rendered as text)
- Reactive values (signals, computeds)
- Other element specs
- `null` or `undefined` (ignored)
- Arrays of any of the above

## Examples

### Basic elements

```typescript
// Empty div
el('div')()

// Div with text
el('div')('Hello, world')

// Nested structure
el('article')(
  el('h1')('Title'),
  el('p')('First paragraph'),
  el('p')('Second paragraph')
)
```

### With props

```typescript
el('input').props({
  type: 'text',
  placeholder: 'Enter name...',
  value: name,
  oninput: (e) => name(e.target.value)
})()

el('a').props({
  href: 'https://example.com',
  target: '_blank'
})('Visit site')
```

### Reactive updates

```typescript
const theme = signal<'light' | 'dark'>('light');
const count = signal(0);

el('div').props({
  className: computed(() => `app theme-${theme()}`),
})(
  el('p')(computed(() => `Count: ${count()}`)),
  el('button').props({
    onclick: () => count(count() + 1)
  })('Increment')
)
```

### With ref callbacks

```typescript
el('input')
  .props({ type: 'text' })
  .ref(
    (input) => input.focus(),
    (input) => {
      // Setup
      const handler = () => console.log('focused');
      input.addEventListener('focus', handler);
      // Cleanup
      return () => input.removeEventListener('focus', handler);
    }
  )()
```

### Partial application

Pre-bind commonly used tags:

```typescript
const div = el('div');
const button = el('button');
const input = el('input');

// Use without repeating tag names
div.props({ className: 'container' })(
  input.props({ type: 'text' })(),
  button.props({ type: 'submit' })('Submit')
)
```

## See also

- [map()](/view/map) â€” Render lists of elements
- [match()](/view/match) â€” Conditional element rendering
- [mount()](/view/mount) â€” Attach element specs to the DOM
- [Adding a UI](/guides/adding-a-ui) â€” Tutorial on building UIs

---

## map()

The `map()` function renders a reactive array as a list of elements. When items change, it efficiently updates only what's necessary.

## Syntax

```typescript
// Primitives (auto-keyed by value)
map(items, render)

// Objects (explicit key function)
map(items, keyFn, render)
```

### Parameters

**`items`**
: A reactive array (signal or computed).

**`keyFn`** (required for objects)
: A function that returns a unique identifier for each item. Receives the plain item value.

**`render`**
: A function that returns an element spec for each item. Receives a **reactive signal** wrapping the item.

### Return value

A reactive list spec that reconciles efficiently when the source array changes.

## Description

`map()` efficiently reconciles DOM elements when items are added, removed, or reordered. Unlike virtual DOM diffing, it tracks items by key and updates only what's necessary.

### Primitive arrays

For arrays of strings or numbers, the value itself is used as the key:

```typescript
const items = signal(['Apple', 'Banana', 'Cherry']);

el('ul')(
  map(items, (item) => el('li')(item))
)
```

### Object arrays

For objects, provide a key function to track identity:

```typescript
const todos = signal([
  { id: 1, text: 'Learn', done: false },
  { id: 2, text: 'Build', done: false },
]);

el('ul')(
  map(
    todos,
    (todo) => todo.id,       // key function
    (todo) => el('li')(      // render function
      computed(() => todo().text)
    )
  )
)
```

### Item signals

The render function receives a **signal** wrapping each item, not the plain value. This enables reactive updates when items change:

```typescript
map(todos, t => t.id, (todo) => {
  // todo is a signal, read it to get the value
  return el('li')(
    computed(() => todo().text),
    computed(() => todo().done ? 'âœ“' : '')
  );
})
```

When you update an item in the source array, the corresponding item signal updates â€” the element isn't recreated:

```typescript
// Update one todo â€” the element updates reactively
todos(arr => arr.map(t =>
  t.id === 1 ? { ...t, done: true } : t
));
```

### Reconciliation

When the source array changes, `map()`:
- **Adds** elements for new items
- **Removes** elements for deleted items
- **Reorders** elements when positions change
- **Updates** item signals when values change (same key)

This is efficient because elements are reused â€” only the minimal DOM operations are performed.

## Examples

### Simple list

```typescript
const names = signal(['Alice', 'Bob', 'Carol']);

el('ul')(
  map(names, (name) => el('li')(name))
)

// Add item
names([...names(), 'Dave']);

// Remove item
names(names().filter(x => x !== 'Bob'));
```

### Todo list

```typescript
type Todo = { id: string; text: string; done: boolean };

const todos = signal<Todo[]>([]);

const toggle = (id: string) => {
  todos(todos().map(t =>
    t.id === id ? { ...t, done: !t.done } : t
  ));
};

const remove = (id: string) => {
  todos(todos().filter(t => t.id !== id));
};

el('ul')(
  map(todos, t => t.id, (todo) =>
    el('li').props({
      style: computed(() =>
        todo().done ? 'text-decoration: line-through' : ''
      ),
    })(
      el('input').props({
        type: 'checkbox',
        checked: computed(() => todo().done),
        onchange: () => toggle(todo().id),
      })(),
      computed(() => todo().text),
      el('button').props({
        onclick: () => remove(todo().id)
      })('Ã—')
    )
  )
)
```

### Nested lists

```typescript
type Category = { id: string; name: string; items: string[] };

const categories = signal<Category[]>([...]);

el('div')(
  map(categories, c => c.id, (category) =>
    el('section')(
      el('h2')(computed(() => category().name)),
      el('ul')(
        map(
          computed(() => category().items),
          (item) => el('li')(item)
        )
      )
    )
  )
)
```

### With index

If you need the index, derive it from the array position:

```typescript
const items = signal(['A', 'B', 'C']);

el('ol')(
  map(items, (item, index) =>
    el('li')(computed(() => `${index() + 1}. ${item()}`))
  )
)
```

## See also

- [el()](/view/el) â€” Create elements
- [match()](/view/match) â€” Conditional rendering
- [Signal Patterns](/patterns/signal-patterns) â€” Computed collections pattern

---

## match()

The `match()` function swaps elements based on a reactive value. When the value changes, the old element is disposed and a new one takes its place.

## Syntax

```typescript
match(source, render)
```

### Parameters

**`source`**
: A reactive value (signal or computed) to match against.

**`render`**
: A function that receives the current value and returns an element spec, or `null` to render nothing.

### Return value

A reactive spec that renders the result of the render function, disposing and replacing elements when the source value changes.

## Description

`match()` is for conditional rendering â€” showing different elements based on state. Unlike `computed()` which derives values, `match()` renders elements:

```typescript
const show = signal(true);

match(show, (visible) =>
  visible ? el('div')('Visible!') : null
)
```

When `show` changes from `true` to `false`:
1. The `div` element is disposed (cleanup callbacks run)
2. Nothing is rendered (`null`)

When `show` changes back to `true`:
1. A new `div` element is created

### Element lifecycle

Each time the render function returns a different element, the previous one is fully disposed. This includes:
- Running any cleanup functions from `.ref()` callbacks
- Disposing any effects tied to the element
- Removing the element from the DOM

### Why not computed?

`computed()` derives values, not elements. This won't work:

```typescript
// WRONG â€” computed can't return elements
const content = computed(() =>
  show() ? el('div')('Yes') : el('div')('No')
);
```

Use `match()` for conditional elements, `computed()` for conditional values.

## Examples

### Show/hide

```typescript
const isVisible = signal(true);

el('div')(
  el('button').props({
    onclick: () => isVisible(!isVisible())
  })('Toggle'),
  match(isVisible, (visible) =>
    visible ? el('p')('Now you see me') : null
  )
)
```

### Switch views

```typescript
const isEditing = signal(false);
const text = signal('Click to edit');

el('div')(
  match(isEditing, (editing) =>
    editing
      ? el('input').props({
          value: text,
          oninput: (e) => text(e.target.value),
          onblur: () => isEditing(false),
        })()
      : el('span').props({
          onclick: () => isEditing(true)
        })(text)
  )
)
```

### Multi-way switch

```typescript
type Status = 'idle' | 'loading' | 'success' | 'error';

const status = signal<Status>('idle');

match(status, (s) => {
  switch (s) {
    case 'idle':
      return el('button').props({
        onclick: load
      })('Load data');
    case 'loading':
      return el('div')('Loading...');
    case 'success':
      return el('div')('Data loaded!');
    case 'error':
      return el('div').props({ className: 'error' })('Error!');
  }
})
```

### Tabs

```typescript
type Tab = 'home' | 'settings' | 'profile';

const currentTab = signal<Tab>('home');

el('div')(
  el('nav')(
    el('button').props({ onclick: () => currentTab('home') })('Home'),
    el('button').props({ onclick: () => currentTab('settings') })('Settings'),
    el('button').props({ onclick: () => currentTab('profile') })('Profile'),
  ),
  match(currentTab, (tab) => {
    switch (tab) {
      case 'home': return HomePanel();
      case 'settings': return SettingsPanel();
      case 'profile': return ProfilePanel();
    }
  })
)
```

### With loading states

```typescript
const user = signal<User | null>(null);
const loading = signal(false);
const error = signal<Error | null>(null);

match(
  computed(() => ({ user: user(), loading: loading(), error: error() })),
  ({ user, loading, error }) => {
    if (loading) return el('div')('Loading...');
    if (error) return el('div')(`Error: ${error.message}`);
    if (user) return UserProfile(user);
    return el('div')('No user');
  }
)
```

### Nested match

```typescript
const loggedIn = signal(false);
const role = signal<'admin' | 'user'>('user');

match(loggedIn, (isLoggedIn) =>
  isLoggedIn
    ? match(role, (r) =>
        r === 'admin'
          ? AdminDashboard()
          : UserDashboard()
      )
    : LoginForm()
)
```

## See also

- [el()](/view/el) â€” Create elements
- [map()](/view/map) â€” Render lists
- [computed()](/signals/computed) â€” Derive values (not elements)

---

## mount()

The `mount()` function creates an element from a spec and prepares it for insertion into the DOM.

## Syntax

```typescript
const ref = mount(spec)
```

### Parameters

**`spec`**
: An element spec created with `el()`, `map()`, `match()`, or other view modules.

### Return value

A `NodeRef` with:
- **`element`** â€” The created DOM element (or `null` for fragments)
- **`dispose()`** â€” Cleanup function that removes the element and runs all cleanup callbacks

## Description

Element specs are inert blueprints. `mount()` realizes them into actual DOM elements:

```typescript
const spec = el('div')('Hello');  // just a blueprint
const ref = mount(spec);           // creates real DOM element

document.body.appendChild(ref.element);
```

### Disposal

Call `dispose()` to remove the element and clean up:

```typescript
const ref = mount(App());
document.body.appendChild(ref.element);

// Later, when unmounting
ref.dispose();
```

Disposal:
- Removes the element from its parent
- Runs cleanup callbacks from `.ref()`
- Disposes effects tied to the element
- Recursively disposes all children

### App pattern

A common pattern is to mount once at startup:

```typescript
const App = () =>
  el('div').props({ id: 'app' })(
    Header(),
    Main(),
    Footer()
  );

const app = mount(App());
document.body.appendChild(app.element);
```

## Examples

### Basic mounting

```typescript
const { el, mount } = svc;

const button = mount(
  el('button').props({
    onclick: () => console.log('clicked')
  })('Click me')
);

document.getElementById('root').appendChild(button.element);
```

### Conditional mounting

```typescript
let appRef = null;

const show = () => {
  if (appRef) return;
  appRef = mount(App());
  document.body.appendChild(appRef.element);
};

const hide = () => {
  if (!appRef) return;
  appRef.dispose();
  appRef = null;
};
```

### Multiple instances

```typescript
const Widget = (name: string) =>
  el('div').props({ className: 'widget' })(name);

// Mount multiple independent instances
const widget1 = mount(Widget('First'));
const widget2 = mount(Widget('Second'));

document.getElementById('sidebar').appendChild(widget1.element);
document.getElementById('main').appendChild(widget2.element);
```

### With disposal tracking

```typescript
const refs: NodeRef[] = [];

const addItem = (text: string) => {
  const ref = mount(el('li')(text));
  refs.push(ref);
  list.appendChild(ref.element);
};

const clearAll = () => {
  refs.forEach(ref => ref.dispose());
  refs.length = 0;
};
```

## See also

- [el()](/view/el) â€” Create element specs
- [portal()](/view/portal) â€” Render to different DOM locations

---

## on()

The `on()` function creates event listeners with automatic cleanup and batched signal updates.

## Syntax

```typescript
on(eventName, handler)
on(eventName, handler, options)
```

### Parameters

**`eventName`**
: The event type (`'click'`, `'input'`, `'keydown'`, etc.).

**`handler`**
: The event handler function.

**`options`** (optional)
: Standard `addEventListener` options (`capture`, `once`, `passive`).

### Return value

A lifecycle callback for use with `.ref()`. When the element is removed, the listener is automatically cleaned up.

## Description

For simple event handlers, use props:

```typescript
el('button').props({
  onclick: () => doSomething()
})('Click')
```

`on()` provides additional benefits:
- **Automatic cleanup** when the element is removed
- **Batched updates** â€” multiple signal writes trigger one render
- **Multiple listeners** on the same element

### Usage with ref

```typescript
el('button').ref(
  on('click', () => count(count() + 1))
)('Click')
```

### Multiple listeners

Stack multiple `on()` calls:

```typescript
el('input').ref(
  on('focus', () => console.log('focused')),
  on('blur', () => console.log('blurred')),
  on('input', (e) => value(e.target.value))
)()
```

### Automatic batching

When a handler updates multiple signals, they're batched into a single render:

```typescript
el('button').ref(
  on('click', () => {
    // All three updates batched into one render
    firstName('');
    lastName('');
    loading(true);
  })
)('Reset')
```

## Examples

### Basic click

```typescript
const count = signal(0);

el('button').ref(
  on('click', () => count(count() + 1))
)('Increment')
```

### Input handling

```typescript
const text = signal('');

el('input')
  .props({
    type: 'text',
    value: text,
  })
  .ref(
    on('input', (e) => text(e.target.value))
  )()
```

### Form submission

```typescript
const query = signal('');

const handleSubmit = () => {
  console.log('Searching:', query());
};

el('input')
  .props({
    type: 'text',
    placeholder: 'Search...',
    value: query,
  })
  .ref(
    on('input', (e) => query(e.target.value)),
    on('keydown', (e) => {
      if (e.key === 'Enter') handleSubmit();
    })
  )()
```

### Event options

```typescript
// Capture phase
on('click', handler, { capture: true })

// Fire once only
on('click', handler, { once: true })

// Passive (for scroll performance)
on('scroll', handler, { passive: true })
```

### With props events

You can mix `on()` with props events:

```typescript
el('button')
  .props({
    onclick: () => console.log('props handler')
  })
  .ref(
    on('click', () => console.log('on handler'))
  )('Both fire')
```

Both handlers fire on click.

## on() vs props

| Feature | Props (`onclick`) | `on()` |
|---------|-------------------|--------|
| Simple cases | âœ“ Best choice | Works |
| Multiple listeners | One per event | âœ“ Unlimited |
| Auto cleanup | âœ“ | âœ“ |
| Batching | No | âœ“ |
| Event options | No | âœ“ |

Use props for simple handlers. Use `on()` when you need batching, multiple listeners, or event options.

## See also

- [el()](/view/el) â€” Element creation with props events
- [batch()](/signals/batch) â€” Manual batching alternative

---

## portal()

The `portal()` function renders content into a different DOM location â€” useful for modals, tooltips, and overlays that need to escape their parent's overflow or z-index context.

## Syntax

```typescript
portal()(child)
portal(target)(child)
```

### Parameters

**`target`** (optional)
: Where to render the content. Can be:
- A DOM element
- A function returning a DOM element
- A reactive value (signal) containing an element
- Omitted to use `document.body`

**`child`**
: The element spec to render at the target location.

### Return value

A spec that renders its child at the specified target, maintaining reactivity and proper cleanup.

## Description

Portals let you render content outside the normal DOM hierarchy while keeping it logically connected to its parent component:

```typescript
el('div').props({ className: 'container' })(
  el('button')('Open Modal'),
  portal()(
    el('div').props({ className: 'modal' })('Modal content')
  )
)
```

The modal is a child of the container in your code, but renders to `document.body` in the DOM.

### Lifecycle

Portal content follows normal lifecycle rules:
- Created when the portal is mounted
- Disposed when the portal is unmounted
- Cleanup callbacks from `.ref()` run on disposal

### With match

Combine with `match()` for conditional portals:

```typescript
const showModal = signal(false);

match(showModal, (show) =>
  show
    ? portal()(ModalContent())
    : null
)
```

## Examples

### Modal

```typescript
const App = () => {
  const showModal = signal(false);

  return el('div')(
    el('button').props({
      onclick: () => showModal(true)
    })('Open Modal'),

    match(showModal, (show) =>
      show
        ? portal()(
            el('div').props({ className: 'modal-backdrop' })(
              el('div').props({ className: 'modal' })(
                el('h2')('Modal Title'),
                el('p')('Content here...'),
                el('button').props({
                  onclick: () => showModal(false)
                })('Close')
              )
            )
          )
        : null
    )
  );
};
```

### Custom target

```typescript
// Render to a specific element
portal(() => document.getElementById('tooltip-container'))(
  el('div').props({ className: 'tooltip' })('Tooltip text')
)
```

### Reactive target

```typescript
const targetRef = signal<HTMLElement | null>(null);

el('div')(
  // Capture the target element
  el('div').props({ id: 'dropdown-anchor' }).ref(
    (node) => {
      targetRef(node);
      return () => targetRef(null);
    }
  )(),

  // Portal renders next to the anchor
  portal(targetRef)(
    el('ul').props({ className: 'dropdown' })(
      el('li')('Option 1'),
      el('li')('Option 2')
    )
  )
)
```

### Tooltip positioning

```typescript
const Tooltip = (anchor: HTMLElement, text: string) => {
  const position = signal({ x: 0, y: 0 });

  // Calculate position based on anchor
  const rect = anchor.getBoundingClientRect();
  position({ x: rect.left, y: rect.bottom + 8 });

  return portal()(
    el('div').props({
      className: 'tooltip',
      style: computed(() =>
        `position: fixed; left: ${position().x}px; top: ${position().y}px;`
      ),
    })(text)
  );
};
```

## See also

- [match()](/view/match) â€” Conditional rendering (often used with portals)
- [mount()](/view/mount) â€” Alternative for one-off DOM insertion

---

## Async Loading States

<!-- @tags: async, loading, suspense, pending, error-state, resource, load, ssr -->

React has Suspense. Solid has `<Suspense>` and `<Show>`. These handle async loading states declaratively.

Rimitive handles async state explicitly through two modules: `resource` for reactive data fetching with automatic refetch, and `load` for simpler async boundaries. Both use `match` for rendering. No magic, no special componentsâ€”just reactive state.

---

## The Resource Pattern

The `resource` module wraps async operations and exposes their state reactively:

```typescript
const ProductList = (svc: Service) => () => {
  const { el, resource, match } = svc;

  const products = resource((signal) =>
    fetch('/api/products', { signal }).then(r => r.json())
  );

  // products() returns { status: 'pending' | 'ready' | 'error', value?, error? }
};
```

---

## Rendering Different States

Use `match` to render based on state:

```typescript
return match(products, (state) => {
  switch (state.status) {
    case 'pending':
      return Spinner(svc);
    case 'error':
      return ErrorMessage(svc, state.error);
    case 'ready':
      return ProductGrid(svc, state.value);
  }
});
```

Or use the convenience accessors:

```typescript
return el('div')(
  match(products.loading, (loading) =>
    loading
      ? Spinner(svc)
      : match(products.error, (error) =>
          error
            ? ErrorMessage(svc, error)
            : ProductGrid(svc, products.data()!)
        )
  )
);
```

The explicit approach is more verbose but clearer about what's happening.

---

## A Show Helper

If you want something closer to Solid's `<Show>`, create a simple helper:

```typescript
const show = <T, R>(
  when: () => T | null | undefined | false,
  render: (value: T) => R,
  fallback?: () => R
): R | undefined => {
  const value = when();
  if (value) return render(value);
  return fallback?.();
};

// Usage
return el('div')(
  show(
    () => products.data(),
    (data) => ProductGrid(svc, data),
    () => Spinner(svc)
  )
);
```

But this is just a functionâ€”nothing special about it.

---

## Multiple Resources

When loading multiple resources, handle them together:

```typescript
const Dashboard = (svc: Service) => () => {
  const { el, resource, computed, match } = svc;

  const user = resource((s) => fetchUser(s));
  const stats = resource((s) => fetchStats(s));
  const notifications = resource((s) => fetchNotifications(s));

  // Combine loading states
  const allLoading = computed(() =>
    user.loading() || stats.loading() || notifications.loading()
  );

  const anyError = computed(() =>
    user.error() || stats.error() || notifications.error()
  );

  return match(allLoading, (loading) => {
    if (loading) return Spinner(svc)();

    const error = anyError();
    if (error) return ErrorMessage(svc)(error);

    return el('div')(
      UserHeader(svc)(user.data()!),
      StatsPanel(svc)(stats.data()!),
      NotificationList(svc)(notifications.data()!)
    );
  });
};
```

---

## Dependent Resources

When one resource depends on another:

```typescript
const ProductDetail = (svc: Service) => () => {
  const { el, resource, computed, match } = svc;

  const productId = svc.params.id; // from router

  const product = resource((s) =>
    fetch(`/api/products/${productId()}`, { signal: s }).then(r => r.json())
  );

  // Reviews depend on product being loaded
  const reviews = resource((s) => {
    const p = product.data();
    if (!p) return Promise.resolve([]); // No product yet, return empty

    return fetch(`/api/products/${p.id}/reviews`, { signal: s })
      .then(r => r.json());
  });

  return match(product, (state) => {
    if (state.status !== 'ready') {
      return state.status === 'pending' ? Spinner(svc)() : ErrorMessage(svc)(state.error);
    }

    return el('div')(
      ProductInfo(svc)(state.value),
      match(reviews, (reviewState) =>
        reviewState.status === 'pending'
          ? el('div')('Loading reviews...')
          : reviewState.status === 'error'
            ? el('div')('Failed to load reviews')
            : ReviewList(svc)(reviewState.value)
      )
    );
  });
};
```

---

## Refetching

Resources track dependencies and refetch automatically:

```typescript
const category = signal('electronics');

const products = resource((s) =>
  fetch(`/api/products?category=${category()}`, { signal: s })
    .then(r => r.json())
);

// Change category -> products automatically refetches
category('clothing');
```

Manual refetch is also available:

```typescript
el('button').props({
  onclick: () => products.refetch()
})('Refresh')
```

---

## The Load Pattern

For simpler async boundariesâ€”especially in SSR scenariosâ€”use `load()`:

```typescript
const ProductList = (svc: Service) => () => {
  const { el, load, match } = svc;

  return load(
    () => fetch('/api/products').then(r => r.json()),
    (state) => match(state.status, (status) => {
      switch (status) {
        case 'pending':
          return Spinner(svc)();
        case 'error':
          return ErrorMessage(svc)(state.error());
        case 'ready':
          return ProductGrid(svc)(state.data()!);
      }
    })
  );
};
```

The key difference: `load()` takes a fetcher and a renderer. The renderer receives a state object with reactive properties (`status`, `data`, `error`) that you read by calling them.

### When to use each

**Use `resource`** when you need:
- Automatic refetching when dependencies change
- AbortController integration for request cancellation
- A reactive value you can pass around and read anywhere

**Use `load`** when you need:
- Simple one-shot data fetching
- SSR streaming with explicit data boundaries
- Direct control over the loading UI in one place

```typescript
// load() is ideal for SSR - data and UI are co-located
const Page = (svc: Service) => () => {
  const { el, load, match } = svc;

  return el('main')(
    load(
      () => fetchPageData(),
      (state) => match(state.status, (status) =>
        status === 'ready'
          ? PageContent(svc)(state.data()!)
          : status === 'error'
            ? ErrorFallback(svc)()
            : LoadingSkeleton(svc)()
      )
    )
  );
};
```

---

## Cleanup

Resources should be disposed when no longer needed:

```typescript
const ProductPanel = (svc: Service) => () => {
  const { el, resource } = svc;

  const products = resource((s) => fetchProducts(s));

  // Cleanup when element is removed
  return el('div').ref(() => products.dispose)(
    // ... content
  );
};
```

---

## Anti-patterns

### Don't Ignore Loading and Error States

Only rendering the "ready" case leads to a broken UI during loading or when errors occur:

```typescript
// âŒ WRONG - crashes when data isn't ready, no error handling
const ProductList = (svc: Service) => () => {
  const { el, resource, map } = svc;

  const products = resource((s) => fetchProducts(s));

  // products.data() is undefined while loading!
  return el('div')(
    map(products.data()!, (p) => ProductCard(svc)(p))
  );
};
```

```typescript
// âœ… CORRECT - handle all states explicitly
const ProductList = (svc: Service) => () => {
  const { el, resource, match, map } = svc;

  const products = resource((s) => fetchProducts(s));

  return match(products, (state) => {
    switch (state.status) {
      case 'pending':
        return Spinner(svc)();
      case 'error':
        return ErrorMessage(svc)(state.error);
      case 'ready':
        return el('div')(
          map(state.value, (p) => ProductCard(svc)(p))
        );
    }
  });
};
```

### Don't Forget Resource Cleanup

Resources keep fetching and updating until disposed. Without cleanup, they leak memory:

```typescript
// âŒ WRONG - resource lives forever, even after component unmounts
const ProductPanel = (svc: Service) => () => {
  const products = svc.resource((s) => fetchProducts(s));

  return svc.el('div')(/* ... */);
  // Resource never disposed!
};
```

```typescript
// âœ… CORRECT - dispose when element unmounts
const ProductPanel = (svc: Service) => () => {
  const products = svc.resource((s) => fetchProducts(s));

  return svc.el('div').ref(() => products.dispose)(/* ... */);
};
```

### Don't Ignore the AbortSignal

Resources pass an AbortSignal to cancel in-flight requests. Ignoring it causes race conditions when dependencies change rapidly:

```typescript
// âŒ WRONG - ignores signal, old requests may resolve after new ones
const Search = (svc: Service) => () => {
  const query = svc.signal('');

  const results = svc.resource(() =>  // No signal parameter!
    fetch(`/api/search?q=${query()}`).then(r => r.json())
  );
};
```

```typescript
// âœ… CORRECT - pass signal to fetch for automatic cancellation
const Search = (svc: Service) => () => {
  const query = svc.signal('');

  const results = svc.resource((signal) =>
    fetch(`/api/search?q=${query()}`, { signal }).then(r => r.json())
  );
};
```

When `query` changes, the previous fetch is automatically aborted.

### Don't Use Resource for Mutations

Resources are for reactive data fetching (GET). For mutations (POST, PUT, DELETE), use the `asyncAction` pattern:

```typescript
// âŒ WRONG - resource for a mutation doesn't make sense
const DeleteButton = (svc: Service) => () => {
  const deletion = svc.resource((s) =>
    fetch('/api/item', { method: 'DELETE', signal: s })
  );  // This fetches immediately on mount!

  return svc.el('button')(/* ??? */);
};
```

```typescript
// âœ… CORRECT - use asyncAction for imperative mutations
const DeleteButton = (svc: Service) => () => {
  const { el, signal } = svc;

  const pending = signal(false);
  const error = signal<Error | null>(null);

  const deleteItem = async () => {
    pending(true);
    error(null);
    try {
      await fetch('/api/item', { method: 'DELETE' });
    } catch (e) {
      error(e instanceof Error ? e : new Error(String(e)));
    } finally {
      pending(false);
    }
  };

  return el('button').props({
    onclick: deleteItem,
    disabled: pending,
  })('Delete');
};
```

### Don't Access .data() Without Checking Status

The `data()` accessor returns `undefined` until the resource is ready. Using it directly without guards causes runtime errors:

```typescript
// âŒ WRONG - data() is undefined until ready
const UserProfile = (svc: Service) => () => {
  const user = svc.resource((s) => fetchUser(s));

  // This crashes during loading!
  return svc.el('div')(user.data()!.name);
};
```

```typescript
// âœ… CORRECT - use match to ensure data exists
const UserProfile = (svc: Service) => () => {
  const { el, resource, match } = svc;
  const user = resource((s) => fetchUser(s));

  return match(user, (state) =>
    state.status === 'ready'
      ? el('div')(state.value.name)
      : state.status === 'error'
        ? el('div')('Error loading user')
        : el('div')('Loading...')
  );
};
```

---

## Behaviors

<!-- @tags: behavior, headless, disclosure, dropdown, modal, pagination, composition -->

A **behavior** is a portable function that encapsulates reactive logic without any UI. It receives a service, returns a factory, and that factory returns an API of signals, computeds, and actions.

Think of behaviors as headless componentsâ€”all the state and logic, none of the markup.

---

## The Shape

```typescript
type SignalsSvc = {
  signal: <T>(initial: T) => Writable<T>;
  computed: <T>(fn: () => T) => Readable<T>;
  effect: (fn: () => void | (() => void)) => () => void;
};

const behaviorName = (svc: SignalsSvc) => (options?: Options) => {
  // Create reactive state
  // Define actions
  // Return the API
  return { ... };
};
```

Three levels:
1. **Service injection**: `(svc) =>` â€” receives modules
2. **Factory**: `(options?) =>` â€” configures the instance
3. **API**: `{ ... }` â€” the reactive interface consumers use

---

## A Simple Example: Counter

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const { signal, computed } = svc;

  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

Usage with `use()`:

```typescript
const App = (svc: Service) => () => {
  const { el, use, computed } = svc;
  const { count, increment, decrement } = use(counter)(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: decrement })('-'),
    el('button').props({ onclick: increment })('+')
  );
};
```

The behavior handles state. The component handles rendering. Clean separation.

---

## Composing Behaviors

Behaviors can use other behaviors. This is where the pattern shines.

### Disclosure (open/close)

```typescript
const disclosure = (svc: SignalsSvc) => (initialOpen = false) => {
  const { signal, computed } = svc;
  const isOpen = signal(initialOpen);

  return {
    isOpen,
    open: () => isOpen(true),
    close: () => isOpen(false),
    toggle: () => isOpen(!isOpen()),
    // Accessibility props
    triggerProps: computed(() => ({
      'aria-expanded': String(isOpen()),
    })),
    contentProps: computed(() => ({
      hidden: !isOpen(),
    })),
  };
};
```

### Dropdown (disclosure + keyboard)

```typescript
const dropdown = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {
  const disc = disclosure(svc)(options?.initialOpen ?? false);

  // Add keyboard handling
  const onKeyDown = (e: KeyboardEvent) => {
    switch (e.key) {
      case 'Escape':
        disc.close();
        break;
      case 'Enter':
      case ' ':
        e.preventDefault();
        disc.toggle();
        break;
    }
  };

  return {
    ...disc,
    triggerProps: svc.computed(() => ({
      ...disc.triggerProps(),
      onkeydown: onKeyDown,
    })),
  };
};
```

### Modal (disclosure + focus trap + scroll lock)

```typescript
const modal = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {
  const { signal, effect } = svc;

  const disc = disclosure(svc)(options?.initialOpen ?? false);
  const previousFocus = signal<HTMLElement | null>(null);

  // Focus trap and scroll lock as an effect
  effect(() => {
    if (disc.isOpen()) {
      // Save current focus
      previousFocus(document.activeElement as HTMLElement);
      // Lock scroll
      document.body.style.overflow = 'hidden';
    } else {
      // Restore scroll
      document.body.style.overflow = '';
      // Restore focus
      previousFocus()?.focus();
    }
  });

  return {
    ...disc,
    // Close on backdrop click
    backdropProps: svc.computed(() => ({
      onclick: disc.close,
    })),
    // Prevent close when clicking modal content
    contentProps: svc.computed(() => ({
      ...disc.contentProps(),
      onclick: (e: Event) => e.stopPropagation(),
    })),
  };
};
```

Same `disclosure` behavior, three different use cases. The logic is shared; the semantics differ.

---

## Behaviors with Options

Use options for configuration that affects behavior:

```typescript
type PaginationOptions = {
  totalItems: number;
  pageSize?: number;
  initialPage?: number;
};

const pagination = (svc: SignalsSvc) => (options: PaginationOptions) => {
  const { signal, computed } = svc;

  const pageSize = options.pageSize ?? 10;
  const currentPage = signal(options.initialPage ?? 1);

  const totalPages = computed(() =>
    Math.ceil(options.totalItems / pageSize)
  );

  const hasNext = computed(() => currentPage() < totalPages());
  const hasPrev = computed(() => currentPage() > 1);

  return {
    currentPage,
    totalPages,
    hasNext,
    hasPrev,
    next: () => hasNext() && currentPage(currentPage() + 1),
    prev: () => hasPrev() && currentPage(currentPage() - 1),
    goTo: (page: number) => {
      if (page >= 1 && page <= totalPages()) {
        currentPage(page);
      }
    },
  };
};
```

---

## Behaviors with Reactive Options

When options need to be reactive, accept signals:

```typescript
import type { Readable } from '@rimitive/signals';

type SearchOptions = {
  query: Readable<string>;
  debounceMs?: number;
};

const search = (svc: SignalsSvc) => (options: SearchOptions) => {
  const { signal, computed, effect } = svc;

  const results = signal<SearchResult[]>([]);
  const isSearching = signal(false);

  let timeoutId: number | undefined;

  effect(() => {
    const q = options.query();

    clearTimeout(timeoutId);

    if (!q) {
      results([]);
      return;
    }

    isSearching(true);

    timeoutId = window.setTimeout(async () => {
      const data = await performSearch(q);
      results(data);
      isSearching(false);
    }, options.debounceMs ?? 300);
  });

  return {
    results,
    isSearching,
    resultCount: computed(() => results().length),
  };
};
```

---

## Using Behaviors in React

Behaviors work in React via `@rimitive/react`:

```typescript
import { SignalProvider, createHook, useSubscribe } from '@rimitive/react';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Create hooks from behaviors
const useCounter = createHook(counter);
const useDisclosure = createHook(disclosure);

function ReactDropdown() {
  const disc = useDisclosure(false);

  // Subscribe to signals for React re-renders
  const isOpen = useSubscribe(disc.isOpen);
  const triggerProps = useSubscribe(disc.triggerProps);
  const contentProps = useSubscribe(disc.contentProps);

  return (
    <div>
      <button {...triggerProps} onClick={disc.toggle}>
        Toggle
      </button>
      {isOpen && (
        <div {...contentProps}>
          Dropdown content
        </div>
      )}
    </div>
  );
}

// Wrap app with provider
const svc = compose(SignalModule, ComputedModule, EffectModule)();

function App() {
  return (
    <SignalProvider svc={svc}>
      <ReactDropdown />
    </SignalProvider>
  );
}
```

Same behavior, different framework. The logic stays the same.

---

## Naming Conventions

Rimitive doesn't enforce naming conventions, but here are some that work:

```typescript
// Option 1: Plain names
const counter = (svc) => ...
const disclosure = (svc) => ...

// Option 2: "use" prefix (familiar to React users)
const useCounter = (svc) => ...
const useDisclosure = (svc) => ...

// Option 3: "create" prefix (emphasizes factory nature)
const createCounter = (svc) => ...
const createDisclosure = (svc) => ...
```

---

## When to Use Behaviors

**Good candidates:**
- State that multiple components share (disclosure, selection, pagination)
- Complex state logic (forms, wizards, data fetching)
- Reusable interaction patterns (drag-and-drop, keyboard navigation)
- Anything you'd put in a custom hook in React

**Not necessary for:**
- One-off component state (just use signals directly)
- Pure presentation logic (no state to manage)
- Framework-specific integrations

---

## Testing Behaviors

Behaviors are trivial to testâ€”no DOM, no framework:

```typescript
import { describe, it, expect } from 'vitest';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

describe('counter', () => {
  const createTestSvc = () => compose(SignalModule, ComputedModule, EffectModule)();

  it('increments and decrements', () => {
    const svc = createTestSvc();
    const c = counter(svc)(5);

    expect(c.count()).toBe(5);

    c.increment();
    expect(c.count()).toBe(6);

    c.decrement();
    c.decrement();
    expect(c.count()).toBe(4);
  });

  it('computes doubled', () => {
    const svc = createTestSvc();
    const c = counter(svc)(3);

    expect(c.doubled()).toBe(6);

    c.increment();
    expect(c.doubled()).toBe(8);
  });
});
```

Pure functions, pure tests.

### Testing Behaviors with Dependencies

When a behavior depends on external services, compose with mock modules:

```typescript
import { compose, defineModule } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// A storage module your behavior depends on
const StorageModule = defineModule({
  name: 'storage',
  create: () => ({
    get: (key: string) => localStorage.getItem(key),
    set: (key: string, value: string) => localStorage.setItem(key, value),
  }),
});

type StorageImpl = { get: (key: string) => string | null; set: (key: string, value: string) => void };

// Behavior that uses storage
const persistedCounter = (svc: SignalsSvc & { storage: StorageImpl }) => (key: string) => {
  const { signal, effect, storage } = svc;

  const saved = storage.get(key);
  const count = signal(saved ? parseInt(saved, 10) : 0);

  effect(() => storage.set(key, String(count())));

  return {
    count,
    increment: () => count(count() + 1),
  };
};

// Test with mocked storage
describe('persistedCounter', () => {
  it('persists to storage', () => {
    const stored: Record<string, string> = {};

    // Create mock storage module
    const MockStorageModule = defineModule({
      name: 'storage',
      create: (): StorageImpl => ({
        get: (key: string) => stored[key] ?? null,
        set: (key: string, value: string) => { stored[key] = value; },
      }),
    });

    // Compose with mock instead of real storage
    const testSvc = compose(
      SignalModule,
      ComputedModule,
      EffectModule,
      MockStorageModule
    );

    const c = persistedCounter(testSvc)('count');
    c.increment();
    c.increment();

    expect(stored['count']).toBe('2');
  });
});
```

For module dependency chains, use `override()` to swap nested dependencies:

```typescript
const DbModule = defineModule({
  name: 'db',
  create: () => ({ query: () => fetchFromDatabase() }),
});

const UserModule = defineModule({
  name: 'user',
  dependencies: [DbModule],
  create: ({ db }) => ({ getUser: (id: string) => db.query() }),
});

// Test: swap DbModule for a mock inside UserModule
const MockDb = defineModule({
  name: 'db',
  create: () => ({ query: () => ({ id: '1', name: 'Test' }) }),
});

const testSvc = compose(override(UserModule, { db: MockDb }));
expect(testSvc.user.getUser('1').name).toBe('Test');
```

---

## Anti-patterns

### Don't Mix UI into Behaviors

Behaviors should be headlessâ€”state and logic only, no DOM:

```typescript
// âŒ WRONG - behavior creates DOM elements
const dropdown = (svc: SignalsSvc) => () => {
  const isOpen = svc.signal(false);

  return {
    isOpen,
    toggle: () => isOpen(!isOpen()),
    // Don't do this! Behaviors shouldn't create elements
    render: () => el('div')(
      el('button').props({ onclick: () => isOpen(!isOpen()) })('Toggle'),
      match(isOpen, (open) => open ? el('div')('Content') : null)
    ),
  };
};
```

```typescript
// âœ… CORRECT - behavior returns props, component renders
const dropdown = (svc: SignalsSvc) => () => {
  const isOpen = svc.signal(false);

  return {
    isOpen,
    toggle: () => isOpen(!isOpen()),
    triggerProps: svc.computed(() => ({
      'aria-expanded': String(isOpen()),
    })),
    contentProps: svc.computed(() => ({
      hidden: !isOpen(),
    })),
  };
};

// Component uses the behavior
const Dropdown = (svc: Service) => () => {
  const { el, match, use } = svc;
  const disc = use(dropdown)();
  return el('div')(
    el('button').props({ ...disc.triggerProps(), onclick: disc.toggle })('Toggle'),
    match(disc.isOpen, (open) => open ? el('div').props(disc.contentProps())('Content') : null)
  );
};
```

### Don't Skip the Service Injection Layer

The double-function pattern exists for portability. Skipping it couples your behavior to a specific service:

```typescript
// âŒ WRONG - hardcoded service, not portable
import { svc } from './myService';

const counter = (initial = 0) => {
  const count = svc.signal(initial);  // Tied to this specific service
  return {
    count,
    increment: () => count(count() + 1),
  };
};
```

```typescript
// âœ… CORRECT - service injected, portable
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
  };
};

// Now works with any compatible service
const c1 = counter(productionSvc)(0);
const c2 = counter(testSvc)(0);  // Easy to test with mocks
```

### Don't Confuse Service Layer vs Factory

The service layer `(svc) =>` runs once when you call `svc.use(behavior)`. The factory `(options) =>` runs each time you create an instance. Put code in the right place:

```typescript
// âŒ WRONG - composing behaviors in the factory (runs every mount)
const dropdown = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {
  // This creates a new disclosure every time dropdown is instantiated
  const useDisclosure = svc.use(disclosure);  // Should be in service layer!
  const disc = useDisclosure(options?.initialOpen ?? false);

  return { ...disc };
};
```

```typescript
// âœ… CORRECT - compose in service layer, instantiate in factory
const dropdown = (svc: SignalsSvc) => {
  // Service layer: runs once, sets up composed behaviors
  const useDisclosure = svc.use(disclosure);

  return (options?: { initialOpen?: boolean }) => {
    // Factory: runs per instance, creates state
    const disc = useDisclosure(options?.initialOpen ?? false);

    return { ...disc };
  };
};
```

### Don't Create Side Effects Outside effect()

Side effects outside `effect()` won't be cleaned up when the behavior is disposed:

```typescript
// âŒ WRONG - side effect not tracked, never cleaned up
const keyboard = (svc: SignalsSvc) => () => {
  const pressed = svc.signal<string | null>(null);

  // This listener is never removed!
  window.addEventListener('keydown', (e) => pressed(e.key));

  return { pressed };
};
```

```typescript
// âœ… CORRECT - effect handles cleanup
const keyboard = (svc: SignalsSvc) => () => {
  const pressed = svc.signal<string | null>(null);

  svc.effect(() => {
    const handler = (e: KeyboardEvent) => pressed(e.key);
    window.addEventListener('keydown', handler);

    // Cleanup function - runs when effect re-runs or disposes
    return () => window.removeEventListener('keydown', handler);
  });

  return { pressed };
};
```

---

## Composition Over Stores

<!-- @tags: store, proxy, deep-reactivity, immutable, composition, state-management, nested-state -->

SolidJS has `createStore`. Vue has `reactive()`. These provide "deep reactivity"â€”you can mutate nested properties and the framework tracks the changes automatically.

Rimitive doesn't have stores. This is intentional.

---

## Why No Stores?

Deep reactivity requires proxies. Proxies have costs:

- **Magic behavior**: Property access triggers invisible tracking. Mutations trigger invisible updates. Hard to debug.
- **Performance overhead**: Every property access goes through the proxy trap.
- **Complexity**: Edge cases around arrays, Maps, Sets, class instances, etc.
- **Encourages sprawl**: Big nested state objects instead of focused, composable units.

There's nothing saying you can't create your own moduleâ€”it's just that Rimitive doesn't ship one by default.

---

## The Alternative: Composition

Instead of one big store, compose focused behaviors:

```typescript
// Instead of this:
const store = createStore({
  user: {
    profile: { name: '', avatar: '' },
    settings: { theme: 'light', notifications: true }
  },
  cart: {
    items: [],
    total: 0
  }
});

// Do this:
const userProfile = (svc: SignalsSvc) => () => {
  const name = svc.signal('');
  const avatar = svc.signal('');
  return {
    name,
    avatar,
    setName: (n: string) => name(n),
    setAvatar: (a: string) => avatar(a),
  };
};

const userSettings = (svc: SignalsSvc) => () => {
  const theme = svc.signal<'light' | 'dark'>('light');
  const notifications = svc.signal(true);
  return {
    theme,
    notifications,
    toggleTheme: () => theme(theme() === 'light' ? 'dark' : 'light'),
  };
};

const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);
  const total = svc.computed(() =>
    items().reduce((sum, item) => sum + item.price * item.qty, 0)
  );
  return {
    items,
    total,
    addItem: (item: CartItem) => items([...items(), item]),
    removeItem: (id: string) => items(items().filter(i => i.id !== id)),
  };
};
```

Each behavior:
- Has a clear, focused purpose
- Encapsulates its own logic
- Is independently testable
- Can be composed with others
- Is portable

---

## Composing Behaviors

Behaviors can depend on other behaviors by calling them directly:

```typescript
const checkout = (svc: SignalsSvc) => () => {
  const { computed } = svc;

  // Call other behaviors directly with the service
  const c = cart(svc)();
  const profile = userProfile(svc)();

  const canCheckout = computed(() =>
    c.items().length > 0 && profile.name() !== ''
  );

  const submit = async () => {
    if (!canCheckout()) return;
    await submitOrder({
      items: c.items(),
      customer: profile.name(),
    });
  };

  return { canCheckout, submit };
};
```

---

## Working with Arrays

For reactive arrays, use a signal holding an array:

```typescript
const todoList = ({ signal }: SignalsSvc) => () => {
  const items = signal<Todo[]>([]);

  return {
    items,
    add: (text: string) => {
      items([...items(), { id: crypto.randomUUID(), text, done: false }]);
    },
    toggle: (id: string) => {
      items(items().map(t =>
        t.id === id ? { ...t, done: !t.done } : t
      ));
    },
    remove: (id: string) => {
      items(items().filter(t => t.id !== id));
    },
  };
};
```

This follows an immutable pattern which is:
- Explicit (you see the update happening)
- Debuggable (you can log the before/after)
- Predictable (no proxy magic)

---

## When You Really Want Nested Updates

If you genuinely need to update nested data, create a focused updater:

```typescript
const nestedSettings = (svc: SignalsSvc) => () => {
  const settings = svc.signal({
    display: { theme: 'light', fontSize: 14 },
    privacy: { shareData: false, analytics: true },
  });

  // Focused updaters for specific paths
  const setTheme = (theme: string) => {
    settings({
      ...settings(),
      display: { ...settings().display, theme }
    });
  };

  const setFontSize = (size: number) => {
    settings({
      ...settings(),
      display: { ...settings().display, fontSize: size }
    });
  };

  // Or a generic path updater if you really need it
  const update = <K extends keyof Settings>(
    section: K,
    updates: Partial<Settings[K]>
  ) => {
    settings({
      ...settings(),
      [section]: { ...settings()[section], ...updates }
    });
  };

  return { settings, setTheme, setFontSize, update };
};
```

---

## But I Really Want Proxies

If you're convinced you need proxy-based stores, you can build them on top of Rimitive's primitives. The signals are thereâ€”wrap them in proxies if you want.

Or use an external store library and connect it via effects:

```typescript
import { createStore } from 'some-store-library';

const externalStore = createStore({ count: 0 });

const bridged = (svc: SignalsSvc) => () => {
  const count = svc.signal(externalStore.getState().count);

  // Sync from external store to signal
  externalStore.subscribe((state) => {
    count(state.count);
  });

  return { count };
};
```

But consider: if you're reaching for proxies, you might be fighting the framework. Rimitive's composition model works best when you embrace it.

---

## Anti-patterns

### Don't Create Monolithic State Objects

Putting everything in one big signal defeats the purpose of composition:

```typescript
// âŒ WRONG - monolithic state, hard to test and maintain
const appState = signal({
  user: { name: '', avatar: '', settings: { theme: 'light', notifications: true } },
  cart: { items: [], total: 0 },
  ui: { sidebarOpen: false, modal: null },
});

// Updates become awkward
appState(s => ({
  ...s,
  user: { ...s.user, settings: { ...s.user.settings, theme: 'dark' } }
}));
```

```typescript
// âœ… CORRECT - composed behaviors with focused responsibilities
const userSettings = (svc: SignalsSvc) => () => {
  const theme = svc.signal<'light' | 'dark'>('light');
  return {
    theme,
    toggleTheme: () => theme(theme() === 'light' ? 'dark' : 'light'),
  };
};

const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);
  const total = svc.computed(() => items().reduce((sum, i) => sum + i.price, 0));
  return { items, total, /* actions */ };
};

// Each behavior is focused, testable, and composable
```

### Don't Manually Sync Derived State

Using signals for values that should be computed causes bugs when you forget to update them:

```typescript
// âŒ WRONG - manually tracking derived state
const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);
  const total = svc.signal(0);  // Manually maintained!

  const addItem = (item: CartItem) => {
    items([...items(), item]);
    total(total() + item.price);  // Must remember to update
  };

  const removeItem = (id: string) => {
    const item = items().find(i => i.id === id);
    items(items().filter(i => i.id !== id));
    // Oops! Forgot to update total
  };

  return { items, total, addItem, removeItem };
};
```

```typescript
// âœ… CORRECT - compute derived values automatically
const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);

  // Automatically stays in sync
  const total = svc.computed(() =>
    items().reduce((sum, item) => sum + item.price, 0)
  );

  return {
    items,
    total,  // Always correct, can't get out of sync
    addItem: (item: CartItem) => items([...items(), item]),
    removeItem: (id: string) => items(items().filter(i => i.id !== id)),
  };
};
```

### Don't Expose Raw Signals Without Actions

Exposing signals directly allows uncontrolled mutations from anywhere:

```typescript
// âŒ WRONG - raw signal exposure, no controlled updates
const counter = (svc: SignalsSvc) => () => {
  const count = svc.signal(0);
  return { count };  // Anyone can write anything!
};

// Elsewhere:
counter.count(-999);  // No validation, no control
counter.count('oops'); // Type error, but conceptually wrong
```

```typescript
// âœ… CORRECT - expose signals with controlled actions
const counter = (svc: SignalsSvc) => () => {
  const count = svc.signal(0);

  return {
    count,  // Read access
    increment: () => count(count() + 1),
    decrement: () => count(Math.max(0, count() - 1)),  // Validated
    reset: () => count(0),
  };
};
```

### Don't Tightly Couple Composed Behaviors

Behaviors should receive dependencies, not import them directly:

```typescript
// âŒ WRONG - hard dependency on specific cart implementation
import { cart } from './cart';

const checkout = (svc: SignalsSvc) => () => {
  const c = cart(svc)();  // Always uses this specific cart

  return {
    submit: () => submitOrder(c.items()),
  };
};
```

```typescript
// âœ… CORRECT - receive the cart as a parameter
type CartLike = { items: Readable<CartItem[]> };

const checkout = (svc: SignalsSvc) => (cart: CartLike) => {
  return {
    submit: () => submitOrder(cart.items()),
  };
};

// Can inject any cart implementation, including mocks for testing
const c = cart(svc)();
const ch = checkout(svc)(c);
```

---

## Error Handling

<!-- @tags: error, error-boundary, try-catch, error-handling, async-error, effect-error, result-type -->

React has Error Boundaries. Solid has `<ErrorBoundary>`. You might expect Rimitive to have something similar.

It doesn'tâ€”because it doesn't need one.

---

## Why No Error Boundary Module?

In React and Solid, components are reactive functions that re-run during a render cycle. Errors can happen mid-render, and the framework needs a way to catch them and show fallback UI.

In Rimitive, components are just functions that return specs. They run once, produce a data structure, and that's it. Errors are plain JavaScript errors that propagate normally.

```typescript
const RiskyComponent = (svc: Service) => () => {
  const { el } = svc;

  // If this throws, it's a normal JS error
  const data = somethingThatMightThrow();

  return el('div')(data.value);
};
```

You handle it with... try/catch:

```typescript
const SafeWrapper = (svc: Service) => () => {
  const { el } = svc;
  const useRiskyComponent = svc(RiskyComponent);

  try {
    return useRiskyComponent();
  } catch (e) {
    return el('div').props({ className: 'error' })(
      'Something went wrong'
    );
  }
};
```

---

## Handling Async Errors

For async operations, use the `resource` module. It tracks error state explicitly:

```typescript
const ProductList = (svc: Service) => () => {
  const { el, resource, match } = svc;

  const products = resource((signal) =>
    fetch('/api/products', { signal }).then(r => r.json())
  );

  return match(products, (state) => {
    if (state.status === 'pending') {
      return el('div')('Loading...');
    }
    if (state.status === 'error') {
      return el('div').props({ className: 'error' })(
        `Failed to load: ${state.error}`
      );
    }
    return el('ul')(
      ...state.value.map(p => el('li')(p.name))
    );
  });
};
```

The error state is part of the resource's reactive value.

---

## Effect Errors

Errors in effects propagate normally. If you need to catch them:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, EffectModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule, EffectModule)();
const { signal, effect } = svc;

const count = signal(0);

effect(() => {
  try {
    riskyOperation(count());
  } catch (e) {
    console.error('Effect failed:', e);
    // Handle gracefully
  }
});
```

Or wrap the risky operation in a function that returns a result type:

```typescript
type Result<T> = { ok: true; value: T } | { ok: false; error: unknown };

const safeRiskyOperation = (n: number): Result<string> => {
  try {
    return { ok: true, value: riskyOperation(n) };
  } catch (e) {
    return { ok: false, error: e };
  }
};

effect(() => {
  const result = safeRiskyOperation(count());
  if (!result.ok) {
    errorState(result.error);
  }
});
```

---

## Creating a Reusable Error Wrapper

If you want an Error Boundary-like pattern, create a behavior:

```typescript
const errorBoundary = (svc: Service) =>
  <T>(
    render: () => T,
    fallback: (error: unknown) => T
  ): T => {
    try {
      return render();
    } catch (e) {
      return fallback(e);
    }
  };

// Usage
const App = (svc: Service) => () => {
  const { el } = svc;
  const withErrorBoundary = svc(errorBoundary);
  const useRiskyComponent = svc(RiskyComponent);

  return el('div')(
    withErrorBoundary(
      () => useRiskyComponent(),
      (e) => el('div')(`Error: ${e}`)
    )
  );
};
```

But honestly? Just use try/catch. It's JavaScript. It works.

---

## Anti-patterns

### Don't Swallow Errors Silently

Catching errors without logging or re-throwing hides bugs:

```typescript
// âŒ WRONG - error silently disappears
const LoadData = (svc: Service) => () => {
  const { el, signal, effect } = svc;
  const data = signal<Data | null>(null);

  effect(() => {
    try {
      data(fetchData());
    } catch (e) {
      // Silently swallowed - you'll never know it failed!
    }
  });

  return el('div')(/* ... */);
};
```

```typescript
// âœ… CORRECT - track error state, show it to users, log it
const LoadData = (svc: Service) => () => {
  const { el, signal, effect, match } = svc;
  const data = signal<Data | null>(null);
  const error = signal<Error | null>(null);

  effect(() => {
    try {
      error(null);
      data(fetchData());
    } catch (e) {
      console.error('Failed to load data:', e);
      error(e instanceof Error ? e : new Error(String(e)));
    }
  });

  return match(error, (err) =>
    err
      ? el('div').props({ className: 'error' })(err.message)
      : el('div')(/* render data */)
  );
};
```

### Don't Throw in Computeds Without Handling

A throwing computed breaks any effect or computed that depends on it:

```typescript
// âŒ WRONG - throws in computed, breaks dependent computations
const derived = computed(() => {
  const value = source();
  if (value < 0) {
    throw new Error('Invalid value');  // Breaks everything downstream
  }
  return value * 2;
});
```

```typescript
// âœ… CORRECT - return error state instead of throwing
type ComputedResult<T> = { ok: true; value: T } | { ok: false; error: string };

const derived = computed((): ComputedResult<number> => {
  const value = source();
  if (value < 0) {
    return { ok: false, error: 'Value must be non-negative' };
  }
  return { ok: true, value: value * 2 };
});

// Usage
match(derived, (result) =>
  result.ok
    ? el('span')(result.value)
    : el('span').props({ className: 'error' })(result.error)
);
```

### Don't Ignore Resource Error State

Resources track errors automatically. Ignoring them causes crashes:

```typescript
// âŒ WRONG - assumes data is always available
const ProductList = (svc: Service) => () => {
  const { el, resource, map } = svc;
  const products = resource((s) => fetchProducts(s));

  // Crashes when in error state!
  return el('ul')(
    map(products.data()!, (p) => el('li')(p.name))
  );
};
```

```typescript
// âœ… CORRECT - handle error state explicitly
const ProductList = (svc: Service) => () => {
  const { el, resource, match, map } = svc;
  const products = resource((s) => fetchProducts(s));

  return match(products, (state) => {
    switch (state.status) {
      case 'pending':
        return el('div')('Loading...');
      case 'error':
        return el('div').props({ className: 'error' })(
          `Failed to load: ${state.error.message}`
        );
      case 'ready':
        return el('ul')(map(state.value, (p) => el('li')(p.name)));
    }
  });
};
```

### Don't Catch and Continue Without Recovery

Catching an error but continuing as if nothing happened leads to inconsistent state:

```typescript
// âŒ WRONG - catches error but leaves state in limbo
const SaveForm = (svc: Service) => () => {
  const { el, signal } = svc;
  const saving = signal(false);

  const save = async () => {
    saving(true);
    try {
      await submitForm();
    } catch (e) {
      // Error caught, but saving is still true!
      console.error(e);
    }
    // Only resets if no error - state is inconsistent
    saving(false);
  };

  return el('form')(/* ... */);
};
```

```typescript
// âœ… CORRECT - always reset state in finally, track error separately
const SaveForm = (svc: Service) => () => {
  const { el, signal, match } = svc;
  const saving = signal(false);
  const saveError = signal<Error | null>(null);

  const save = async () => {
    saving(true);
    saveError(null);
    try {
      await submitForm();
    } catch (e) {
      saveError(e instanceof Error ? e : new Error(String(e)));
    } finally {
      saving(false);  // Always resets, regardless of success/failure
    }
  };

  return el('form')(
    match(saveError, (err) =>
      err ? el('div').props({ className: 'error' })(err.message) : null
    ),
    el('button').props({ disabled: saving })('Save')
  );
};
```

---

## Forms

Forms are one of the most common UI patterns. Rimitive doesn't have a built-in form moduleâ€”you compose form behavior from signals and computeds.

---

## The Field Pattern

A field is state plus metadata: the value, whether it's been touched, and any validation errors.

```typescript
type FieldOptions<T> = {
  initial: T;
  validate?: (value: T) => string | null;
};

const field = <T>(svc: SignalsSvc) => (opts: FieldOptions<T>) => {
  const { signal, computed } = svc;

  const value = signal(opts.initial);
  const touched = signal(false);

  const error = computed(() => {
    if (!touched()) return null;
    return opts.validate?.(value()) ?? null;
  });

  const valid = computed(() => !error());

  return {
    value,
    touched,
    error,
    valid,
    touch: () => touched(true),
    reset: () => {
      value(opts.initial);
      touched(false);
    },
  };
};
```

Usage:

```typescript
const emailField = svc(field)({
  initial: '',
  validate: (v) => {
    if (!v) return 'Required';
    if (!v.includes('@')) return 'Invalid email';
    return null;
  },
});

// Read state
emailField.value();   // ''
emailField.touched(); // false
emailField.error();   // null (not touched yet)

// User types and blurs
emailField.value('bad');
emailField.touch();
emailField.error();   // 'Invalid email'

// User fixes it
emailField.value('user@example.com');
emailField.error();   // null
emailField.valid();   // true
```

---

## Input Binding

Bind the field to an input element:

```typescript
const EmailInput = (svc: Service) => () => {
  const { el, on, signal, computed } = svc;

  const email = svc(field)({
    initial: '',
    validate: (v) => v.includes('@') ? null : 'Invalid email',
  });

  return el('div')(
    el('input')
      .props({
        type: 'email',
        value: email.value,
        className: computed(() => email.error() ? 'input-error' : ''),
      })
      .ref(
        on('input', (e) => email.value((e.target as HTMLInputElement).value)),
        on('blur', () => email.touch())
      )(),
    el('span').props({
      className: 'error-message',
      hidden: computed(() => !email.error()),
    })(computed(() => email.error() ?? ''))
  );
};
```

---

## Composing Fields into Forms

A form is a collection of fields with submission logic:

```typescript
type FormOptions<T> = {
  fields: T;
  onSubmit: (values: { [K in keyof T]: T[K] extends { value: Readable<infer V> } ? V : never }) => void | Promise<void>;
};

const form = <T extends Record<string, { value: Readable<unknown>; valid: Readable<boolean>; touch: () => void }>>(
  svc: SignalsSvc
) => (opts: FormOptions<T>) => {
  const { signal, computed } = svc;

  const submitting = signal(false);
  const submitError = signal<string | null>(null);

  const valid = computed(() =>
    Object.values(opts.fields).every((f) => f.valid())
  );

  const submit = async () => {
    // Touch all fields to show errors
    Object.values(opts.fields).forEach((f) => f.touch());

    if (!valid()) return;

    submitting(true);
    submitError(null);

    try {
      const values = Object.fromEntries(
        Object.entries(opts.fields).map(([k, f]) => [k, f.value()])
      );
      await opts.onSubmit(values as Parameters<typeof opts.onSubmit>[0]);
    } catch (e) {
      submitError(e instanceof Error ? e.message : 'Submission failed');
    } finally {
      submitting(false);
    }
  };

  return {
    fields: opts.fields,
    valid,
    submitting,
    submitError,
    submit,
  };
};
```

---

## Full Form Example

```typescript
const SignupForm = (svc: Service) => () => {
  const { el, on, computed, match } = svc;

  // Create fields
  const email = svc(field)({
    initial: '',
    validate: (v) => {
      if (!v) return 'Email is required';
      if (!v.includes('@')) return 'Invalid email';
      return null;
    },
  });

  const password = svc(field)({
    initial: '',
    validate: (v) => {
      if (!v) return 'Password is required';
      if (v.length < 8) return 'Password must be at least 8 characters';
      return null;
    },
  });

  // Create form
  const signup = svc(form)({
    fields: { email, password },
    onSubmit: async (values) => {
      await fetch('/api/signup', {
        method: 'POST',
        body: JSON.stringify(values),
      });
    },
  });

  // Field renderer helper
  const renderField = (
    label: string,
    type: string,
    f: ReturnType<ReturnType<typeof field<string>>>
  ) => el('div').props({ className: 'field' })(
    el('label')(label),
    el('input')
      .props({
        type,
        value: f.value,
        disabled: signup.submitting,
      })
      .ref(
        on('input', (e) => f.value((e.target as HTMLInputElement).value)),
        on('blur', () => f.touch())
      )(),
    match(f.error, (err) =>
      err ? el('span').props({ className: 'error' })(err) : null
    )
  );

  return el('form')
    .props({
      onsubmit: (e: Event) => {
        e.preventDefault();
        signup.submit();
      },
    })(
      renderField('Email', 'email', email),
      renderField('Password', 'password', password),

      // Submit error
      match(signup.submitError, (err) =>
        err ? el('div').props({ className: 'submit-error' })(err) : null
      ),

      // Submit button
      el('button')
        .props({
          type: 'submit',
          disabled: computed(() => signup.submitting() || !signup.valid()),
        })(
          computed(() => signup.submitting() ? 'Signing up...' : 'Sign Up')
        )
    );
};
```

---

## Validation Patterns

### Synchronous Validation

Most validation is synchronousâ€”check the value, return an error or null:

```typescript
const required = (msg = 'Required') => (v: string) => v ? null : msg;

const minLength = (n: number) => (v: string) =>
  v.length >= n ? null : `Must be at least ${n} characters`;

const pattern = (re: RegExp, msg: string) => (v: string) =>
  re.test(v) ? null : msg;

// Compose validators
const compose = <T>(...validators: ((v: T) => string | null)[]) => (v: T) => {
  for (const validate of validators) {
    const error = validate(v);
    if (error) return error;
  }
  return null;
};

// Usage
const username = svc(field)({
  initial: '',
  validate: compose(
    required('Username is required'),
    minLength(3),
    pattern(/^[a-z0-9_]+$/, 'Only lowercase letters, numbers, and underscores')
  ),
});
```

### Async Validation

For validation that requires a server check (e.g., username availability):

```typescript
const asyncField = <T>(svc: SignalsSvc) => (opts: {
  initial: T;
  validate?: (value: T) => string | null;
  asyncValidate?: (value: T) => Promise<string | null>;
  debounceMs?: number;
}) => {
  const { signal, computed, effect } = svc;

  const base = field(svc)(opts);
  const asyncError = signal<string | null>(null);
  const validating = signal(false);

  let timeout: number | undefined;

  // Run async validation when value changes
  effect(() => {
    const v = base.value();
    const syncError = opts.validate?.(v);

    // Skip async if sync fails
    if (syncError || !opts.asyncValidate) {
      asyncError(null);
      return;
    }

    clearTimeout(timeout);
    validating(true);

    timeout = window.setTimeout(async () => {
      try {
        const err = await opts.asyncValidate!(v);
        asyncError(err);
      } finally {
        validating(false);
      }
    }, opts.debounceMs ?? 300);
  });

  return {
    ...base,
    validating,
    error: computed(() => base.error() ?? asyncError()),
    valid: computed(() => !base.error() && !asyncError() && !validating()),
  };
};

// Usage
const username = svc(asyncField)({
  initial: '',
  validate: required('Username is required'),
  asyncValidate: async (v) => {
    const res = await fetch(`/api/check-username?q=${v}`);
    const { available } = await res.json();
    return available ? null : 'Username is taken';
  },
  debounceMs: 500,
});
```

---

## Dependent Fields

When one field's validation depends on another:

```typescript
const password = svc(field)({
  initial: '',
  validate: minLength(8),
});

const confirmPassword = svc(field)({
  initial: '',
  validate: (v) => {
    if (!v) return 'Required';
    if (v !== password.value()) return 'Passwords do not match';
    return null;
  },
});
```

---

## Field Arrays

For dynamic lists of fields (e.g., adding/removing tags):

```typescript
const fieldArray = <T>(svc: SignalsSvc) => (opts: {
  initial: T[];
  validateItem?: (value: T) => string | null;
}) => {
  const { signal, computed } = svc;

  const items = signal(
    opts.initial.map((v) => field(svc)({ initial: v, validate: opts.validateItem }))
  );

  const values = computed(() => items().map((f) => f.value()));
  const valid = computed(() => items().every((f) => f.valid()));

  return {
    items,
    values,
    valid,
    add: (value: T) => {
      items([...items(), field(svc)({ initial: value, validate: opts.validateItem })]);
    },
    remove: (index: number) => {
      items(items().filter((_, i) => i !== index));
    },
  };
};

// Usage
const tags = svc(fieldArray)({
  initial: ['javascript', 'typescript'],
  validateItem: (v) => v.length > 0 ? null : 'Tag cannot be empty',
});

tags.add('react');
tags.remove(0);
tags.values(); // ['typescript', 'react']
```

---

## When to Use This Pattern

**Good for:**
- Login/signup forms
- Settings pages
- Any form with validation feedback
- Multi-step wizards

**Overkill for:**
- Simple search inputs (just use a signal)
- Forms without validation
- One-off inputs that don't need error states

---

## Anti-patterns

<!-- @tags: forms, validation, anti-pattern, touched, ux -->

### Don't Validate Before Touched

Showing errors immediatelyâ€”before the user has interactedâ€”creates a poor experience:

```typescript
// âŒ WRONG - error shows immediately, even on empty form load
const field = <T>(svc: SignalsSvc) => (opts: { initial: T; validate: (v: T) => string | null }) => {
  const value = svc.signal(opts.initial);
  const error = svc.computed(() => opts.validate(value()));  // Always validates!

  return { value, error };
};

// User sees "Email is required" before they've even clicked the field
```

```typescript
// âœ… CORRECT - only show errors after user interaction
const field = <T>(svc: SignalsSvc) => (opts: { initial: T; validate: (v: T) => string | null }) => {
  const value = svc.signal(opts.initial);
  const touched = svc.signal(false);

  const error = svc.computed(() => {
    if (!touched()) return null;  // Don't validate until touched
    return opts.validate(value());
  });

  return {
    value,
    touched,
    error,
    touch: () => touched(true),
  };
};
```

<!-- @tags: forms, field-array, anti-pattern, mutation, reactivity -->

### Don't Mutate Field Arrays Directly

Field arrays are signalsâ€”mutating them directly bypasses reactivity:

```typescript
// âŒ WRONG - direct mutation doesn't trigger updates
const tags = svc(fieldArray)({ initial: ['a', 'b'] });

tags.items().push(newField);  // Mutates array, no reactive update
tags.items().splice(0, 1);    // Same problem
```

```typescript
// âœ… CORRECT - use the provided methods
const tags = svc(fieldArray)({ initial: ['a', 'b'] });

tags.add('c');     // Proper reactive update
tags.remove(0);    // Proper reactive update

// Or if you need custom operations, create a new array:
tags.items(tags.items().filter(f => f.valid()));
```

---

## Portability

<!-- @tags: portable, framework-agnostic, react, testing, ssr, adapter, cross-platform -->

Most UI logic isn't tied to a specific framework. A dropdown's open/close behavior is the same whether you're rendering to DOM, React, or a canvas. A form's validation logic doesn't care about the view layer.

Rimitive is designed around this insight. The same code can run in different contexts without modification.

---

## Depend on Contracts, Not Frameworks

A portable component depends on a **service contract**â€”a set of dependencies it needsâ€”not a specific framework:

```typescript
// This component depends on { el, signal, computed }
// It doesn't know or care where those come from
const Counter = (svc: { el: ElFactory; signal: SignalFactory; computed: ComputedFactory }) => () => {
  const { el, signal, computed } = svc;
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('Increment')
  );
};
```

This component works with any service that provides `el`, `signal`, and `computed`â€”whether that's a DOM view service, a test service, or something custom.

---

## Portable Component Pattern

The standard pattern is a function that receives a service and returns a function that takes props:

```typescript
// (svc) => (props) => RefSpec
const Button = (svc: Service) => (props: { label: string; onClick: () => void }) => {
  const { el } = svc;

  return el('button').props({ onclick: props.onClick })(props.label);
};
```

This shape lets you:
- Partially apply the service once
- Call the resulting function multiple times with different props
- Pass the component to `use()` for ergonomic instantiation

```typescript
const App = (svc: Service) => () => {
  const { el, use } = svc;

  return el('div')(
    use(Button)({ label: 'Save', onClick: handleSave }),
    use(Button)({ label: 'Cancel', onClick: handleCancel })
  );
};
```

---

## Running in Different Contexts

### Rimitive DOM View

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule, BatchModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

// Create adapter and compose service
const adapter = createDOMAdapter();
const svc = compose(
  SignalModule, ComputedModule, EffectModule, BatchModule,
  createElModule(adapter), MountModule
)();

const app = Counter(svc);
document.body.appendChild(svc.mount(app).element!);
```

### Testing Without DOM

For tests, use a mock adapter or compose with test dependencies:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Minimal test service - just signals, no view layer
const testSvc = compose(SignalModule, ComputedModule, EffectModule)();

// Test a behavior directly
const { count, increment } = counter(testSvc)(0);
expect(count()).toBe(0);
increment();
expect(count()).toBe(1);
```

### React (via @rimitive/react)

Portable behaviors work in React through `createHook`:

```typescript
import { SignalProvider, createHook, useSubscribe } from '@rimitive/react';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Define a portable behavior
const counter = (svc: { signal: SignalFactory }) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};

// Turn it into a React hook
const useCounter = createHook(counter);

function ReactCounter() {
  const { count, increment } = useCounter(0);
  const value = useSubscribe(count); // Subscribe to trigger re-renders

  return <button onClick={increment}>Count: {value}</button>;
}

// Wrap your app with SignalProvider
const svc = compose(SignalModule, ComputedModule, EffectModule)();

function App() {
  return (
    <SignalProvider svc={svc}>
      <ReactCounter />
    </SignalProvider>
  );
}
```

### Custom Renderer

The same pattern works with any adapter:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { myCanvasAdapter } from './my-canvas-adapter';

const svc = compose(
  SignalModule, ComputedModule, EffectModule,
  createElModule(myCanvasAdapter)
)();

const app = Counter(svc);
// Renders to canvas instead of DOM
```

Same component, different targets.

---

## Anti-patterns

### Don't Import Framework-Specific Code Directly

Importing directly couples your code to a specific setup:

```typescript
// âŒ WRONG - hardcoded dependency, not portable
import { signal } from '@rimitive/signals';

const MyComponent = () => {
  const count = signal(0);  // Can't swap this out for testing
};
```

```typescript
// âœ… CORRECT - depend on the service contract
const MyComponent = (svc: Service) => () => {
  const { signal } = svc;
  const count = signal(0);  // Works with any compatible service
};
```

### Don't Hardcode External Dependencies

Hardcoding URLs, API calls, or other external dependencies makes code untestable and inflexible:

```typescript
// âŒ WRONG - hardcoded URL, can't test without network
const DataList = (svc: Service) => () => {
  const items = svc.resource(() => fetch('/api/items'));
};
```

```typescript
// âœ… CORRECT - accept dependencies via service or props
const DataList = (svc: Service & { fetchItems: () => Promise<Item[]> }) => () => {
  const items = svc.resource(svc.fetchItems);
};

// Or via props
const DataList = (svc: Service) => (props: { fetchItems: () => Promise<Item[]> }) => {
  const items = svc.resource(props.fetchItems);
};
```

This lets you inject a mock fetcher in tests:

```typescript
const mockSvc = {
  ...testSvc,
  fetchItems: async () => [{ id: 1, name: 'Test' }],
};
```

---

## Portable Behaviors vs Portable Components

**Portable behaviors** return reactive state and logicâ€”no UI:

```typescript
const counter = (svc: { signal: SignalFactory }) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};
```

**Portable components** return UI specs:

```typescript
const Counter = (svc: Service) => () => {
  const { el, signal, computed } = svc;
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => count())),
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
```

Behaviors are more portable than components because they have no UI coupling. A behavior can be used in Rimitive views, React, Vue, or anywhere else that can consume signals.

---

## Type Safety

Define your service contracts with TypeScript:

```typescript
import type { SignalFactory, ComputedFactory } from '@rimitive/signals';
import type { ElFactory } from '@rimitive/view/el';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

// Minimal contract for a component
type MinimalSvc = {
  signal: SignalFactory;
  computed: ComputedFactory;
  el: ElFactory<DOMAdapterConfig>;
};

// Component declares exactly what it needs
const MyComponent = (svc: MinimalSvc) => { /* ... */ };
```

This makes dependencies explicit and enables better tree-shakingâ€”if a component only needs `signal` and `el`, it doesn't pull in `effect`, `resource`, etc.

---

## Testing Portable Code

Portable code is easy to test because you control the service:

```typescript
import { describe, it, expect } from 'vitest';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

describe('counter behavior', () => {
  it('increments count', () => {
    const svc = compose(SignalModule, ComputedModule, EffectModule)();
    const { count, increment } = counter(svc)(0);

    expect(count()).toBe(0);
    increment();
    expect(count()).toBe(1);
  });
});
```

No DOM mocking, no framework test utilitiesâ€”just functions and assertions.

---

## Shared State

<!-- @tags: context, shared-state, global-state, service-threading, theme, user, prop-drilling -->

Other frameworks have "context"â€”a way to pass values down the component tree without threading them through every intermediate component.

---

## The Pattern: Service Threading

In Rimitive, the **service is the context**. Components receive a service object containing the modules they need. You can extend that service with additional state at any point in the tree.

```typescript
// Define your app-level shared state
type AppService = Service & {
  theme: Readable<'light' | 'dark'>;
  user: Readable<User | null>;
};

const App = (svc: Service) => () => {
  const { el, signal } = svc;

  // Create shared state
  const theme = signal<'light' | 'dark'>('light');
  const user = signal<User | null>(null);

  // Extend the service
  const appSvc: AppService = { ...svc, theme, user };

  return el('div')(
    Header(appSvc)(),
    Main(appSvc)(),
    Footer(appSvc)()
  );
};
```

Child components receive the extended service and can access the shared state directly:

```typescript
const Header = (svc: AppService) => () => {
  const { el, computed, theme, user } = svc;

  return el('header').props({
    className: computed(() => theme() === 'dark' ? 'header-dark' : 'header-light')
  })(
    el('span')(computed(() => user()?.name ?? 'Guest'))
  );
};
```

No magic or implicit tree traversal. You can see exactly what's being passed where.

---

## Nested Overrides

Need to override a value for a subtree? Extend the service again:

```typescript
const DarkSection = (svc: AppService) => () => {
  const { el, signal } = svc;

  // Override theme for this subtree
  const darkSvc: AppService = { ...svc, theme: signal('dark') };

  return el('section')(
    // Everything in here sees theme = 'dark'
    ThemedCard(darkSvc)(),
    ThemedButton(darkSvc)()
  );
};
```

---

## With Portable Components

The portable component pattern (`(svc) => (props) => spec`) works naturally with this:

```typescript
// Portable component that expects theme in service
const ThemedButton = ({ el, computed, theme }: AppService) => (props: { label: string }) => {
  return el('button').props({
    className: computed(() => `btn btn-${theme()}`)
  })(props.label);
};

// Usage with `use`
const App = ({ el, use }: AppService) => () => {
  return el('div')(
    use(ThemedButton)({ label: 'Click me' })
  );
};
```

When you call `use(ThemedButton)`, it passes the current service (including any extensions) to the component.

---

## TypeScript Tips

Define your extended service types explicitly:

```typescript
import type { Service } from './service';
import type { Readable } from '@rimitive/signals/types';

// Base service with your extensions
export type AppService = Service & {
  theme: Readable<'light' | 'dark'>;
  user: Readable<User | null>;
  // add more as needed
};

// For components that only need a subset
export type ThemedService = Service & {
  theme: Readable<'light' | 'dark'>;
};
```

Components declare what they need:

```typescript
// This component works with any service that has `theme`
const ThemedCard = (svc: ThemedService) => () => { ... };

// This one needs the full app service
const UserProfile = (svc: AppService) => () => { ... };
```

---

## Why Not a Context Module?

I considered adding one. The problem: context in other frameworks works through implicit tree traversalâ€”a component "finds" the nearest provider by walking up the tree at render time.

Rimitive components are just functions returning specs. There's no render cycle or "currently rendering" context to hook into. Any context system would either:

1. Require explicit scope passing (which is what we already have)
2. Add hidden magic that fights Rimitive's design philosophy

The service threading pattern is explicit, type-safe, and composes naturally. It's not as terse as `useContext()`, but you can always see what's happening.

---

## Anti-patterns

### Don't Use Module-Level Signals for Shared State

Creating signals at module scope seems convenient, but it causes state to leak across your entire application and makes testing nearly impossible:

```typescript
// âŒ WRONG - module-level signal is global singleton
const theme = signal<'light' | 'dark'>('light');
const user = signal<User | null>(null);

const Header = (svc: Service) => () => {
  // Reads global state - can't test in isolation
  return svc.el('header')(theme());
};
```

```typescript
// âœ… CORRECT - state lives in the service, threaded explicitly
const App = (svc: Service) => () => {
  const theme = svc.signal<'light' | 'dark'>('light');
  const user = svc.signal<User | null>(null);

  const appSvc = { ...svc, theme, user };

  return svc.el('div')(Header(appSvc)());
};
```

The service threading pattern keeps state local to component trees and enables testing with isolated services.

### Don't Mutate the Service Object

Mutating the service directly instead of creating a new one causes subtle bugsâ€”all components sharing that service see the mutation:

```typescript
// âŒ WRONG - mutates shared service object
const DarkSection = (svc: AppService) => () => {
  svc.theme = svc.signal('dark');  // Mutates the original!
  return svc.el('section')(/* ... */);
};
```

```typescript
// âœ… CORRECT - create a new extended service
const DarkSection = (svc: AppService) => () => {
  const darkSvc = { ...svc, theme: svc.signal('dark') };
  return svc.el('section')(Child(darkSvc)());
};
```

### Don't Skip Type Annotations for Extended Services

Without proper types, you lose the main benefit of explicit service threadingâ€”knowing exactly what's available:

```typescript
// âŒ WRONG - untyped extension loses type safety
const App = (svc: Service) => () => {
  const theme = svc.signal('light');
  const appSvc = { ...svc, theme };  // Type is just Service & { theme: ... }

  // Later components have no idea what's in the service
  return svc.el('div')(Header(appSvc)());  // Header type is unclear
};
```

```typescript
// âœ… CORRECT - explicit service types
type AppService = Service & {
  theme: Readable<'light' | 'dark'>;
};

const App = (svc: Service) => () => {
  const theme = svc.signal<'light' | 'dark'>('light');
  const appSvc: AppService = { ...svc, theme };

  // Header explicitly declares what it needs
  return svc.el('div')(Header(appSvc)());
};

const Header = (svc: AppService) => () => {
  // TypeScript knows exactly what's available
  const { el, theme } = svc;
  return el('header')(/* ... */);
};
```

### Don't Create Shared State Inside Render

Shared state should be created once and threaded through. Creating it inside component bodies means it's recreated on each instantiation:

```typescript
// âŒ WRONG - creates new signal every time component is instantiated
const ThemedSection = (svc: Service) => (props: { children: RefSpec }) => {
  // This creates a NEW theme signal for every ThemedSection instance!
  const theme = svc.signal<'light' | 'dark'>('light');
  const themedSvc = { ...svc, theme };

  return svc.el('section')(props.children);
};
```

```typescript
// âœ… CORRECT - shared state created at app level, threaded down
const App = (svc: Service) => () => {
  // Created once at the app level
  const theme = svc.signal<'light' | 'dark'>('light');
  const appSvc: AppService = { ...svc, theme };

  return svc.el('div')(
    ThemedSection(appSvc)({ children: /* ... */ })
  );
};

const ThemedSection = (svc: AppService) => (props: { children: RefSpec }) => {
  // Uses existing theme from service, doesn't create new one
  return svc.el('section')(props.children);
};
```

---

## Signal Patterns

<!-- @tags: signal, toggle, previous-value, debounce, async-action, derived-state -->

## Try It

Signals are simpleâ€”read with `sig()`, write with `sig(value)`. But there are patterns that make them more ergonomic for common use cases.

---

## Working with Arrays and Objects

When updating arrays and objects, read the current value and write the new value:

```typescript
const items = signal<Item[]>([]);

// Append
items([...items(), newItem]);

// Remove by id
items(items().filter(x => x.id !== id));

// Update one item
items(items().map(x => x.id === id ? { ...x, done: true } : x));

// Toggle a property
items(items().map(x => x.id === id ? { ...x, done: !x.done } : x));
```

---

## Derived Actions

The standard behavior pattern returns an object with state and actions:

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};

const { count, increment, decrement } = svc(counter)(0);
```

An alternative: attach actions directly to the signal:

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);

  return Object.assign(count, {
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  });
};

// Usage - no destructuring needed
const count = svc(counter)(0);

count();           // read: 0
count(5);          // write: 5
count.increment(); // action: 6
count.reset();     // action: 0
```

This works because signals are functions, and functions are objects that can have properties.

---

## Toggle

A common case of derived actionsâ€”boolean signals with on/off/toggle:

```typescript
const toggle = (svc: SignalsSvc) => (initial = false) => {
  const value = svc.signal(initial);

  return Object.assign(value, {
    on: () => value(true),
    off: () => value(false),
    toggle: () => value(!value()),
  });
};

// Usage
const isOpen = svc(toggle)(false);

isOpen();        // false
isOpen.toggle(); // true
isOpen.off();    // false

// Still works as a normal signal
isOpen(true);    // true
```

---

## Previous Value

Track the previous value for transitions, animations, or undo:

```typescript
const withPrevious = <T>(svc: SignalsSvc) => (initial: T) => {
  const { signal, computed } = svc;

  const current = signal(initial);
  const previous = signal(initial);

  const set = (value: T) => {
    previous(current());
    current(value);
  };

  const changed = computed(() => current() !== previous());

  return { current, previous, set, changed };
};

// Usage
const page = svc(withPrevious)(1);

page.set(2);
page.current();   // 2
page.previous();  // 1
page.changed();   // true

page.set(2);
page.changed();   // false (same value)
```

For undo/redo, extend the pattern with a history stack:

```typescript
const withHistory = <T>(svc: SignalsSvc) => (initial: T, maxHistory = 10) => {
  const { signal, computed } = svc;

  const current = signal(initial);
  const past = signal<T[]>([]);
  const future = signal<T[]>([]);

  const canUndo = computed(() => past().length > 0);
  const canRedo = computed(() => future().length > 0);

  const set = (value: T) => {
    past([...past().slice(-(maxHistory - 1)), current()]);
    future([]);
    current(value);
  };

  const undo = () => {
    if (!canUndo()) return;
    const prev = past();
    const last = prev[prev.length - 1];
    past(prev.slice(0, -1));
    future([...future(), current()]);
    current(last!);
  };

  const redo = () => {
    if (!canRedo()) return;
    const fut = future();
    const next = fut[fut.length - 1];
    future(fut.slice(0, -1));
    past([...past(), current()]);
    current(next!);
  };

  return { current, set, undo, redo, canUndo, canRedo };
};
```

---

## Debounced Signals

Delay signal updates until input settles:

```typescript
const debounced = <T>(svc: SignalsSvc) => (
  source: Readable<T>,
  ms: number
) => {
  const { signal, effect } = svc;

  const value = signal(source.peek());
  let timeout: number | undefined;

  effect(() => {
    const v = source();
    clearTimeout(timeout);
    timeout = window.setTimeout(() => value(v), ms);
  });

  return value;
};

// Usage
const searchInput = signal('');
const debouncedSearch = svc(debounced)(searchInput, 300);

// searchInput updates immediately on keystroke
// debouncedSearch updates 300ms after typing stops
```

A variant that debounces both reads and writes:

```typescript
const debouncedSignal = <T>(svc: SignalsSvc) => (initial: T, ms: number) => {
  const { signal, effect } = svc;

  const immediate = signal(initial);
  const debounced = signal(initial);

  let timeout: number | undefined;

  effect(() => {
    const v = immediate();
    clearTimeout(timeout);
    timeout = window.setTimeout(() => debounced(v), ms);
  });

  // Return a signal-like object that writes to immediate, reads from debounced
  const result = ((value?: T) => {
    if (arguments.length === 0) return debounced();
    immediate(value!);
  }) as Writable<T>;

  result.peek = () => debounced.peek();

  return Object.assign(result, {
    immediate,  // Access the non-debounced value if needed
  });
};
```

---

## Async Actions

For mutations that need loading and error state:

```typescript
const asyncAction = <T, Args extends unknown[]>(svc: SignalsSvc) => (
  action: (...args: Args) => Promise<T>
) => {
  const { signal } = svc;

  const pending = signal(false);
  const error = signal<Error | null>(null);
  const lastResult = signal<T | null>(null);

  const execute = async (...args: Args): Promise<T> => {
    pending(true);
    error(null);

    try {
      const result = await action(...args);
      lastResult(result);
      return result;
    } catch (e) {
      const err = e instanceof Error ? e : new Error(String(e));
      error(err);
      throw err;
    } finally {
      pending(false);
    }
  };

  return { execute, pending, error, lastResult };
};

// Usage
const saveUser = svc(asyncAction)(async (user: User) => {
  const res = await fetch('/api/users', {
    method: 'POST',
    body: JSON.stringify(user),
  });
  if (!res.ok) throw new Error('Failed to save');
  return res.json();
});

// In a component
el('button')
  .props({
    onclick: () => saveUser.execute({ name: 'Alice' }),
    disabled: saveUser.pending,
  })(
    computed(() => saveUser.pending() ? 'Saving...' : 'Save')
  );

// Show errors
match(saveUser.error, (err) =>
  err ? el('div').props({ className: 'error' })(err.message) : null
);
```

---

## Computed Collections

When working with reactive lists, pre-compute common derived views:

```typescript
const todoList = (svc: SignalsSvc) => () => {
  const { signal, computed } = svc;

  const items = signal<Todo[]>([]);

  // Pre-computed views - computed once, cached automatically
  const active = computed(() => items().filter(t => !t.done));
  const completed = computed(() => items().filter(t => t.done));

  const counts = computed(() => ({
    total: items().length,
    active: active().length,
    completed: completed().length,
  }));

  const allDone = computed(() =>
    items().length > 0 && completed().length === items().length
  );

  return {
    items,
    active,
    completed,
    counts,
    allDone,
    // Actions...
    add: (text: string) => items([...items(), { id: crypto.randomUUID(), text, done: false }]),
    toggle: (id: string) => items(items().map(t => t.id === id ? { ...t, done: !t.done } : t)),
    remove: (id: string) => items(items().filter(t => t.id !== id)),
    clear: () => items(items().filter(t => !t.done)),
  };
};
```

Consumers can read whichever view they need:

```typescript
// Only re-renders when active items change
const ActiveList = (svc: Service) => (todos: ReturnType<typeof todoList>) => {
  const { el, map } = svc;
  return map(todos.active, t => t.id, TodoItem);
};

// Only re-renders when counts change
const Stats = (svc: Service) => (todos: ReturnType<typeof todoList>) => {
  const { el, computed } = svc;
  return el('div')(
    computed(() => `${todos.counts().active} items left`)
  );
};
```

---

## Element Partial Application

Pre-bind commonly used element tags:

```typescript
const svc = compose(SignalModule, createElModule(adapter));
const { el } = svc;

// Partial application - call el() once per tag
const div = el('div');
const button = el('button');
const input = el('input');
const span = el('span');

// Use without repeating tag names
const Form = () =>
  div.props({ className: 'form' })(
    div.props({ className: 'field' })(
      input.props({ type: 'text', placeholder: 'Name' })(),
    ),
    button.props({ type: 'submit' })('Submit')
  );
```

This is especially useful in files with many elements of the same type.

---

## Service Factory

For applications that need multiple isolated instances:

```typescript
// Define service creation as a factory
const createService = () => {
  const adapter = createDOMAdapter();
  return compose(
    SignalModule, ComputedModule, EffectModule,
    createElModule(adapter),
    createMapModule(adapter),
    createMatchModule(adapter),
  );
};

// Each call creates a fresh service with its own state
const app1 = createService();
const app2 = createService();

// Mount separate instances
mount(App(app1), document.getElementById('app1')!);
mount(App(app2), document.getElementById('app2')!);
```

This is useful for:
- Embedding multiple independent widgets on a page
- Testing with isolated services
- SSR where each request needs fresh state

---

## Anti-patterns

### Don't Create Module-Level Signals

Signals created at module scope are shared across your entire application. This causes state to leak between components and makes testing difficult:

```typescript
// âŒ WRONG - module-level signal is global shared state
const count = signal(0);  // Created once when module loads

const Counter = () => {
  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
// Every Counter instance shares the same count!
```

```typescript
// âœ… CORRECT - state created per instance
const Counter = () => {
  const count = signal(0);  // Fresh state each time

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
```

### Don't Mutate Signal Values Directly

Signals hold values by reference. Mutating the value directly bypasses reactivity:

```typescript
// âŒ WRONG - mutation doesn't trigger updates
const items = signal<string[]>([]);

items().push('new item');  // Mutates the array, but signal doesn't know
items();  // Still returns the same reference - no reactive update!
```

```typescript
// âœ… CORRECT - create new values with explicit read/write
const items = signal<string[]>([]);

items([...items(), 'new item']);  // New array, signal updates
```

The same applies to objects:

```typescript
// âŒ WRONG
const user = signal({ name: 'Alice', age: 30 });
user().age = 31;  // Mutation - no reactive update

// âœ… CORRECT
user({ ...user(), age: 31 });  // New object - reactive update
```

### Don't Read Signals Outside Reactive Context

Reading a signal outside of `computed` or `effect` won't track dependencies:

```typescript
// âŒ WRONG - this value won't update
const name = signal('Alice');
const greeting = `Hello, ${name()}!`;  // Read once, never updates

el('div')(greeting);  // Always shows "Hello, Alice!"
```

```typescript
// âœ… CORRECT - wrap in computed for reactive updates
const name = signal('Alice');
const greeting = computed(() => `Hello, ${name()}!`);

el('div')(greeting);  // Updates when name changes
```

### Don't Create Circular Dependencies in Computeds

Computeds that depend on each other create infinite loops:

```typescript
// âŒ WRONG - circular dependency
const a = computed(() => b() + 1);
const b = computed(() => a() + 1);  // Boom! Infinite loop
```

If you need derived values that reference each other, use signals with explicit updates:

```typescript
// âœ… CORRECT - use signals with controlled updates
const a = signal(0);
const b = signal(0);

const updateA = (value: number) => {
  a(value);
  b(value + 1);  // Explicitly update b when a changes
};
```

### Don't Return Elements from Computeds

Computeds are for deriving primitive valuesâ€”strings, numbers, booleans, objects. They can't return element specs:

```typescript
// âŒ WRONG - computed can't return elements
const content = computed(() => {
  if (showDetails()) {
    return el('div')('Details here');  // Won't work!
  }
  return el('span')('Summary');
});

return el('div')(content);  // Broken
```

For conditional rendering, use `match` instead:

```typescript
// âœ… CORRECT - use match for conditional elements
return el('div')(
  match(showDetails, (show) =>
    show
      ? el('div')('Details here')
      : el('span')('Summary')
  )
);
```

Computeds are for values. `match` is for conditional UI.

---

## Package API Reference

The following sections contain API documentation from each package's README.

---

### @rimitive/core

Simple, minimal Dependency Injection through module composition. Modules declare dependencies and `compose()` wires them together.

Additional features:

- [**fork**](#forkbase-freshmodules) - fresh instances of selected modules, shares everything else
- [**transient**](#transientmodule) - fresh instance per dependent instead of shared singleton
- [**lazy**](#lazymodule) - async module initialization
- [**override**](#overridemodule-replacements) - swap dependencies for testing or configuration
- [**merge**](#mergeservice-additions) - extend context with additional properties

Works standalone or as the foundation for rimitive's reactive system.

## Architecture

This is a **Dependency Injection (DI)** system using the **Composition Root** pattern:

| Concept                   | In @rimitive/core                                                |
| ------------------------- | ---------------------------------------------------------------- |
| **Inversion of Control**  | Modules declare dependencies; they don't instantiate them        |
| **Constructor Injection** | `create(deps)` receives resolved dependencies                    |
| **Composition Root**      | `compose()` is the single place where the object graph is wired  |
| **Scopes**                | Singleton (default), transient, or lazy (async)                  |
| **Transitive Resolution** | Pass only what you need; dependencies are included automatically |
| **Async Support**         | `lazy()` wrapper for modules with async `create()`               |

Think of it like npm for runtime:

```
package.json "dependencies"  â†’  Module declares dependencies
npm install / node_modules   â†’  compose() resolves the graph
import X from 'x'            â†’  deps available by name in create()
```

## Quick Start

```typescript
import { compose, defineModule } from '@rimitive/core';

const Logger = defineModule({
  name: 'logger',
  create: () => ({
    log: (msg: string) => console.log(`[LOG] ${msg}`),
    error: (msg: string) => console.error(`[ERR] ${msg}`),
  }),
});

const Database = defineModule({
  name: 'db',
  dependencies: [Logger],
  create: ({ logger }) => ({
    query: (sql: string) => {
      logger.log(`Executing: ${sql}`);
      return []; // your db logic here
    },
  }),
});

const svc = compose(Database);

svc.db.query('SELECT * FROM users');
// [LOG] Executing: SELECT * FROM users
```

---

## compose(...modules)

Resolves the dependency graph and returns a composed service. Each module is instantiated once and shared (singleton by default).

```typescript
const svc = compose(Logger, Database, Cache);
```

Access modules as properties:

```typescript
svc.logger.log('hi');
svc.db.query('SELECT 1');
```

When you're done, clean up:

```typescript
svc.dispose();
```

---

## defineModule(definition)

Create a module:

```typescript
const Cache = defineModule({
  name: 'cache',
  create: () => {
    const store = new Map();
    return {
      get: (key: string) => store.get(key),
      set: (key: string, value: unknown) => store.set(key, value),
    };
  },
});
```

With dependencies:

```typescript
const UserService = defineModule({
  name: 'users',
  dependencies: [Database, Cache],
  create: ({ db, cache }) => ({
    getUser: (id: string) => {
      const cached = cache.get(id);
      if (cached) return cached;
      const user = db.query(`SELECT * FROM users WHERE id = ${id}`)[0];
      cache.set(id, user);
      return user;
    },
  }),
});
```

Full options:

```typescript
defineModule({
  name: 'myModule',              // becomes property on service
  create: (deps) => impl,        // factory, receives resolved deps
  dependencies: [OtherModule],   // what this module needs
  init: (ctx) => { ... },        // called on creation
  destroy: (ctx) => { ... },     // called on dispose
  instrument: (impl, instr) => impl  // wrap for debugging
});
```

---

## merge(service, additions)

Extend a service with extra properties:

```typescript
const svc = compose(Logger);
const extended = merge(svc, { env: 'production' });

extended.env; // 'production'
extended.logger; // same instance as svc.logger
```

Handy for passing context through a system:

```typescript
const App = (svc) => {
  const config = loadConfig();
  const childSvc = merge(svc, { config });
  return childSvc(Router);
};
```

---

## override(module, replacements)

Swap dependencies without changing the original module. Useful for testing or environment-specific configurations.

```typescript
import { compose, override } from '@rimitive/core';

// Production uses real database
const prodSvc = compose(UserService);

// Testing uses mock database
const MockDB = defineModule({
  name: 'db',
  create: () => ({ query: () => mockData }),
});

const testSvc = compose(override(UserService, { db: MockDB }));
```

Replacements are matched by name. If the replacement has a different name, it's aliased automatically:

```typescript
const FileLogger = defineModule({
  name: 'fileLogger', // Different name
  create: () => ({ log: writeToFile }),
});

// FileLogger is aliased to 'logger' for this composition
compose(override(App, { logger: FileLogger }));
```

---

## transient(module)

Mark a module as transient - each dependent gets a fresh instance instead of sharing a singleton.

```typescript
import { compose, defineModule, transient } from '@rimitive/core';

const Logger = transient(
  defineModule({
    name: 'logger',
    create: () => new Logger(),
  })
);

const ServiceA = defineModule({
  name: 'serviceA',
  dependencies: [Logger],
  create: ({ logger }) => {
    /* unique logger instance */
  },
});

const ServiceB = defineModule({
  name: 'serviceB',
  dependencies: [Logger],
  create: ({ logger }) => {
    /* different logger instance */
  },
});

const svc = compose(ServiceA, ServiceB);
```

Transient modules still share their singleton dependencies:

```typescript
const Config = defineModule({ name: 'config', create: () => loadConfig() });

const Logger = transient(
  defineModule({
    name: 'logger',
    dependencies: [Config],
    create: ({ config }) => new Logger(config),
  })
);

// Each Logger instance shares the same Config
```

---

## fork(base, freshModules)

Create a new composition that shares instances from an existing one, but with fresh instances of specified modules. Useful for per-request contexts, test isolation, or scoped state.

```typescript
import { compose, fork, defineModule } from '@rimitive/core';

const Config = defineModule({ name: 'config', create: () => loadConfig() });
const DbPool = defineModule({ name: 'dbPool', create: () => createPool() });
const DbConnection = defineModule({
  name: 'dbConnection',
  dependencies: [DbPool],
  create: ({ dbPool }) => dbPool.getConnection(),
});

// Long-lived root composition
const root = compose(Config, DbPool, DbConnection);

// Per-request: fresh DbConnection, inherited Config and DbPool
const requestCtx = fork(root, [DbConnection]);

requestCtx.config; // Same instance (inherited from root)
requestCtx.dbPool; // Same instance (inherited from root)
requestCtx.dbConnection; // Fresh instance (not shared with root)

// Cleanup when done - only disposes fresh instances
requestCtx.dispose();
// root is unaffected
```

Fresh modules are:

- **Re-instantiated** - new instance, not shared with the base
- **Singleton within the fork** - shared by dependents in the forked context
- **Independently disposable** - disposing the fork only cleans up its fresh instances

**Rebinding dependencies:** Pass a replacement module with the same name to swap implementations:

```typescript
const MockDb = defineModule({ name: 'db', create: () => mockDb });

// UserService now receives MockDb instead of the original
const testCtx = fork(root, [MockDb, UserService]);
```

---

## lazy(module)

Mark a module with async `create()` as lazy. Lazy modules are awaited during composition, allowing async initialization like database connections or remote config loading.

```typescript
import { compose, defineModule, lazy } from '@rimitive/core';

const DbPool = lazy(
  defineModule({
    name: 'dbPool',
    create: async () => {
      const pool = await createPool();
      await pool.connect();
      return pool;
    },
  })
);

// compose() returns a Promise when lazy modules are present
const svc = await compose(DbPool, UserService);

// After await, everything is resolved - sync access
svc.dbPool.query('SELECT 1');
```

Async modules **must** be wrapped with `lazy()` - you'll get both a type error and runtime error otherwise.

---

## Instrumentation

Add debugging to your modules:

```typescript
import {
  compose,
  createInstrumentation,
  devtoolsProvider,
} from '@rimitive/core';

const svc = compose(Logger, Database, {
  instrumentation: createInstrumentation({
    providers: [devtoolsProvider()],
  }),
});
```

Modules define how they're instrumented:

```typescript
const MyModule = defineModule({
  name: 'myModule',
  create: () => (value) => createImpl(value),
  instrument: (impl, instr) => (value) => {
    const instance = impl(value);
    instr.register(instance, 'myModule');
    return instance;
  },
});
```

---

### @rimitive/signals

Reactive primitives for rimitive. Signals, computeds, effects, and friends.

## Quick Start

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(
  SignalModule,
  ComputedModule,
  EffectModule
);

const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => console.log('Count:', count()));
// logs: "Count: 0"

count(5);
// logs: "Count: 5"
```

---

## signal

Reactive state. Read with `sig()`, write with `sig(value)`.

```typescript
const name = signal('Alice');

name(); // 'Alice'
name('Bob');
name(); // 'Bob'
name.peek(); // read without tracking

const count = signal(0);
count(count() + 1); // read then write

const items = signal<string[]>([]);
items([...items(), 'new']); // spread and append
```

---

## computed

Derived values. Lazy, cached, auto-tracks dependencies.

```typescript
const firstName = signal('Ada');
const lastName = signal('Lovelace');

const fullName = computed(() => `${firstName()} ${lastName()}`);

fullName(); // 'Ada Lovelace'
lastName('Byron');
fullName(); // 'Ada Byron'
```

---

## effect

Side effects when dependencies change. **Synchronous**â€”runs immediately, not next tick.

```typescript
const user = signal({ name: 'Alice', online: false });

effect(() => {
  console.log(`${user().name} is ${user().online ? 'online' : 'offline'}`);
});
// logs: "Alice is offline"

user({ ...user(), online: true });
// logs: "Alice is online"
```

Returns a dispose function:

```typescript
const dispose = effect(() => console.log(count()));
dispose(); // stops tracking
```

### Flush Strategies

By default, effects run synchronouslyâ€”the moment a dependency changes, the effect runs. Sometimes you want to defer execution. That's what flush strategies are for.

```typescript
import { mt, raf, debounce } from '@rimitive/signals/extend';

// Run on next microtask (coalesces rapid updates)
effect(mt(() => console.log(count())));

// Run on requestAnimationFrame (ideal for DOM reads/writes)
effect(raf(() => updateCanvas(data())));

// Run after 300ms of no changes
effect(debounce(300, () => search(query())));
```

| Strategy           | Use case                                                      |
| ------------------ | ------------------------------------------------------------- |
| `mt(fn)`           | Batch multiple synchronous signal updates into one effect run |
| `raf(fn)`          | DOM measurements, canvas rendering, animations                |
| `debounce(ms, fn)` | User input, search boxes, expensive operations                |

Without a strategy, effects are synchronous. Wrap your effect function in a strategy to control timing.

---

## batch

Group updates into a single notification.

```typescript
import { BatchModule } from '@rimitive/signals/extend';

const { signal, effect, batch } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  BatchModule
);

const a = signal(1);
const b = signal(2);

effect(() => console.log(a() + b()));
// logs: 3

batch(() => {
  a(10);
  b(20);
});
// logs: 30 (once, not twice)
```

---

## subscribe

Subscribe without creating a reactive context.

```typescript
import { SubscribeModule } from '@rimitive/signals/extend';

const { signal, subscribe } = compose(SignalModule, SubscribeModule);
const count = signal(0);
const unsubscribe = subscribe(count, (value) => {
  console.log('Count changed to:', value);
});

count(1); // logs: "Count changed to: 1"
unsubscribe();
```

---

## untrack

Read signals without tracking.

```typescript
import { UntrackModule } from '@rimitive/signals/extend';

const { signal, computed, untrack } = compose(
  SignalModule,
  ComputedModule,
  UntrackModule
);

const a = signal(1);
const b = signal(2);

// Only tracks `a`, not `b`
const result = computed(() => a() + untrack(() => b()));

result(); // 3
b(10);
result(); // still 3 (b not tracked)
a(5);
result(); // 15 (recomputes, reads current b)
```

---

## iter

Reactive collection with O(1) mutations. Like a signal, but for lists.

```typescript
import { IterModule } from '@rimitive/signals/extend';

const { signal, computed, effect, iter } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  IterModule
);

type Todo = { id: number; text: string };

const todos = iter<Todo>(
  (todo) => todo.id,
  [
    { id: 1, text: 'Buy milk' },
    { id: 2, text: 'Walk dog' },
  ]
);
```

### Reading (tracks dependency)

```typescript
// Callable - returns array
todos(); // [{ id: 1, ... }, { id: 2, ... }]

// Iterable - works with for...of
for (const todo of todos) {
  console.log(todo.text);
}

// In computed/effect - auto-tracks
const count = computed(() => todos().length);
effect(() => console.log('Todos:', [...todos]));
```

### O(1) Mutations

```typescript
todos.append({ id: 3, text: 'New todo' });
todos.prepend({ id: 0, text: 'First' });
todos.insertAfter(refTodo, newTodo);
todos.insertBefore(refTodo, newTodo);
todos.remove(todo); // by item
todos.remove(1); // by key
todos.update({ id: 1, text: 'Updated' });
todos.clear();
```

### Bulk Replace (with reconciliation)

```typescript
// Callable with array - reconciles efficiently
todos([
  { id: 2, text: 'Walk dog' },
  { id: 3, text: 'New item' },
]);
// Removes id:1, adds id:3, reorders - minimal operations
```

### Lookups

```typescript
todos.get(1); // { id: 1, text: '...' } | undefined
todos.has(1); // true
todos.size; // 2 (reactive)
todos.peek(); // [...] without tracking (like signal.peek())
```

### Why iter?

| Operation   | `signal<T[]>` | `iter<T>` |
| ----------- | ------------- | --------- |
| Append      | O(n) copy     | O(1)      |
| Remove      | O(n) copy     | O(1)      |
| Update item | O(n) copy     | O(1)      |
| Read all    | O(1)          | O(n)      |

Use `iter` when you frequently mutate lists. Use `signal<T[]>` for small, rarely-changed arrays.

---

### @rimitive/view

View layer tooling for rimitive. Elements, lists, conditionals, portals.

## Quick Start

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const { signal, computed, el, mount } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  MountModule
);

const count = signal(0);

const App = () =>
  el('div')(
    el('p')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('Increment')
  );

document.body.appendChild(mount(App()).element!);
```

---

## el

Creates element specs. Specs are inert blueprintsâ€”they become real DOM when mounted.

```typescript
el('div')('Hello');

el('button').props({ disabled: true, className: 'btn' })('Click');

// Reactive props
el('p').props({ textContent: computed(() => `Count: ${count()}`) })();

// Lifecycle via ref
el('input')
  .ref((elem) => elem.focus())
  .ref((elem) => {
    elem.addEventListener('input', handler);
    return () => elem.removeEventListener('input', handler);
  })();
```

Partial application for reusable tags:

```typescript
const div = el('div');
const button = el('button');

const App = () =>
  div.props({ className: 'app' })(
    button.props({ onclick: handleClick })('Submit')
  );
```

---

## map

Reactive lists with keyed reconciliation.

```typescript
import { createMapModule } from '@rimitive/view/map';

const { signal, el, map } = compose(...modules, createMapModule(adapter));

const items = signal([
  { id: 1, text: 'First' },
  { id: 2, text: 'Second' },
]);

// Key function required for objects
map(
  items,
  (item) => item.id,
  (item) => el('li')(computed(() => item().text))
);

// Primitives don't need keys
const tags = signal(['a', 'b', 'c']);
map(tags, (tag) => el('span')(tag));
```

The render callback receives a reactive `item`â€”call `item()` to read.

---

## match

Conditional rendering. Switches views when the reactive value changes.

```typescript
import { createMatchModule } from '@rimitive/view/match';

const { signal, match } = compose(...modules, createMatchModule(adapter));

const tab = signal<'home' | 'settings'>('home');

match(tab, (current) => (current === 'home' ? HomePage() : SettingsPage()));

// Conditional show/hide
const showModal = signal(false);
match(showModal, (show) => (show ? Modal() : null));
```

---

## portal

Renders content into a different DOM location.

```typescript
import { createPortalModule } from '@rimitive/view/portal';

const { portal } = compose(...modules, createPortalModule(adapter));

// Portal to document.body (default)
portal()(el('div').props({ className: 'modal' })('Content'));

// Portal to specific element
portal(() => document.getElementById('tooltips'))(Tooltip());
```

---

## load

Async loading boundaries.

```typescript
import { LoadModule } from '@rimitive/view/load';

const { load, el } = compose(...modules, LoadModule);

load({
  loader: async () => {
    const data = await fetch('/api/data').then((r) => r.json());
    return DataView(data);
  },
  loading: () => el('div')('Loading...'),
  error: (err) => el('div')(`Error: ${err.message}`),
});
```

---

## mount

Creates real DOM from specs.

```typescript
import { MountModule } from '@rimitive/view/deps/mount';

const { mount } = compose(...modules, MountModule);

const ref = mount(App());
document.body.appendChild(ref.element!);

// Cleanup
ref.dispose?.();
```

---

## Adapters

View modules take an adapter for renderer-agnostic operation.

```typescript
// DOM (browser)
import { createDOMAdapter } from '@rimitive/view/adapters/dom';

// Test (no DOM required)
import { createTestAdapter } from '@rimitive/view/adapters/test';

// Custom (Canvas, WebGL, etc.)
import type { Adapter } from '@rimitive/view/adapter';

const myAdapter: Adapter<MyConfig> = {
  createNode: (tag, props) => { ... },
  setAttribute: (element, key, value) => { ... },
  insertBefore: (parent, node, anchor) => { ... },
  removeChild: (parent, node) => { ... },
  createTextNode: (text) => { ... },
  createComment: (text) => { ... },
};
```

---

## Specs vs Elements

**Specs** are dataâ€”inert descriptions of what to render:

```typescript
const spec = el('div')('Hello'); // Just data, no DOM
```

**Elements** are created when specs are mounted:

```typescript
const ref = mount(spec); // Now it's real DOM
document.body.appendChild(ref.element!);
```

This separation enables SSR, testing without a DOM, and composition before mounting.

---

### @rimitive/router

Routing as reactive state. The router provides signals (`matches`, `currentPath`), not renderingâ€”use `match()` from `@rimitive/view` to render.

## Quick Start

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createRouterModule, Link } from '@rimitive/router';

const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
  {
    id: 'products',
    path: 'products',
    children: [{ id: 'product-detail', path: ':id' }],
  },
];

const adapter = createDOMAdapter();

const { router, match, el } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  createMatchModule(adapter),
  createRouterModule(routes)
);
```

---

## Routes

Routes are plain objects with `id`, `path`, and optional `children`. Dynamic segments use `:param`:

```typescript
const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
  {
    id: 'products',
    path: 'products',
    children: [
      { id: 'product-list', path: '' },
      { id: 'product-detail', path: ':id' },
    ],
  },
];
```

---

## Rendering

`router.matches` is a reactive signal of matched routes. Use `match()` to render:

```typescript
const pages = {
  home: () => el('div')('Home Page'),
  about: () => el('div')('About Page'),
  'product-detail': (params) => el('div')(`Product ${params.id}`),
};

const App = () =>
  match(router.matches, (matches) => {
    const route = matches[0];
    if (!route) return el('div')('404 Not Found');

    const Page = pages[route.id];
    return Page ? Page(route.params) : el('div')('Unknown route');
  });
```

For nested routes, `matches` contains the full hierarchy:

```typescript
// URL: /products/123
router.matches();
// [
//   { id: 'products', path: '/products', params: {} },
//   { id: 'product-detail', path: '/products/123', params: { id: '123' } }
// ]
```

---

## Navigation

```typescript
router.navigate('/products/456');
router.back();
router.forward();
```

---

## Link

`Link` renders anchors with client-side navigation:

```typescript
import { Link } from '@rimitive/router';

Link({ href: '/about' })('About Us');
Link({ href: '/products', className: 'nav-link' })('Products');

// Dynamic href
Link({ href: computed(() => `/products/${productId()}`) })('View Product');
```

Modifier keys (Cmd/Ctrl+click) open new tabs. External URLs pass through unchanged.

---

## Location Signals

```typescript
// URL: /products?sort=price&filter=new#section-1

router.pathname(); // '/products'
router.search();   // '?sort=price&filter=new'
router.hash();     // '#section-1'
router.query();    // { sort: 'price', filter: 'new' }
```

---

## SSR

Pass `initialPath` for server-side rendering:

```typescript
const svc = compose(
  ...modules,
  createRouterModule(routes, { initialPath: req.url })
);
```

Works without `window`â€”uses the provided path and skips browser history APIs.

---

### @rimitive/resource

Reactive async data fetching. Automatic dependency tracking, cancellation, and race condition handling.

## Quick Start

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';
import { ResourceModule } from '@rimitive/resource';

const { signal, resource } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  ResourceModule
);

const products = resource((signal) =>
  fetch('/api/products', { signal }).then((r) => r.json())
);

// Full state (discriminated union)
products(); // { status: 'pending' | 'ready' | 'error', ... }

// Convenience accessors
products.loading(); // boolean
products.data(); // T | undefined
products.error(); // unknown | undefined
```

---

## Reactive Dependencies

Read signals inside the fetcher. Changes trigger automatic refetch with cancellation:

```typescript
const categoryId = signal(1);

const products = resource((signal) =>
  fetch(`/api/products?category=${categoryId()}`, { signal }).then((r) =>
    r.json()
  )
);

// Initial fetch: /api/products?category=1

categoryId(2);
// Aborts previous request, fetches /api/products?category=2
```

The fetcher receives an `AbortSignal`â€”pass it to `fetch()` for automatic cancellation when dependencies change or on dispose.

---

## Manual Control

```typescript
// Refetch after a mutation
await saveProduct(newProduct);
products.refetch();

// Cleanup (aborts in-flight request)
products.dispose();
```

In components, dispose via ref cleanup:

```typescript
const ProductList = () => {
  const products = resource((signal) =>
    fetch('/api/products', { signal }).then((r) => r.json())
  );

  return el('div').ref(() => () => products.dispose())();
  // ... render products
};
```

---

## Rendering

Use `match()` to render different states:

```typescript
const ProductList = () =>
  match(products, (state) => {
    switch (state.status) {
      case 'pending':
        return el('div')('Loading...');
      case 'error':
        return el('div')(
          `Error: ${state.error}`,
          el('button').props({ onclick: () => products.refetch() })('Retry')
        );
      case 'ready':
        return el('ul')(
          map(
            state.value,
            (p) => p.id,
            (product) => el('li')(computed(() => product().name))
          )
        );
    }
  });
```

---

### @rimitive/ssr

Server-side rendering and hydration. Effects are synchronous and run on the serverâ€”your reactive code works the same in both environments.

## Quick Start

### Server

```typescript
import { createServer } from 'node:http';
import {
  createParse5Adapter,
  renderToStringAsync,
} from '@rimitive/ssr/server';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } =
    createParse5Adapter();
  const service = createService(adapter);

  const html = await renderToStringAsync(App(service), {
    svc: service,
    mount: (spec) => spec.create(service),
    serialize,
    insertFragmentMarkers,
  });

  const loaderData = service.loader.getData();

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`
    <!DOCTYPE html>
    <html>
    <head>
      <script>window.__LOADER_DATA__ = ${JSON.stringify(loaderData)}</script>
    </head>
    <body>
      <div class="app">${html}</div>
      <script src="/client.js"></script>
    </body>
    </html>
  `);
});

server.listen(3000);
```

### Client

```typescript
import { createClientAdapter } from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

const adapter = createClientAdapter(document.querySelector('.app')!);
const ssrData = window.__LOADER_DATA__;
const service = createService(adapter, { hydrationData: ssrData });

App(service).create(service);
adapter.activate(); // Switch to normal DOM mode
```

---

## Shared Service

Your service factory takes an adapter, so server and client use the same components:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: { hydrationData?: Record<string, unknown>; onResolve?: (id: string, data: unknown) => void }
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    createLoaderModule({
      initialData: options?.hydrationData,
      onResolve: options?.onResolve,
    })
  );
}
```

---

## Loading Data

`load()` creates async boundaries. The `id` is how the client matches server-rendered data during hydration:

```typescript
const UserProfile = (svc: Service) => {
  const { loader, match, el } = svc;

  return loader.load(
    'user-profile', // ID for hydration
    () => fetch('/api/user').then((r) => r.json()),
    (state) =>
      match(state.status, (status) => {
        switch (status) {
          case 'pending':
            return el('div')('Loading...');
          case 'error':
            return el('div')(`Error: ${state.error()}`);
          case 'ready':
            return el('div')(
              el('h1')(state.data()!.name),
              el('p')(state.data()!.email)
            );
        }
      })
  );
};
```

---

## Streaming

Send HTML immediately, stream data as it loads:

### Server

```typescript
import {
  createParse5Adapter,
  renderToStream,
  createStreamWriter,
} from '@rimitive/ssr/server';

const stream = createStreamWriter('__APP_STREAM__');

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } =
    createParse5Adapter();

  const service = createService(adapter, {
    onResolve: (id, data) => {
      res.write(`<script>${stream.chunkCode(id, data)}</script>`);
    },
  });

  const { initialHtml, done } = renderToStream(App(service), {
    mount: (spec) => spec.create(service),
    serialize,
    insertFragmentMarkers,
  });

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.write(`<!DOCTYPE html>
<html>
<head><script>${stream.bootstrapCode()}</script></head>
<body>
  <div class="app">${initialHtml}</div>
  <script src="/client.js"></script>`);

  await done;
  res.end('</body></html>');
});
```

### Client

```typescript
import { createClientAdapter, connectStream } from '@rimitive/ssr/client';

const adapter = createClientAdapter(document.querySelector('.app')!);
const service = createService(adapter);

App(service).create(service);
adapter.activate();
connectStream(service, '__APP_STREAM__');
```

---

## Browser-Only Code

Effects and refs run on the server. Guard browser-specific code:

```typescript
el('input').ref((el) => {
  if (typeof window === 'undefined') return;
  el.focus();
})();
```

**Needs guards:** `focus()`, `blur()`, `scrollIntoView()`, `getBoundingClientRect()`, `window`, `localStorage`

**Works without guards:** Event handlers (`onclick`), basic DOM properties (`className`, `textContent`)

---

## Package Reference

- [@rimitive/core](https://github.com/hejhi/rimitive/tree/main/packages/rimitive): Core composition (`compose`, `defineModule`, `merge`)
- [@rimitive/signals](https://github.com/hejhi/rimitive/tree/main/packages/signals): Reactive core (`signal`, `computed`, `effect`, `batch`)
- [@rimitive/view](https://github.com/hejhi/rimitive/tree/main/packages/view): View layer (`el`, `map`, `match`, `portal`, `load`)
- [@rimitive/router](https://github.com/hejhi/rimitive/tree/main/packages/router): Reactive routing (`matches`, `navigate()`, `query`)
- [@rimitive/resource](https://github.com/hejhi/rimitive/tree/main/packages/resource): Async data fetching with `resource()`
- [@rimitive/ssr](https://github.com/hejhi/rimitive/tree/main/packages/ssr): Server-side rendering and streaming
- [@rimitive/react](https://github.com/hejhi/rimitive/tree/main/packages/react): React bindings
