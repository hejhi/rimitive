# Rimitive - Complete Documentation

> A set of composable libraries for TypeScript. Compose signals, views, and behaviors into applications with fine-grained reactivity.

This document contains the complete Rimitive documentation for LLM consumption.

---

## Project Overview (README)

Rimitive is a set of composable libraries that provide:

- **reactive primitives** for state, views, routing, and async data
- **a composition system** to wire together only what you need
- **adapters and integrations** for DOM, SSR, React, and more

Rimitive uses the primitive construct with a tiny but powerful compositional library so you **avoid as much up-front commitment as possible**. You can start with just signals and computeds in your vanilla js app or reactive framework as you prototype, pulling in more Rimitive as you need (or not). The goal of Rimitive is to blend into your architecture, and allow you to easily package and re-use micro reactive services tailored to your needs.

The primitives:

- [`@rimitive/signals`](packages/signals): primitives for state management
- [`@rimitive/view`](packages/view): primitives for composing a reactive UI
- [`@rimitive/resource`](packages/resource): primitive for async data

The composition core:

- [`@rimitive/core`](packages/core): a strongly typed composition system that can be used outside of rimitive altogether

Additional packages provide [routing](https://rimitive.dev/guides/adding-routing/), [SSR](https://rimitive.dev/guides/server-rendering/), React bindings, and devtools. You can also [design your own modules](https://rimitive.dev/guides/custom-modules/).

No build or transpilation required. Everything tree-shakes.

---

Here is the most basic setup of rimitive:

```ts
import { compose } from '@rimitive/core';
import { SignalModule } from '@rimitive/signals/extend';

// `compose()` returns your reactive service
const { signal } = compose(SignalModule);
```

Add a computed to your reactive service:

```ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';

// All wiring happens under the hood, as part of the module/service system. But you can
// customize or define your own modules, tapping directly into the reactive graph
// (or even replacing it if you want!)
const { signal, computed } = compose(SignalModule, ComputedModule);
```

Compose your own tiny, performant reactive services tailored to your use cases. This pattern scales all the way to the most complex use cases you can imagine.

With the ability to define your own modules, you can even create your own reactive primitives to work with or replace Rimitives! ðŸŽ¶

---

In addition to the above, Rimitive does not prescribe ways to use primitives, but rather provides framework-agnostic **patterns, conventions, and mental models** for building performant, lean, ergonomic, and scalable reactive applications.

For instance, Rimitive provides patterns for creating components and headless components (or behaviors), but there's no capital-C components or magical reactive closures like you would find in most reactive frameworks. Reactivity lives entirely within the primitives.

Patterns and architectures in Rimitive focus on **low coupling, high cohesion**â€”focusing on keeping reactive logic self-contained and portable. Test behaviors without rendering, swap components without touching logic, and share behaviors across frameworks and environments.

Additionally:

- **No VDOM**: fine-grained updates directly to the DOM
- **Minimal reconciliation**: only primitives that need reconciliation have it
- **No global state**: each `compose()` creates an isolated reactive context, making it safe for React concurrency or usage on the server.

ðŸ“š **[Full documentation at rimitive.dev](https://rimitive.dev)**

---

## Packages

| Package                                                       | Description                                                                                                           |
| ------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| [`@rimitive/core`](packages/core)                             | Composition engine â€” `compose()`, `defineModule()`                                                                    |
| [`@rimitive/signals`](packages/signals)                       | Reactive primitives â€” `signal`, `computed`, `effect`, `batch`                                                         |
| [`@rimitive/view`](packages/view)                             | UI primitives â€” `el`, `map`, `match`, `portal`, `load`                                                                |
| [`@rimitive/router`](packages/router)                         | Reactive routing â€” `matches`, `navigate()`, `query`                                                                   |
| [`@rimitive/resource`](packages/resource)                     | Async data fetching with `resource()`                                                                                 |
| [`@rimitive/ssr`](packages/ssr)                               | Server-side rendering and streaming                                                                                   |
| [`@rimitive/react`](packages/react)                           | React bindings                                                                                                        |
| [`@rimitive/devtools-extension`](packages/devtools-extension) | Chrome DevTools extension ([download](https://github.com/hejhi/rimitive/releases?q=devtools-extension&expanded=true)) |

---

## Using Rimitive Primitives

Yes, "Rimitive primitive" sounds ridiculous.

Anyway, here's a slightly larger example, with view primitives and a DOM adapter!

```typescript
import { compose } from '@rimitive/core';
import {
  SignalModule,
  ComputedModule,
  EffectModule,
} from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { MountModule } from '@rimitive/view/deps/mount';

const { signal, computed, el, mount } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(createDOMAdapter()), // Provide the DOM adapter to the view primitive
  MountModule
);
```

> Note: primitives are environment-agnostic, so some modules (like `createElModule`) take an adapter. Rimitive provides DOM, SSR, and hydration adaptersâ€”or write your own!

Now that you have a reactive service, you can use it however you'd like:

```typescript
// Note: this might _look_ like a capital-c Component, but it's not a magically reactive closure!
// This means no "re-rendering"â€”it mounts or unmounts. Das it.
const App = () => {
  const count = signal(0);

  return el('div')(
    el('p').props({ textContent: computed(() => `Count: ${count()}`) }),
    el('button').props({ onclick: () => count(count() + 1) })('Increment')
  );
};

document.body.appendChild(mount(App()).element!);
```

The component itself doesn't re-render, and neither does `el`â€”the element structure is created **once**. Only reactive props and text children update via fine-grained effects that target exactly one DOM property or text node (for reactive DOM structure, you can use primitives like [`map` and `match`](https://rimitive.dev/guides/rendering-lists/)).

That's about all there is to using rimitive! The rest is all about choosing the primitives and patterns you want to useâ€”check out the [guides](https://rimitive.dev/guides/getting-started/) and [API reference](https://rimitive.dev/api/).

---

## Extensibility

Want to:

- **Create custom modules?** Use [`defineModule()`](https://rimitive.dev/guides/custom-modules/) with the same patterns rimitive uses internally
- **Swap out the reactive system?** Replace the dependency modules with your own (or someone else's), or even swap out entire primitives for something else
- **Build a custom adapter/renderer?** Implement the `Adapter` interface for Canvas, WebGL, or anything tree-based
- **Add instrumentation?** Compose with `createInstrumentation()` for debugging; instrumentation is first-class in rimitive

Rimitive provides modules for reactivity and UI out of the box, but they're not special. In fact, they're built with the same tools rimitive provides to you. Rimitive at its core is a simple, type-safe composition pattern, so it can be used for creating lots of tools, not just reactive frameworks.

---

## Claude Code Plugins

If you use [Claude Code](https://claude.ai/code), these plugins teach Claude how to write idiomatic rimitive code:

| Plugin                                           | Description                                                      |
| ------------------------------------------------ | ---------------------------------------------------------------- |
| [`rimitive-behavior`](plugins/rimitive-behavior) | Create headless behaviors â€” portable reactive logic without UI   |
| [`rimitive-compose`](plugins/rimitive-compose)   | Help composing services with the right modules and imports       |
| [`rimitive-module`](plugins/rimitive-module)     | Create custom modules with `defineModule()`                      |
| [`rimitive-view`](plugins/rimitive-view)         | Build views with `el`, `map`, `match`, and other view primitives |
| [`rimitive-adapter`](plugins/rimitive-adapter)   | Create custom adapters for Canvas, WebGL, or other renderers     |

Install via Claude Code: `/install-plugin github:hejhi/rimitive/plugins/<plugin-name>`

---

## Inspirations

Rimitive draws from libraries and ideas by _brilliant_ people that have shaped how I think about reactivity and composition, and what I want in my nerd life:

- [alien-signals](https://github.com/stackblitz/alien-signals) and [reactively](https://github.com/milomg/reactively) â€” push-pull reactivity, graph coloring
- [downshift](https://www.downshift-js.com/use-select/) â€” headless, portable UI behavior
- [jotai](https://jotai.org/docs/core/atom) â€” atoms as configs, not values
- [ProseMirror](https://prosemirror.net) â€” extensibility and determinism

---

## Why Rimitive?

The story behind Rimitiveâ€”the impetus, how it started, how it's going: [Why Rimitive?](https://rimitive.dev/why/)

---

## Status

Alpha. Tested, benchmarked, used in personal projects, _not_ battle-tested in production yet.


---

## Getting Started

Rimitive is built for **progressive complexity** and **low up-front commitment**. Start with just signals in a vanilla TS file. Months later, you might have a full app with routing, SSR, and streamingâ€”without rewrites, migrations, or a "now we need a real framework" moment.

Compose only the primitives you need, opting in as you go!

In fact, rimitive is as much about providing **scalable patterns, conventions, and mental models** for building performant, lean, ergonomic, and scalable reactive applications as it is about providing the actual reactive primitives and tooling you need to do it.

Rimitive also has a transparent architecture. You can literally replace or extend any part of it with your own custom-built tooling, at any point in time, down to the core reactive graph if you really wanted to.

Patterns and architectures in rimitive are designed for **low coupling, high cohesion**â€”your reactive logic is self-contained and reusable, your UI just consumes it and has its own ui-specific logic if needed. Test behaviors without rendering, swap components without touching logic, share behaviors across frameworks, compose and share accessible patterns across your UIs.

- **It's a collection of reactive libraries, not a framework** â€” take only what you need, as you need it!
- **No VDOM** â€” fine-grained updates directly to the DOM
- **No global state** â€” each `compose()` creates an isolated reactive context

---

## Installation

```bash
npm install @rimitive/core @rimitive/signals @rimitive/view
```

## Your First App

Create a counter with reactive state and DOM rendering:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

// 1. Create the adapter
const adapter = createDOMAdapter();

// 2. Compose your service
const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  MountModule
);

// 3. Destructure the primitives
const { signal, computed, el, mount } = svc;

// 4. Create reactive state
const count = signal(0);
const doubled = computed(() => count() * 2);

// 5. Build the UI
const App = () =>
  el('div')(
    el('h1')('Counter'),
    el('p')(computed(() => `Count: ${count()}`)),
    el('p')(computed(() => `Doubled: ${doubled()}`)),
    el('button').props({
      onclick: () => count(count() + 1)
    })('Increment')
  );

// 6. Mount it
const app = mount(App());
document.body.appendChild(app.element!);
```

That's it. Click the button, the count updates, the DOM updates automatically.

## What Just Happened?

1. **`compose()`** wires modules together into a service
2. **`signal()`** creates reactive state â€” read with `count()`, write with `count(newValue)`
3. **`computed()`** derives values that update when dependencies change
4. **`el()`** creates DOM elements with reactive children and props
5. **`mount()`** attaches the element tree to the DOM

---

## Creating a Service

Here's the simplest Rimitive setup:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule);
const { signal } = svc;
```

`compose()` takes primitive modules and returns a reactive service with only the primitives you asked for.

---

## Adding More Primitives

Need more primitives? Add them!

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(SignalModule, ComputedModule, EffectModule);
```

Then use them:

```typescript
const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => {
  console.log('Count is now:', count());
});

// ...etc
```

---

## Why Compose?

You might wonder: why not just export these functions directly?

Each `compose()` call creates an independent reactive context with no global leakage. This means:

- **Isolation** â€” Multiple services don't interfere with each other
- **Testing** â€” Fresh contexts per test, no cleanup needed
- **Tree-shaking** â€” Only bundle what you use
- **Extensibility** â€” Add [view modules](/guides/adding-a-ui), [router](/guides/adding-routing), or [custom modules](/guides/custom-modules) later

---

## Using a Service

Once you've [created a service](/guides/creating-a-service), there are a few ways to use it.

---

## Top-Level

You can safely destructure anything in rimitive from a service, so it's common to do this:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(SignalModule, ComputedModule, EffectModule);
const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => {
  console.log(count(), doubled());
});
```

Great for simple scripts or when you only need a single service. In rimitive, it's also common to export the service as well as the service type directly, which comes in handy _a lot_:

```typescript
// myService.ts

export const svc = compose(SignalModule, ComputedModule, EffectModule);
export const { signal, computed, effect, batch, el, mount } = svc;
export type Service = typeof svc;
```

---

## In a Function

rimitive makes heavy usage of plain factory functions that encapsulate bits of reactive behavior, like:

```typescript
import { signal } from './myService.ts'

const myCounter = () => {
  const count = signal(0);
  const increment = () => count(count() + 1);

  return { count, increment };
};

const counter = myCounter();
counter.increment();
counter.count(); // 1
```

The above is simply a factory that instantiates reactive state and returns an api to drive it. In rimitive, this pattern is called a ["behavior"](/guides/creating-a-behavior), which is conventionally prefixed with `use*` for clarity (ie `useCounter` instead of `myCounter`).

You can stop right here, if that's all you need! But if you want to actually drive a reactive ui with state (a "component"), rimitive has primitives and patterns to help you with that too. Next up though, let's talk about the [behavior pattern](/guides/creating-a-behavior).

---

## Adding a UI

You have signals, and maybe some behaviors, so perhaps now we want to add a reactive UI on top of it.

rimitive provides the `view` package that contains view-specific primitives, with `el()` being the foundation. `el()` is a function for creating elements. It's renderer-agnostic (DOM, native, canvas, whatever), but we'll use the DOM adapter here since that's probably the most common use case.

---

## Extending the Service

Add the view modules to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

export const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // Let's add the `el` and `mount` primitives from the `view` package, and provide the
  // DOM adapter to make DOM elements
  createElModule(createDOMAdapter()),
  MountModule
);
export const { signal, computed, effect, el, mount } = svc;
export type Service = typeof svc;
```

Same pattern as before, just now with more modules!

---

## Creating Elements

`el()` is curried: `el(tag)(children)`. Don't be scurred, it'll make sense:

```typescript
// Just a div tag
const div = el('div')();

// An h1 with text
const heading = el('h1')('Hello, World');

// a div with children
const container = el('div')(
  el('h1')('Title'),
  el('p')('Some text')
);
```

---

## Props

Use `.props()` to set reactive attributes and events:

```typescript
const isDisabled = signal(false);

const button = el('button').props({
  className: 'primary',
  disabled: isDisabled,
  onclick: () => console.log('clicked'),
})('Click me');

isDisabled(true);  // button becomes disabled, class changes
```

Props are typesafe and typed based on the element. `el('button')` knows about `disabled`, `onclick`, `type`, etc. These types are driven by the adapter provided, so for the DOM you get things like `button`, whatever, but swap it out or customize the adapter and then you can get all sorts of other things, like custom elements, svg or canvas abstractions, hydration abstractions...whatever you want really.

---

## Reactive Content

Pass a computed for reactive text:

```typescript
const count = signal(0);

const display = el('div')(
  computed(() => `Count: ${count()}`)
);

count(5);  // display updates to "Count: 5"
```

---

## UI Components

the star of the show, UI components in rimitive are...just functions that return elements:

```typescript
const Greeting = (name: string) =>
  el('div')(
    el('h2')(`Hello, ${name}!`),
    el('p')('Welcome to Rimitive.')
  );

const app = el('div')(
  Greeting('Ada'),
  Greeting('Grace')
);
```

That's it, kind of anticlimactic.

---

## With Behaviors

Drive UIs with reactive behavior:

```typescript
import { svc, el, computed } from './service';
import { useCounter } from './behaviors/counter';

const Counter = (initial: number) => {
  const { count, doubled, increment, decrement, reset } = useCounter(initial);

  return el('div')(
    el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),
    el('div')(
      el('button').props({ onclick: decrement })('-'),
      el('button').props({ onclick: increment })('+'),
      el('button').props({ onclick: reset })('Reset')
    )
  );
};

const app = el('div')(
  Counter(0),
  Counter(100)
);
```

Again, `Counter` itself is not a reactive closure. It's not going to re-render. But it's quite nice in a way, isn't it? all your reactive behavior and logic contained in behavior functions, then using the api returned to drive UI specific logic?

But wait, there's more!

---

## Portable Components

Just like behaviors, components can be made portable by wrapping them in a function that receives the service:

```typescript
import type { Service } from './service';
import { counter } from './behaviors/counter';

const Counter = (svc: Service) => {
  const { el, computed } = svc;

  // The service layer is so cyute isn't it??
  const useCounter = svc(counter);

  return (initial: number) => {
    const { count, doubled, increment, decrement, reset } = useCounter(initial);

    return el('div')(
      el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),
      el('div')(
        el('button').props({ onclick: decrement })('-'),
        el('button').props({ onclick: increment })('+'),
        el('button').props({ onclick: reset })('Reset')
      )
    );
  };
};
```

Same shape as portable behaviors: `(svc) => (args) => result`. The outer function is the service layer, the inner function is the component factory.

```typescript
import { svc } from './service';

const CounterComponent = svc(Counter);

const app = el('div')(
  CounterComponent(0),
  CounterComponent(100)
);
```

Can you see what's coming?? Components compose other components in the service layer:

```typescript
import type { Service } from './service';
import { counter } from './behaviors/counter';
import { Counter } from './Counter';

const Dashboard = (svc: Service) => {
  const { el } = svc;

  // Compose the Counter component in the service layer
  const CounterComponent = svc(Counter);

  return () =>
    el('div')(
      el('h1')('Dashboard'),
      el('div')(
        el('label')('Users: '),
        CounterComponent(0)
      ),
      el('div')(
        el('label')('Sessions: '),
        CounterComponent(100)
      )
    );
};
```

The service layer is where you wire up your dependenciesâ€”behaviors, other components, whatever you need. Then the inner function just uses them.

This is useful for testing, SSR, or sharing components across different service contexts.

---

## Mounting

Use `mount()` to actually attach to the DOM:

```typescript
const App = () => el('div')(
  el('h1')('My App')
);

const app = mount(App());
document.body.appendChild(app.element!);
```

---

## Conditional Rendering

`match()` swaps elements based on a reactive value. When the value changes, the old element is disposed and a new one takes its place.

---

## Adding the Module

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  createMatchModule(adapter),
  MountModule
);

const { el, match, signal, mount } = svc;
```

---

## Show/Hide

Toggle visibility by returning `null`:

```typescript
const showMessage = signal(true);

const message = match(showMessage, (show) =>
  show ? el('div')('Hello!') : null
);

const app = el('div')(
  el('button').props({
    onclick: () => showMessage(!showMessage())
  })('Toggle'),
  message
);
```

---

## Switching Views

Switch between different element types:

```typescript
const isEditMode = signal(false);
const text = signal('Click edit to change');

const content = match(isEditMode, (editing) =>
  editing
    ? el('input').props({ value: text })()
    : el('span')(text)
);

const app = el('div')(
  content,
  el('button').props({
    onclick: () => isEditMode(!isEditMode())
  })(
    computed(() => isEditMode() ? 'Save' : 'Edit')
  )
);
```

---

## Multi-Way Switch

Use a discriminated value for multiple branches:

```typescript
type Tab = 'home' | 'settings' | 'profile';
const currentTab = signal<Tab>('home');

const tabContent = match(currentTab, (tab) => {
  switch (tab) {
    case 'home': return el('div')('Welcome home');
    case 'settings': return el('div')('Settings panel');
    case 'profile': return el('div')('Your profile');
  }
});
```

---

## Next Steps

- [Rendering Lists](/guides/rendering-lists) â€” Efficient list rendering with `map()`
- [Portals](/guides/portals) â€” Render to different DOM locations

---

## Rendering Lists

`map()` renders a reactive list efficiently (_very efficiently_). When items change, it updates only what's necessary. `map()` contains ONLY the reconciliation logic required to deal with rendering dynamic lists efficiently, so again, a small bundle addition.

---

## Adding the Module

First, add the map module to your service:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMapModule } from '@rimitive/view/map';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  // map takes an adapter as well
  createMapModule(adapter),
  MountModule
);

const { el, map, signal, mount } = svc;
```

### Basic Usage

For primitive arrays (strings, numbers), just pass the array and a render function:

```typescript
const items = signal(['Apple', 'Banana', 'Cherry']);

const list = el('ul')(
  map(items, (item) => el('li')(item))
);
```

The render function receives a **reactive signal** wrapping each item. You can pass it directly as a child:

```typescript
map(items, (item) =>
  el('li')(item)  // item is a signal, cool!
)
```

When `items` updates, `map()` reconciles the DOM efficiently, adding, removing, and reordering elements as needed.

### Keyed Lists

For object arrays, provide a key function so `map()` can track identity:

```typescript
type Todo = { id: number; text: string; done: boolean };

const todos = signal<Todo[]>([
  { id: 1, text: 'Learn Rimitive', done: false },
  { id: 2, text: 'Build something', done: false },
]);

const list = el('ul')(
  map(
    todos,
    (todo) => todo.id,  // key function
    (todo) => el('li')(
      el('span')(computed(() => todo().text)),
      el('input').props({
        type: 'checkbox',
        checked: computed(() => todo().done),
      })()
    )
  )
);
```

The key function receives the plain item value and returns a unique identifier. This lets `map()` efficiently update items when the array changes. I tried so hard to get away without using keys but I'm not smart enough so key functions there shall remain.

### Reactive Item Updates

Each item is wrapped in a signal. When you update an item in the source array, the item signal updates tooâ€”no element recreation needed:

```typescript
const toggleTodo = (id: number) => {
  todos(todos().map(t =>
    t.id === id ? { ...t, done: !t.done } : t
  ));
};

// The checkbox updates reactively without recreating the <li>
```

---

## Portals

`portal()` renders content into a different DOM locationâ€”useful for modals, tooltips, and overlays that need to escape their parent's overflow or z-index context.

---

## Adding the Module

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createPortalModule } from '@rimitive/view/portal';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  createMatchModule(adapter),
  createPortalModule(adapter),
  MountModule
);

const { el, match, portal, signal, mount } = svc;
```

---

## Basic Portal

Render to `document.body` (the default):

```typescript
const showModal = signal(false);

const modal = match(showModal, (show) =>
  show
    ? portal()(
        el('div').props({ className: 'modal-backdrop' })(
          el('div').props({ className: 'modal' })(
            el('h2')('Modal Title'),
            el('p')('Modal content here...'),
            el('button').props({
              onclick: () => showModal(false)
            })('Close')
          )
        )
      )
    : null
);

const app = el('div')(
  el('button').props({
    onclick: () => showModal(true)
  })('Open Modal'),
  modal  // Rendered to body, not inside this div
);
```

---

## Custom Target

Portal to a specific element:

```typescript
// Portal to a getter
portal(() => document.getElementById('tooltip-root'))(
  el('div').props({ className: 'tooltip' })('Tooltip content')
)
```

Or use a signal ref:

```typescript
const targetRef = signal<HTMLElement | null>(null);

el('div').ref((el) => {
  targetRef(el);
  return () => targetRef(null);
})();

portal(targetRef)(tooltipContent)
```

---

## Next Steps

- [Rendering Lists](/guides/rendering-lists) â€” Efficient list rendering with `map()`
- [Conditional Rendering](/guides/conditional-rendering) â€” Show/hide and switch views with `match()`

---

## Event Handling

You've seen `onclick` in props. That works for simple cases. For more complex event handlingâ€”multiple listeners, automatic cleanup, batched updatesâ€”use `on()`.

---

## Basic Props Events

For simple click handlers, props work fine:

```typescript
const count = signal(0);

el('button').props({
  onclick: () => count(count() + 1)
})('Click me')
```

This attaches the handler directly to the element. Simple and direct.

---

## The on() Helper

`on()` provides automatic cleanup and batching. When multiple signals update in a handler, batching ensures only one re-render.

Add the on module:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule, BatchModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { OnModule } from '@rimitive/view/deps/addEventListener';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  BatchModule,
  createElModule(adapter),
  OnModule,
  MountModule
);

const { el, on, signal, mount } = svc;
```

### Using on() with .ref()

`on()` returns a lifecycle callback for use with `.ref()`:

```typescript
const count = signal(0);

const button = el('button').ref(
  on('click', () => count(count() + 1))
)('Click me');
```

When the element is removed from the DOM, the listener is automatically cleaned up.

### Multiple Listeners

Stack multiple `on()` calls:

```typescript
const input = el('input')
  .ref(
    on('focus', () => console.log('focused')),
    on('blur', () => console.log('blurred')),
    on('input', (e) => handleInput(e))
  )();
```

Each listener is independently attached and cleaned up.

---

## Input Handling

A common patternâ€”controlled inputs with `on()`:

```typescript
const text = signal('');

const input = el('input')
  .props({
    type: 'text',
    value: text,
  })
  .ref(
    on('input', (e) => text((e.target as HTMLInputElement).value))
  )();
```

The `value` prop binds the input's value to the signal. The `on('input')` handler updates the signal when the user types.

### Form Submission

Handle Enter key and form submission:

```typescript
const searchQuery = signal('');

const handleSubmit = () => {
  console.log('Searching for:', searchQuery());
  // perform search...
};

const searchInput = el('input')
  .props({
    type: 'text',
    placeholder: 'Search...',
    value: searchQuery,
  })
  .ref(
    on('input', (e) => searchQuery((e.target as HTMLInputElement).value)),
    on('keydown', (e) => {
      if (e.key === 'Enter') handleSubmit();
    })
  )();

const searchButton = el('button').ref(
  on('click', handleSubmit)
)('Search');
```

---

## Automatic Batching

When a handler updates multiple signals, `on()` batches them into a single update:

```typescript
const firstName = signal('');
const lastName = signal('');
const loading = signal(false);

const handleSubmit = () => {
  // All three updates batched into one render
  firstName('');
  lastName('');
  loading(true);
};

el('button').ref(
  on('click', handleSubmit)
)('Submit')
```

Without batching, this would trigger three separate re-renders. With `on()`, it's one.

### Why Batching Matters

Consider a form with derived state:

```typescript
const firstName = signal('John');
const lastName = signal('Doe');
const fullName = computed(() => `${firstName()} ${lastName()}`);

// Display updates once, not twice
el('button').ref(
  on('click', () => {
    firstName('Jane');
    lastName('Smith');
  })
)('Change Name')
```

The `fullName` computed only recalculates once after both signals update.

---

## Event Options

Pass standard addEventListener options as the third argument:

```typescript
// Capture phase
on('click', handler, { capture: true })

// Once only
on('click', handler, { once: true })

// Passive (for scroll performance)
on('scroll', handler, { passive: true })
```

---

## When to Use What

**Use props (`onclick`, `oninput`, etc.) when:**
- Simple, single handler
- No need for cleanup management
- Handler updates one signal

**Use `on()` when:**
- Multiple listeners on one element
- Handler updates multiple signals (batching)
- Need explicit cleanup
- Using event options (capture, passive, once)

Both are valid. Props are simpler; `on()` is more powerful.

---

## A Complete Example

A search form with debounced input:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule, BatchModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { OnModule } from '@rimitive/view/deps/addEventListener';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();
const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  BatchModule,
  createElModule(adapter),
  createMatchModule(adapter),
  OnModule,
  MountModule
);

const { el, match, on, signal, computed, effect, mount } = svc;

// State
const query = signal('');
const results = signal<string[]>([]);
const loading = signal(false);

// Debounced search
let debounceTimer: number;
const debouncedSearch = (q: string) => {
  clearTimeout(debounceTimer);
  if (!q.trim()) {
    results([]);
    return;
  }

  loading(true);
  debounceTimer = setTimeout(() => {
    // Simulate API call
    const mockResults = ['Apple', 'Banana', 'Cherry', 'Date']
      .filter(item => item.toLowerCase().includes(q.toLowerCase()));

    // Batched update
    results(mockResults);
    loading(false);
  }, 300);
};

// Watch query changes
effect(() => {
  debouncedSearch(query());
});

// App
const App = () => el('div').props({ className: 'search-app' })(
  el('h1')('Search'),

  // Search input
  el('input')
    .props({
      type: 'text',
      placeholder: 'Type to search...',
      value: query,
    })
    .ref(
      on('input', (e) => query((e.target as HTMLInputElement).value)),
      on('keydown', (e) => {
        if (e.key === 'Escape') query('');
      })
    )(),

  // Loading indicator
  match(loading, (isLoading) =>
    isLoading ? el('div').props({ className: 'loading' })('Searching...') : null
  ),

  // Results
  el('ul')(
    ...[] // Would use map() here for dynamic results
  ),

  // Result count
  el('div').props({ className: 'count' })(
    computed(() => {
      const r = results();
      return r.length === 0
        ? 'No results'
        : `${r.length} result${r.length === 1 ? '' : 's'}`;
    })
  )
);

const app = mount(App());
document.body.appendChild(app.element!);
```

Event handling, batching, cleanupâ€”all handled. Next: [Loading Data](/guides/loading-data) for async data fetching.

---

## Creating a Behavior

A **behavior** is, like many things in rimitive, simply a pattern. It's a function that encapsulates reactive state, with actions to drive that state, into a reusable unit. Again, no UI or component framework, just a nice convention to provide portable reactive logic.

---

## The Simple Approach

The easiest way to create a behavior is to import primitives directly from your service:

```typescript
// behaviors/useCounter.ts
import { signal, computed } from '../service';

// Again, use* is just a convention, this is not prescribed and not React!
export const useCounter = (initial = 0) => {
  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

Use it anywhere:

```typescript
import { useCounter } from './behaviors/useCounter';

const counter = useCounter(10);
counter.increment();
counter.count();  // 11
```

This works great for simple cases. The behavior is tied to your service, which is fine when you have a single app context.

---

## The Portable Pattern

When you need behaviors that work across different contextsâ€”testing with mocks, sharing between apps, or SSRâ€”use the portable pattern.

### The Shape

```typescript
// Remember how we exported `typeof svc` in the previous guide example?
import type { Service } from './service';

// The "portable" pattern is...just wrapping your behavior in an outer
// function that injects the service
const myPortableBehavior = (svc: Service) => (options?) => {
  // Create state
  // Return API
};
```

This silly little pattern doesn't look like much but opens up a whole world of fun possibilities. So from now on, we'll be working with portable functions.

### A Counter Example

```typescript
import type { Service } from './service';

const counter = ({ signal, computed }: Service) => (initial = 0) => {
  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

### Using It

```typescript
import { svc } from './service';

// Oh look! svc itself is callable and injects the svc for you! Neat!
const useCounter = svc(counter);
const c = useCounter(10);

c.count();
c.increment();
c.doubled();
```

`svc(counter)` provides (or injects) the service (and is totally type safe). Then you have a ready-to-use behavior bound to your service that you can name whatever you want. Again, by convention (NOT prescription) we prefix with `use*` for nice semantics and ergonomics.

---

## Composing Behaviors

The double-function behavior pattern is quite powerful for composition. Behaviors can easily compose other behaviors. To demonstrate this, let's start with a basic portable behavior:

```typescript
const disclosure = ({ signal }: Service) => (initialOpen = false) => {
  const isOpen = signal(initialOpen);

  return {
    isOpen,
    open: () => isOpen(true),
    close: () => isOpen(false),
    toggle: () => isOpen(!isOpen()),
  };
};
```

Now, we can compose it!

```typescript
const dropdown = (svc: Service) => {
  // Another convention is to use the outer function as a "service layer", but you could
  // do this in the return function if you don't mind it running on every mount.
  const useDisclosure = svc(disclosure);

  return (options?: { initialOpen?: boolean }) => {
    const disc = useDisclosure(options?.initialOpen ?? false);

    // Add keyboard handling
    // Look ma, no memoization required!
    const onKeyDown = (e: KeyboardEvent) => {
      if (e.key !== 'Enter') return;
      e.preventDefault();
      disc.toggle();
    };

    return {
      ...disc,
      onKeyDown,
    };
  };
};
```

Now `dropdown` composes `disclosure`! They both use the same behavior shape of `(svc) => (args) => api`, but one composes the other. In rimitive, we call the outer function the **service layer**. It's a convenient place to inject services a single time.

---

## Testing

Behaviors are trivial to test. Just import your service:

```typescript
import { describe, it, expect } from 'vitest';
import { svc } from './service';

describe('counter', () => {
  it('increments', () => {
    const c = svc(counter)(0);

    c.increment();
    c.increment();

    expect(c.count()).toBe(2);
  });

  it('respects initial value', () => {
    const c = svc(counter)(50);

    expect(c.count()).toBe(50);
    c.reset();
    expect(c.count()).toBe(50);
  });
});
```

Pure functions, pure tests. Again, if this is all you need, you can stop here. If you want a reactive UI and UI components, as the kids say, "let's gooooo".

---

## Adding Routing

Routing in Rimitive is reactive state. The router tracks the current URL and matches it against your route definitions. You render different views by reacting to those matches.

---

## The Simplest Router

Start with just route definitions and a router:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';
import { createRouterModule } from '@rimitive/router';

// Define routes - pure data
const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
];

// Compose with router
const svc = compose(
  SignalModule,
  ComputedModule,
  createRouterModule(routes)
);

const { router } = svc;
```

The router gives you reactive signals:

```typescript
router.currentPath();  // '/' or '/about'
router.matches();      // [{ id: 'home', pattern: '/', params: {}, path: '/' }]
```

Navigate programmatically:

```typescript
router.navigate('/about');
router.currentPath();  // '/about'
router.matches();      // [{ id: 'about', pattern: '/about', params: {}, path: '/about' }]
```

That's the core: routes in, reactive matches out.

---

## Rendering Routes

Use `match()` to render different views based on the current route:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { MountModule } from '@rimitive/view/deps/mount';
import { createRouterModule } from '@rimitive/router';

const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
];

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  createMatchModule(adapter),
  MountModule,
  createRouterModule(routes)
);

const { el, match, mount, router } = svc;
```

Now render based on the matched route:

```typescript
// Page components
const Home = () => el('div')(
  el('h1')('Home'),
  el('p')('Welcome!')
);

const About = () => el('div')(
  el('h1')('About'),
  el('p')('Learn more about us.')
);

const NotFound = () => el('div')(
  el('h1')('404'),
  el('p')('Page not found.')
);

// Route â†’ component mapping
const pages = {
  home: Home,
  about: About,
};

// App with routing
const App = () => el('div')(
  match(router.matches, (matches) => {
    const route = matches[0];
    if (!route) return NotFound();

    const Page = pages[route.id];
    return Page ? Page() : NotFound();
  })
);

const app = mount(App());
document.body.appendChild(app.element!);
```

When `router.matches` changes, `match()` swaps the rendered component.

---

## Adding Navigation

Use `Link` for declarative navigation that works with the router:

```typescript
import { Link } from '@rimitive/router/link';

const Nav = () => el('nav')(
  Link({ href: '/' })('Home'),
  Link({ href: '/about' })('About')
);

const App = () => el('div')(
  Nav(),
  el('main')(
    match(router.matches, (matches) => {
      const route = matches[0];
      if (!route) return NotFound();
      const Page = pages[route.id];
      return Page ? Page() : NotFound();
    })
  )
);
```

`Link` renders an `<a>` tag that intercepts clicks and calls `router.navigate()` instead of doing a full page reload.

For programmatic navigation, use `router.navigate()` directly:

```typescript
const Home = () => el('div')(
  el('h1')('Home'),
  el('button').props({
    onclick: () => router.navigate('/about')
  })('Go to About')
);
```

---

## Route Parameters

Capture dynamic segments with `:param` syntax:

```typescript
const routes = [
  { id: 'home', path: '' },
  { id: 'products', path: 'products' },
  { id: 'product-detail', path: 'products/:id' },
];
```

When the URL is `/products/123`, the match includes the parameter:

```typescript
router.navigate('/products/123');
router.matches();
// [{ id: 'product-detail', pattern: '/products/:id', params: { id: '123' }, path: '/products/123' }]
```

Use the params in your component:

```typescript
const ProductDetail = (params: { id: string }) => el('div')(
  el('h1')(`Product ${params.id}`),
  el('p')('Product details here...')
);

// In the router match
match(router.matches, (matches) => {
  const route = matches[0];
  if (!route) return NotFound();

  if (route.id === 'product-detail') {
    return ProductDetail(route.params as { id: string });
  }

  const Page = pages[route.id];
  return Page ? Page() : NotFound();
});
```

---

## Query Strings

The router parses query strings into reactive signals:

```typescript
// URL: /products?sort=price&category=electronics

router.search();  // '?sort=price&category=electronics'
router.query();   // { sort: 'price', category: 'electronics' }
```

React to query changes:

```typescript
const Products = () => {
  const sortOrder = computed(() => router.query().sort || 'name');

  return el('div')(
    el('h1')('Products'),
    el('p')(computed(() => `Sorted by: ${sortOrder()}`)),
    el('button').props({
      onclick: () => router.navigate('/products?sort=price')
    })('Sort by Price')
  );
};
```

---

## Active Link Styling

Use `router.currentPath` to style the active link:

```typescript
const NavLink = (href: string, label: string) => {
  const isActive = computed(() => router.currentPath() === href);

  return Link({
    href,
    className: computed(() => isActive() ? 'nav-link active' : 'nav-link')
  })(label);
};

const Nav = () => el('nav')(
  NavLink('/', 'Home'),
  NavLink('/about', 'About'),
  NavLink('/products', 'Products')
);
```

---

## A Complete Example

Putting it all together:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { MountModule } from '@rimitive/view/deps/mount';
import { createRouterModule } from '@rimitive/router';
import { Link } from '@rimitive/router/link';

// Routes
const routes = [
  { id: 'home', path: '' },
  { id: 'about', path: 'about' },
  { id: 'products', path: 'products' },
  { id: 'product-detail', path: 'products/:id' },
];

// Service
const adapter = createDOMAdapter();
const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  createElModule(adapter),
  createMatchModule(adapter),
  MountModule,
  createRouterModule(routes)
);

const { el, match, mount, router, computed } = svc;

// Navigation
const NavLink = (href: string, label: string) =>
  Link({
    href,
    className: computed(() =>
      router.currentPath() === href ? 'active' : ''
    )
  })(label);

const Nav = () => el('nav')(
  NavLink('/', 'Home'),
  NavLink('/about', 'About'),
  NavLink('/products', 'Products')
);

// Pages
const Home = () => el('div')(
  el('h1')('Home'),
  el('button').props({
    onclick: () => router.navigate('/about')
  })('Learn More')
);

const About = () => el('div')(
  el('h1')('About'),
  el('p')('We build things.')
);

const Products = () => el('div')(
  el('h1')('Products'),
  el('ul')(
    el('li')(Link({ href: '/products/1' })('Product 1')),
    el('li')(Link({ href: '/products/2' })('Product 2')),
    el('li')(Link({ href: '/products/3' })('Product 3'))
  )
);

const ProductDetail = (id: string) => el('div')(
  el('h1')(`Product ${id}`),
  el('button').props({
    onclick: () => router.navigate('/products')
  })('â† Back')
);

const NotFound = () => el('div')(
  el('h1')('404'),
  Link({ href: '/' })('Go Home')
);

// App
const App = () => el('div')(
  Nav(),
  el('main')(
    match(router.matches, (matches) => {
      const route = matches[0];
      if (!route) return NotFound();

      // Just plain old javascript...
      switch (route.id) {
        case 'home': return Home();
        case 'about': return About();
        case 'products': return Products();
        case 'product-detail': return ProductDetail(route.params.id);
        default: return NotFound();
      }
    })
  )
);

// Mount
const app = mount(App());
document.body.appendChild(app.element!);
```

Routes are data. Matching is reactive. Rendering is just `match()` on `router.matches`. Everything composes with the same patterns you've already learned.

Next: [Server Rendering](/guides/server-rendering) for rendering on the server with data loading.

---

## Loading Data

Data loading in Rimitive is reactive. When dependencies change, data refetches. When requests overlap, stale ones get cancelled. Let's build up to that.

---

## The Manual Way

You could manage async state yourself with signals and effects:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, effect } = compose(SignalModule, ComputedModule, EffectModule);

// State
const loading = signal(true);
const data = signal<string[]>([]);
const error = signal<Error | null>(null);

// Fetch on mount
effect(() => {
  loading(true);
  fetch('/api/items')
    .then(r => r.json())
    .then(items => {
      data(items);
      loading(false);
    })
    .catch(err => {
      error(err);
      loading(false);
    });
});
```

This works, but you're managing three signals, handling errors, and there's no cancellation. When dependencies change mid-flight, you get race conditions.

---

## The resource() Primitive

`resource()` handles all of that. Add the resource module:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { ResourceModule } from '@rimitive/resource';

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  ResourceModule
);

const { signal, resource } = svc;
```

### Basic Usage

Create a resource with a fetcher function:

```typescript
const items = resource((signal) =>
  fetch('/api/items', { signal }).then(r => r.json())
);
```

The fetcher receives an `AbortSignal`. Pass it to `fetch()` for automatic cancellation.

### Reading State

A resource has multiple ways to read its state:

```typescript
// Full state object
items();
// { status: 'pending' }
// { status: 'ready', value: [...] }
// { status: 'error', error: Error }

// Convenience accessors
items.loading();  // true | false
items.data();     // T | undefined
items.error();    // unknown | undefined
```

All are reactiveâ€”use them in computeds or effects.

---

## Reactive Dependencies

Here's where resources shine. Read signals inside the fetcher, and the resource refetches when they change:

```typescript
const categoryId = signal(1);

const products = resource((signal) =>
  fetch(`/api/products?category=${categoryId()}`, { signal })
    .then(r => r.json())
);

// Initial fetch: /api/products?category=1

categoryId(2);
// Aborts previous request
// New fetch: /api/products?category=2
```

The previous request is automatically aborted. No race conditions, no stale data.

### Multiple Dependencies

Track as many signals as you need:

```typescript
const category = signal('electronics');
const sortBy = signal('price');
const page = signal(1);

const products = resource((signal) =>
  fetch(
    `/api/products?category=${category()}&sort=${sortBy()}&page=${page()}`,
    { signal }
  ).then(r => r.json())
);

// Any change triggers a refetch
category('books');   // refetch
sortBy('rating');    // refetch
page(2);             // refetch
```

---

## Rendering Resources

Use `match()` to render different states:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { ResourceModule } from '@rimitive/resource';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createMapModule } from '@rimitive/view/map';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  ResourceModule,
  createElModule(adapter),
  createMatchModule(adapter),
  createMapModule(adapter),
  MountModule
);

const { el, match, map, resource, mount } = svc;
```

Now render based on resource state:

```typescript
type Product = { id: number; name: string; price: number };

const products = resource<Product[]>((signal) =>
  fetch('/api/products', { signal }).then(r => r.json())
);

const ProductList = () =>
  match(products, (state) => {
    switch (state.status) {
      case 'pending':
        return el('div')('Loading...');
      case 'error':
        return el('div')(`Error: ${state.error}`);
      case 'ready':
        return el('ul')(
          map(state.value, (p) => p.id, (product) =>
            el('li')(computed(() => product().name))
          )
        );
    }
  });
```

### Using Convenience Accessors

For simpler rendering, use the boolean accessors:

```typescript
const ProductList = () =>
  el('div')(
    match(products.loading, (isLoading) =>
      isLoading ? el('div')('Loading...') : null
    ),
    match(products.error, (err) =>
      err ? el('div')(`Error: ${err}`) : null
    ),
    match(products.data, (data) =>
      data
        ? el('ul')(
            map(data, (p) => p.id, (product) =>
              el('li')(computed(() => product().name))
            )
          )
        : null
    )
  );
```

---

## Refetch and Dispose

### Manual Refetch

Trigger a refetch programmatically:

```typescript
const products = resource((signal) =>
  fetch('/api/products', { signal }).then(r => r.json())
);

// Later...
products.refetch();
```

Useful for "refresh" buttons or after mutations.

### Cleanup

When a resource is no longer needed, dispose it to abort any in-flight request and stop tracking:

```typescript
const products = resource((signal) =>
  fetch('/api/products', { signal }).then(r => r.json())
);

// When done
products.dispose();
```

In components, clean up when the element is removed:

```typescript
const ProductList = () => {
  const products = resource((signal) =>
    fetch('/api/products', { signal }).then(r => r.json())
  );

  return el('div').ref(() => {
    // Cleanup callback runs when element is removed
    return () => products.dispose();
  })(
    // ... render products
  );
};
```

---

## A Complete Example

A product browser with category filtering:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import type { Reactive } from '@rimitive/signals';
import { ResourceModule } from '@rimitive/resource';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createMapModule } from '@rimitive/view/map';
import { MountModule } from '@rimitive/view/deps/mount';

const adapter = createDOMAdapter();
const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  ResourceModule,
  createElModule(adapter),
  createMatchModule(adapter),
  createMapModule(adapter),
  MountModule
);

const { el, match, map, signal, computed, resource, mount } = svc;

// Types
type Category = { id: number; name: string };
type Product = { id: number; name: string; price: number };

// State
const selectedCategory = signal<number | null>(null);

// Resources
const categories = resource<Category[]>((signal) =>
  fetch('/api/categories', { signal }).then(r => r.json())
);

const products = resource<Product[]>((signal) => {
  const catId = selectedCategory();
  const url = catId
    ? `/api/products?category=${catId}`
    : '/api/products';
  return fetch(url, { signal }).then(r => r.json());
});

// Components
const CategoryButton = (category: Category) =>
  el('button').props({
    className: computed(() =>
      selectedCategory() === category.id ? 'active' : ''
    ),
    onclick: () => selectedCategory(category.id),
  })(category.name);

const ProductCard = (productSignal: Reactive<Product>) =>
  el('div').props({ className: 'product' })(
    el('h3')(computed(() => productSignal().name)),
    el('p')(computed(() => `$${productSignal().price}`))
  );

const App = () =>
  el('div').props({ className: 'app' })(
    el('h1')('Products'),

    // Category filter
    el('div').props({ className: 'categories' })(
      el('button').props({
        className: computed(() =>
          selectedCategory() === null ? 'active' : ''
        ),
        onclick: () => selectedCategory(null),
      })('All'),
      match(categories, (state) =>
        state.status === 'ready'
          ? el('span')(
              ...state.value.map(CategoryButton)
            )
          : null
      )
    ),

    // Products grid
    match(products, (state) => {
      switch (state.status) {
        case 'pending':
          return el('div').props({ className: 'loading' })('Loading products...');
        case 'error':
          return el('div').props({ className: 'error' })(
            'Failed to load products',
            el('button').props({
              onclick: () => products.refetch()
            })('Retry')
          );
        case 'ready':
          return state.value.length === 0
            ? el('div')('No products found')
            : el('div').props({ className: 'grid' })(
                map(state.value, (p) => p.id, ProductCard)
              );
      }
    })
  );

const app = mount(App());
document.body.appendChild(app.element!);
```

Reactive dependencies, automatic cancellation, clean rendering. The resource handles the complexity; you handle the UI.

---

## What About SSR?

For server-side rendering with data, Rimitive provides `load()` which integrates with the SSR system. That's covered in the SSR guideâ€”for now, `resource()` handles client-side data fetching.

Next: [Adding Routing](/guides/adding-routing) for navigation between views.

---

## Server Rendering

Server-side rendering in Rimitive renders your components to HTML on the server, waits for async data to load, then sends the complete page to the browser. The client hydrates the existing DOM instead of recreating it.

Unlike many frameworks, Rimitive effects are synchronous and run on the server too. There's no special "client-only" mode â€” your reactive code works the same way in both environments. This makes SSR predictable: signals update, effects run, DOM changes, all synchronously.

---

## The Basic Setup

You need three pieces:
1. A server adapter (uses linkedom instead of the real DOM)
2. A render function that awaits async boundaries
3. A client that hydrates the SSR HTML

### Server Adapter

```typescript
import { createDOMServerAdapter } from '@rimitive/ssr/server';

const { adapter, serialize, insertFragmentMarkers } = createDOMServerAdapter();
```

The server adapter creates elements using linkedom (a lightweight DOM implementation). `serialize` converts elements to HTML strings. `insertFragmentMarkers` adds comment markers for hydration.

### Creating a Service

Your service factory takes an adapter, so both server and client can use the same components:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export type ServiceOptions = {
  loaderData?: Record<string, unknown>;
};

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: ServiceOptions
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    createLoaderModule({
      initialData: options?.loaderData,
    })
  );
}

export type Service = ReturnType<typeof createService>;
```

---

## Loading Data with load()

`load()` creates async boundaries that work with SSR. It takes three arguments:

1. **id** â€” A unique string for data lookup during hydration
2. **fetcher** â€” An async function that returns data
3. **renderer** â€” A function that receives state and returns UI

```typescript
import type { LoadState, LoadStatus } from '@rimitive/view/load';

type UserData = { name: string; email: string };

const UserProfile = (svc: Service) => {
  const { loader, match, el } = svc;

  return loader.load(
    'user-profile',  // ID for hydration
    () => fetch('/api/user').then(r => r.json()),
    (state: LoadState<UserData>) =>
      match(state.status, (status: LoadStatus) => {
        switch (status) {
          case 'pending':
            return el('div')('Loading...');
          case 'error':
            return el('div')(`Error: ${state.error()}`);
          case 'ready':
            return el('div')(
              el('h1')(state.data()!.name),
              el('p')(state.data()!.email)
            );
        }
      })
  );
};
```

The state object has reactive properties:
- `state.status` â€” `'pending' | 'ready' | 'error'`
- `state.data()` â€” The loaded data (undefined until ready)
- `state.error()` â€” The error (undefined unless error)

### Error Handling

Always handle errors in your renderer. The `error` state catches exceptions from your fetcher:

```typescript
loader.load(
  'stats',
  async () => {
    const res = await fetch('/api/stats');
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    return res.json();
  },
  (state) =>
    match(state.status, (status) => {
      switch (status) {
        case 'pending':
          return Loading();
        case 'error':
          return ErrorDisplay(state.error());
        case 'ready':
          return StatsView(state.data()!);
      }
    })
)
```

---

## Rendering on the Server

Use `renderToStringAsync` to render your app and wait for all `load()` boundaries:

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createDOMServerAdapter,
  renderToStringAsync,
} from '@rimitive/ssr/server';
import type { RefSpec } from '@rimitive/view/types';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer(async (req, res) => {
  // Create per-request adapter and service
  const { adapter, serialize, insertFragmentMarkers } = createDOMServerAdapter();
  const service = createService(adapter);

  // Create the app RefSpec
  const appSpec = App(service);

  // Render to string, awaiting all load() boundaries
  const html = await renderToStringAsync(appSpec, {
    svc: service,
    mount: (spec: RefSpec<unknown>) => spec.create(service),
    serialize,
    insertFragmentMarkers,
  });

  // Get loader data for hydration
  const loaderData = service.loader.getData();

  // Send HTML with embedded data
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`
    <!DOCTYPE html>
    <html>
    <head>
      <script>window.__RIMITIVE_DATA__ = ${JSON.stringify(loaderData)}</script>
    </head>
    <body>
      <div class="app">${html}</div>
      <script src="/client.js"></script>
    </body>
    </html>
  `);
});

server.listen(3000);
```

Key points:
- Create a fresh adapter and service per request (no shared state)
- `renderToStringAsync` awaits all `load()` boundaries before returning
- `service.loader.getData()` collects all resolved data
- Embed the data in a script tag for client hydration

---

## Hydrating on the Client

The client hydrates the existing DOM instead of creating new elements:

```typescript
// client.ts
import { createClientAdapter } from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

// Create hydration adapter for the SSR root element
const adapter = createClientAdapter(document.querySelector('.app')!);

// Get loader data from SSR
const loaderData = window.__RIMITIVE_DATA__;

// Create service with hydrating adapter and loader data
const service = createService(adapter, { loaderData });

// Hydrate - walks existing DOM, wires up reactivity
App(service).create(service);

// Switch to normal DOM mode for future updates
adapter.activate();
```

What happens:
1. `createClientAdapter` creates an adapter that walks existing DOM
2. `loaderData` provides pre-fetched data so `load()` doesn't refetch
3. `.create(service)` hydrates the app, connecting signals to existing elements
4. `adapter.activate()` switches to normal DOM mode for subsequent updates

---

## A Complete Example

Here's a minimal but complete SSR setup:

### Shared Service

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export type ServiceOptions = {
  loaderData?: Record<string, unknown>;
};

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: ServiceOptions
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    createLoaderModule({ initialData: options?.loaderData })
  );
}

export type Service = ReturnType<typeof createService>;
```

### App Component

```typescript
// App.ts
import type { LoadState, LoadStatus } from '@rimitive/view/load';
import type { Service } from './service.js';

type Stats = { users: number; views: number };

async function fetchStats(): Promise<Stats> {
  const res = await fetch('https://api.example.com/stats');
  if (!res.ok) throw new Error('Failed to fetch stats');
  return res.json();
}

export const App = (svc: Service) => {
  const { loader, match, el } = svc;

  return el('div').props({ className: 'app' })(
    el('h1')('My App'),

    loader.load(
      'stats',
      fetchStats,
      (state: LoadState<Stats>) =>
        match(state.status, (status: LoadStatus) => {
          switch (status) {
            case 'pending':
              return el('div').props({ className: 'loading' })('Loading stats...');
            case 'error':
              return el('div').props({ className: 'error' })(
                'Failed to load stats: ',
                String(state.error())
              );
            case 'ready': {
              const data = state.data()!;
              return el('div').props({ className: 'stats' })(
                el('p')(`Users: ${data.users}`),
                el('p')(`Views: ${data.views}`)
              );
            }
          }
        })
    )
  );
};
```

### Server

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createDOMServerAdapter,
  renderToStringAsync,
} from '@rimitive/ssr/server';
import type { RefSpec } from '@rimitive/view/types';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } = createDOMServerAdapter();
  const service = createService(adapter);

  try {
    const html = await renderToStringAsync(App(service), {
      svc: service,
      mount: (spec: RefSpec<unknown>) => spec.create(service),
      serialize,
      insertFragmentMarkers,
    });

    const loaderData = service.loader.getData();

    res.writeHead(200, { 'Content-Type': 'text/html' });
    res.end(`<!DOCTYPE html>
<html>
<head>
  <title>My App</title>
  <script>window.__RIMITIVE_DATA__=${JSON.stringify(loaderData)}</script>
</head>
<body>
  <div class="app">${html}</div>
  <script src="/client.js"></script>
</body>
</html>`);
  } catch (err) {
    console.error('SSR Error:', err);
    res.writeHead(500);
    res.end('Server Error');
  }
});

server.listen(3000);
```

### Client

```typescript
// client.ts
import { createClientAdapter } from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

const adapter = createClientAdapter(document.querySelector('.app')!);
const service = createService(adapter, {
  loaderData: window.__RIMITIVE_DATA__,
});

App(service).create(service);
adapter.activate();
```

---

## When Data Fetching Fails

Server-side errors are caught and rendered as the error state. The client receives the error UI, and the error is preserved in the loader data.

For server-level errors (outside of `load()` boundaries), wrap `renderToStringAsync` in a try/catch:

```typescript
try {
  const html = await renderToStringAsync(appSpec, options);
  // ... send HTML
} catch (err) {
  console.error('SSR failed:', err);
  res.writeHead(500);
  res.end('Internal Server Error');
}
```

---

## Browser-Only Code in Refs

Since effects and refs run on the server, code that relies on browser APIs needs guards. The server uses linkedom, which implements core DOM operations but not browser-specific features like `focus()`, `scrollIntoView()`, or `getBoundingClientRect()`.

### Common Patterns

**Guard with environment check:**

```typescript
el('input').ref((el) => {
  if (typeof window === 'undefined') return;
  el.focus();
})()
```

**Use optional chaining for methods that might not exist:**

```typescript
el('div').ref((el) => {
  el.scrollIntoView?.({ behavior: 'smooth' });
})()
```

**Feature detection:**

```typescript
el('div').ref((el) => {
  if ('animate' in el) {
    el.animate([{ opacity: 0 }, { opacity: 1 }], { duration: 300 });
  }
})()
```

### What Works Without Guards

- **Event handlers via `on()`** â€” The server adapter skips these automatically
- **Event handlers via props** (`onclick`, `oninput`) â€” Also skipped on server
- **Basic DOM properties** â€” `className`, `textContent`, `id`, etc. work fine

### What Needs Guards

- `focus()`, `blur()`
- `scrollIntoView()`, `scrollTo()`
- `getBoundingClientRect()`, `getClientRects()`
- `animate()`
- Browser globals: `window`, `document`, `localStorage`, `navigator`

---

## Next Steps

This covers basic SSR where the server waits for all data before sending HTML. For pages with slow data sources, you might want to send HTML immediately and stream data as it loads. That's covered in [Streaming SSR](/guides/streaming-ssr).

---

## Streaming SSR

With basic SSR, the server waits for all data before sending anything. Streaming SSR sends the page shell immediately, then streams data chunks as each `load()` boundary resolves. Users see content faster, especially when some data sources are slow.

---

## How Streaming Works

1. Server renders the app with `pending` states for all `load()` boundaries
2. Initial HTML is sent immediately â€” users see the loading UI
3. As each `load()` boundary resolves, data is streamed as a script tag
4. Client receives data via a streaming receiver and updates signals
5. UI updates reactively â€” no DOM manipulation needed

The key insight: signals update the UI. The server streams data, the client pushes it to signals, and Rimitive handles the rest.

---

## Setting Up the Stream Writer

The stream writer generates JavaScript code for the streaming protocol:

```typescript
import { createStreamWriter } from '@rimitive/ssr/server';

// Create writer with a unique key
const stream = createStreamWriter('__APP_STREAM__');

// Bootstrap code initializes the receiver
stream.bootstrapCode();
// Returns: "window.__APP_STREAM__=(function(){...})();"

// Chunk code pushes data to the receiver
stream.chunkCode('stats', { users: 100 });
// Returns: "__APP_STREAM__.push("stats",{"users":100});"
```

The receiver queues data chunks until the client connects, then forwards them to the loader.

---

## Server Setup

Use `renderToStream` instead of `renderToStringAsync`:

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createDOMServerAdapter,
  renderToStream,
  createStreamWriter,
} from '@rimitive/ssr/server';
import type { RefSpec } from '@rimitive/view/types';
import { createService } from './service.js';
import { App } from './App.js';

const STREAM_KEY = '__APP_STREAM__';
const stream = createStreamWriter(STREAM_KEY);

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } = createDOMServerAdapter();

  // Create service with streaming callback
  const service = createService(adapter, {
    onResolve: (id, data) => {
      // Stream each data chunk as it resolves
      res.write(`<script>${stream.chunkCode(id, data)}</script>`);
    },
  });

  // Render with pending states
  const { initialHtml, done, pendingCount } = renderToStream(
    App(service),
    {
      mount: (spec: RefSpec<unknown>) => spec.create(service),
      serialize,
      insertFragmentMarkers,
    }
  );

  // Start response immediately
  res.writeHead(200, { 'Content-Type': 'text/html' });

  // Write document head with bootstrap script
  res.write(`<!DOCTYPE html>
<html>
<head>
  <script>${stream.bootstrapCode()}</script>
</head>
<body>`);

  // Write initial HTML (with loading states)
  res.write(`<div class="app">${initialHtml}</div>`);

  // Write client script
  res.write('<script src="/client.js"></script>');

  // Wait for all data to stream
  await done;

  // Close document
  res.write('</body></html>');
  res.end();
});

server.listen(3000);
```

Key differences from basic SSR:
- `onResolve` callback streams data as each boundary resolves
- `renderToStream` returns immediately with pending states
- `done` promise resolves when all data has streamed

---

## Service with Streaming Support

Your service needs to pass `onResolve` to the loader:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export type ServiceOptions = {
  loaderData?: Record<string, unknown>;
  onResolve?: (id: string, data: unknown) => void;
};

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: ServiceOptions
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    createLoaderModule({
      initialData: options?.loaderData,
      onResolve: options?.onResolve,
    })
  );
}

export type Service = ReturnType<typeof createService>;
```

---

## Client Setup

The client connects to the stream after hydration:

```typescript
// client.ts
import { createClientAdapter, connectStream } from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

const STREAM_KEY = '__APP_STREAM__';

// Create hydration adapter
const adapter = createClientAdapter(document.querySelector('.app')!);

// Create service (no loaderData for streaming)
const service = createService(adapter);

// Hydrate the app
App(service).create(service);

// Switch to normal DOM mode
adapter.activate();

// Connect to the stream - receives queued and future data chunks
connectStream(service, STREAM_KEY);
```

`connectStream` does two things:
1. Flushes any data chunks that arrived before hydration completed
2. Wires up the loader to receive future chunks

---

## Using load() with Streaming

Components use `load()` the same way as basic SSR:

```typescript
import type { LoadState, LoadStatus } from '@rimitive/view/load';
import type { Service } from './service.js';

type Stats = { users: number; views: number };

async function fetchStats(): Promise<Stats> {
  // Simulate slow API
  await new Promise(r => setTimeout(r, 2000));
  return { users: 1234, views: 56789 };
}

export const StatsWidget = (svc: Service) => {
  const { loader, match, el } = svc;

  return loader.load(
    'stats',
    fetchStats,
    (state: LoadState<Stats>) =>
      match(state.status, (status: LoadStatus) => {
        switch (status) {
          case 'pending':
            return el('div').props({ className: 'skeleton' })('Loading stats...');
          case 'error':
            return el('div').props({ className: 'error' })(
              'Failed to load: ',
              String(state.error())
            );
          case 'ready': {
            const data = state.data()!;
            return el('div').props({ className: 'stats' })(
              el('span')(`${data.users} users`),
              el('span')(`${data.views} views`)
            );
          }
        }
      })
  );
};
```

What happens with streaming:
1. Server renders `pending` state immediately
2. HTML with skeleton UI is sent to browser
3. 2 seconds later, `fetchStats` resolves
4. `onResolve` streams the data chunk
5. Client receives data, updates the signal
6. `match()` re-renders with `ready` state

---

## Error Handling

Errors in `load()` boundaries are handled gracefully:

```typescript
loader.load(
  'user-data',
  async () => {
    const res = await fetch('/api/user');
    if (!res.ok) {
      throw new Error(`Failed: ${res.status}`);
    }
    return res.json();
  },
  (state) =>
    match(state.status, (status) => {
      switch (status) {
        case 'pending':
          return el('div')('Loading...');
        case 'error':
          return el('div').props({ className: 'error' })(
            el('p')('Something went wrong'),
            el('pre')(String(state.error())),
            el('button').props({
              onclick: () => window.location.reload()
            })('Retry')
          );
        case 'ready':
          return UserProfile(state.data()!);
      }
    })
)
```

With streaming, errors still work:
1. If the fetch fails, `onResolve` isn't called for that boundary
2. The `done` promise still resolves (errors don't break the stream)
3. The error state shows in the UI with no data chunk

For server-level errors, wrap the streaming response:

```typescript
const server = createServer(async (req, res) => {
  try {
    // ... streaming setup
    await done;
    res.write('</body></html>');
    res.end();
  } catch (err) {
    console.error('Streaming error:', err);
    // If headers haven't been sent, send error page
    if (!res.headersSent) {
      res.writeHead(500);
      res.end('Server Error');
    } else {
      // Headers already sent, try to close gracefully
      res.end();
    }
  }
});
```

---

## A Complete Streaming Example

### Service

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export type ServiceOptions = {
  loaderData?: Record<string, unknown>;
  onResolve?: (id: string, data: unknown) => void;
};

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: ServiceOptions
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    createLoaderModule({
      initialData: options?.loaderData,
      onResolve: options?.onResolve,
    })
  );
}

export type Service = ReturnType<typeof createService>;
```

### App with Multiple Async Boundaries

```typescript
// App.ts
import type { LoadState, LoadStatus } from '@rimitive/view/load';
import type { Service } from './service.js';

type User = { name: string };
type Stats = { pageViews: number };
type News = { headlines: string[] };

// Simulate different API speeds
const fetchUser = async (): Promise<User> => {
  await new Promise(r => setTimeout(r, 100));
  return { name: 'Alice' };
};

const fetchStats = async (): Promise<Stats> => {
  await new Promise(r => setTimeout(r, 1500));
  return { pageViews: 12345 };
};

const fetchNews = async (): Promise<News> => {
  await new Promise(r => setTimeout(r, 3000));
  return { headlines: ['Breaking: Rimitive is fast', 'Streaming SSR works'] };
};

export const App = (svc: Service) => {
  const { loader, match, el } = svc;

  return el('div').props({ className: 'app' })(
    el('h1')('Streaming SSR Demo'),

    // Fast - loads in 100ms
    loader.load(
      'user',
      fetchUser,
      (state: LoadState<User>) =>
        match(state.status, (status: LoadStatus) => {
          switch (status) {
            case 'pending':
              return el('div')('Loading user...');
            case 'error':
              return el('div')('Error loading user');
            case 'ready':
              return el('div')(`Welcome, ${state.data()!.name}!`);
          }
        })
    ),

    // Medium - loads in 1.5s
    loader.load(
      'stats',
      fetchStats,
      (state: LoadState<Stats>) =>
        match(state.status, (status: LoadStatus) => {
          switch (status) {
            case 'pending':
              return el('div').props({ className: 'skeleton' })('Loading stats...');
            case 'error':
              return el('div')('Error loading stats');
            case 'ready':
              return el('div')(`${state.data()!.pageViews.toLocaleString()} page views`);
          }
        })
    ),

    // Slow - loads in 3s
    loader.load(
      'news',
      fetchNews,
      (state: LoadState<News>) =>
        match(state.status, (status: LoadStatus) => {
          switch (status) {
            case 'pending':
              return el('div').props({ className: 'skeleton' })('Loading news...');
            case 'error':
              return el('div')('Error loading news');
            case 'ready':
              return el('ul')(
                ...state.data()!.headlines.map(h => el('li')(h))
              );
          }
        })
    )
  );
};
```

### Server

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createDOMServerAdapter,
  renderToStream,
  createStreamWriter,
} from '@rimitive/ssr/server';
import type { RefSpec } from '@rimitive/view/types';
import { createService } from './service.js';
import { App } from './App.js';

const STREAM_KEY = '__APP_STREAM__';
const stream = createStreamWriter(STREAM_KEY);

const server = createServer(async (req, res) => {
  const { adapter, serialize, insertFragmentMarkers } = createDOMServerAdapter();

  const service = createService(adapter, {
    onResolve: (id, data) => {
      console.log(`Streaming: ${id}`);
      res.write(`<script>${stream.chunkCode(id, data)}</script>`);
    },
  });

  const { initialHtml, done, pendingCount } = renderToStream(
    App(service),
    {
      mount: (spec: RefSpec<unknown>) => spec.create(service),
      serialize,
      insertFragmentMarkers,
    }
  );

  console.log(`Initial render: ${pendingCount} pending boundaries`);

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.write(`<!DOCTYPE html>
<html>
<head>
  <title>Streaming SSR</title>
  <script>${stream.bootstrapCode()}</script>
</head>
<body>
  <div class="app">${initialHtml}</div>
  <script src="/client.js"></script>`);

  await done;

  console.log('All boundaries resolved');
  res.write('</body></html>');
  res.end();
});

server.listen(3000);
```

### Client

```typescript
// client.ts
import { createClientAdapter, connectStream } from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

const STREAM_KEY = '__APP_STREAM__';

const adapter = createClientAdapter(document.querySelector('.app')!);
const service = createService(adapter);

App(service).create(service);
adapter.activate();
connectStream(service, STREAM_KEY);

console.log('Hydration complete, stream connected');
```

---

## When to Use Streaming

**Use streaming when:**
- Some data sources are slow (> 500ms)
- You want users to see content as fast as possible
- Different parts of the page have different data needs

**Use basic SSR when:**
- All data loads quickly
- You need the complete page for SEO crawlers
- Simplicity is more important than speed

Both approaches use the same `load()` API in componentsâ€”only the server setup differs.

---

## Custom Modules

Rimitive's composition system isn't limited to the built-in primitives. You can define your own modules with `defineModule` and compose them alongside signals, view, or anything else.

---

## Defining a Module

A module needs a `name` and a `create` function:

```typescript
import { defineModule, compose } from '@rimitive/core';

const LoggerModule = defineModule({
  name: 'logger',
  create: () => ({
    log: (msg: string) => console.log(`[LOG] ${msg}`),
    error: (msg: string) => console.error(`[ERROR] ${msg}`),
  }),
});

const svc = compose(LoggerModule);
svc.logger.log('hello');
```

The `name` becomes the key on the composed service. Whatever `create` returns becomes the value.

---

## Modules with Dependencies

Modules can depend on other modules. List them in `dependencies`, and they'll be available in `create`:

```typescript
import { defineModule, compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';

const CounterModule = defineModule({
  name: 'counter',
  dependencies: [SignalModule, ComputedModule],
  create: ({ signal, computed }) => (initial = 0) => {
    const count = signal(initial);
    const doubled = computed(() => count() * 2);
    return {
      count,
      doubled,
      increment: () => count(count() + 1),
      decrement: () => count(count() - 1),
    };
  },
});

const svc = compose(CounterModule);
const myCounter = svc.counter(10);

myCounter.count();      // 10
myCounter.increment();
myCounter.count();      // 11
myCounter.doubled();    // 22
```

Dependencies are resolved automatically. You only need to pass the modules you wantâ€”`compose()` includes transitive dependencies.

---

## Module Lifecycle

Modules can hook into lifecycle events:

```typescript
const ConnectionModule = defineModule({
  name: 'connection',
  create: () => {
    const ws = new WebSocket('wss://example.com');
    return {
      send: (msg: string) => ws.send(msg),
      socket: ws,
    };
  },
  init: (ctx) => {
    // Called before create, useful for setup
  },
  destroy: (ctx) => {
    // Called when svc.dispose() is invoked
  },
});

const svc = compose(ConnectionModule);
// ... use the connection
svc.dispose(); // triggers destroy hooks
```

---

## Beyond Reactivity

Here's the thing: `@rimitive/core` has no concept of reactivity. It's just a composition mechanism. You can use it for anything:

```typescript
import { defineModule, compose } from '@rimitive/core';

const HttpModule = defineModule({
  name: 'http',
  create: () => ({
    get: (url: string) => fetch(url).then(r => r.json()),
    post: (url: string, data: unknown) =>
      fetch(url, { method: 'POST', body: JSON.stringify(data) }).then(r => r.json()),
  }),
});

const CacheModule = defineModule({
  name: 'cache',
  create: () => {
    const store = new Map<string, unknown>();
    return {
      get: <T>(key: string): T | undefined => store.get(key) as T,
      set: <T>(key: string, value: T): void => { store.set(key, value); },
      clear: () => store.clear(),
    };
  },
});

const ApiModule = defineModule({
  name: 'api',
  dependencies: [HttpModule, CacheModule],
  create: ({ http, cache }) => ({
    async getUser(id: string) {
      const cached = cache.get<User>(`user:${id}`);
      if (cached) return cached;

      const user = await http.get(`/api/users/${id}`);
      cache.set(`user:${id}`, user);
      return user;
    },
  }),
});

const svc = compose(ApiModule);
await svc.api.getUser('123');
```

This makes `compose()` useful for any library or application architectureâ€”not just UI frameworks. You control what gets composed.

---

## Tree-Shaking

Because you explicitly compose modules, everything is fully tree-shakeable. If you don't use `EffectModule`, it won't be in your bundle. If you only need signals without a view, just compose signals:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule, ComputedModule);
// No view code bundled
```

---

## When to Create Modules

Create a module when you want to:

- **Add new primitives** to the composed service
- **Share infrastructure** (logging, http, storage) across behaviors
- **Encapsulate setup/teardown** with lifecycle hooks
- **Build your own libraries** on top of composition

For reusable reactive logic, prefer [behaviors](/guides/creating-a-behavior). Behaviors are simpler and don't require `defineModule`. Use modules when you need something that lives at the composition level.

---

## Signal Patterns

Signals are simpleâ€”read with `sig()`, write with `sig(value)`. But there are patterns that make them more ergonomic for common use cases.

---

## Updater Functions

Signals accept functions for updates based on the previous value:

```typescript
const count = signal(0);

// Direct update
count(5);

// Updater function: receives previous value, returns new value
count(c => c + 1);  // increment
count(c => c * 2);  // double
count(c => Math.max(0, c - 1));  // decrement, minimum 0
```

This is particularly useful for arrays and objects:

```typescript
const items = signal<Item[]>([]);

// Append
items(arr => [...arr, newItem]);

// Remove by id
items(arr => arr.filter(x => x.id !== id));

// Update one item
items(arr => arr.map(x => x.id === id ? { ...x, done: true } : x));

// Toggle a property
items(arr => arr.map(x => x.id === id ? { ...x, done: !x.done } : x));
```

---

## Derived Actions

The standard behavior pattern returns an object with state and actions:

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};

const { count, increment, decrement } = svc(counter)(0);
```

An alternative: attach actions directly to the signal:

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);

  return Object.assign(count, {
    increment: () => count(c => c + 1),
    decrement: () => count(c => c - 1),
    reset: () => count(initial),
  });
};

// Usage - no destructuring needed
const count = svc(counter)(0);

count();           // read: 0
count(5);          // write: 5
count.increment(); // action: 6
count.reset();     // action: 0
```

This works because signals are functions, and functions are objects that can have properties.

---

## Toggle

A common case of derived actionsâ€”boolean signals with on/off/toggle:

```typescript
const toggle = (svc: SignalsSvc) => (initial = false) => {
  const value = svc.signal(initial);

  return Object.assign(value, {
    on: () => value(true),
    off: () => value(false),
    toggle: () => value(v => !v),
  });
};

// Usage
const isOpen = svc(toggle)(false);

isOpen();        // false
isOpen.toggle(); // true
isOpen.off();    // false

// Still works as a normal signal
isOpen(true);    // true
```

---

## Previous Value

Track the previous value for transitions, animations, or undo:

```typescript
const withPrevious = <T>(svc: SignalsSvc) => (initial: T) => {
  const { signal, computed } = svc;

  const current = signal(initial);
  const previous = signal(initial);

  const set = (value: T) => {
    previous(current());
    current(value);
  };

  const changed = computed(() => current() !== previous());

  return { current, previous, set, changed };
};

// Usage
const page = svc(withPrevious)(1);

page.set(2);
page.current();   // 2
page.previous();  // 1
page.changed();   // true

page.set(2);
page.changed();   // false (same value)
```

For undo/redo, extend the pattern with a history stack:

```typescript
const withHistory = <T>(svc: SignalsSvc) => (initial: T, maxHistory = 10) => {
  const { signal, computed } = svc;

  const current = signal(initial);
  const past = signal<T[]>([]);
  const future = signal<T[]>([]);

  const canUndo = computed(() => past().length > 0);
  const canRedo = computed(() => future().length > 0);

  const set = (value: T) => {
    past(p => [...p.slice(-(maxHistory - 1)), current()]);
    future([]);
    current(value);
  };

  const undo = () => {
    if (!canUndo()) return;
    const prev = past();
    const last = prev[prev.length - 1];
    past(prev.slice(0, -1));
    future(f => [...f, current()]);
    current(last!);
  };

  const redo = () => {
    if (!canRedo()) return;
    const fut = future();
    const next = fut[fut.length - 1];
    future(fut.slice(0, -1));
    past(p => [...p, current()]);
    current(next!);
  };

  return { current, set, undo, redo, canUndo, canRedo };
};
```

---

## Debounced Signals

Delay signal updates until input settles:

```typescript
const debounced = <T>(svc: SignalsSvc) => (
  source: Readable<T>,
  ms: number
) => {
  const { signal, effect } = svc;

  const value = signal(source.peek());
  let timeout: number | undefined;

  effect(() => {
    const v = source();
    clearTimeout(timeout);
    timeout = window.setTimeout(() => value(v), ms);
  });

  return value;
};

// Usage
const searchInput = signal('');
const debouncedSearch = svc(debounced)(searchInput, 300);

// searchInput updates immediately on keystroke
// debouncedSearch updates 300ms after typing stops
```

A variant that debounces both reads and writes:

```typescript
const debouncedSignal = <T>(svc: SignalsSvc) => (initial: T, ms: number) => {
  const { signal, effect } = svc;

  const immediate = signal(initial);
  const debounced = signal(initial);

  let timeout: number | undefined;

  effect(() => {
    const v = immediate();
    clearTimeout(timeout);
    timeout = window.setTimeout(() => debounced(v), ms);
  });

  // Return a signal-like object that writes to immediate, reads from debounced
  const result = ((value?: T) => {
    if (arguments.length === 0) return debounced();
    immediate(value!);
  }) as Writable<T>;

  result.peek = () => debounced.peek();

  return Object.assign(result, {
    immediate,  // Access the non-debounced value if needed
  });
};
```

---

## Async Actions

For mutations that need loading and error state:

```typescript
const asyncAction = <T, Args extends unknown[]>(svc: SignalsSvc) => (
  action: (...args: Args) => Promise<T>
) => {
  const { signal } = svc;

  const pending = signal(false);
  const error = signal<Error | null>(null);
  const lastResult = signal<T | null>(null);

  const execute = async (...args: Args): Promise<T> => {
    pending(true);
    error(null);

    try {
      const result = await action(...args);
      lastResult(result);
      return result;
    } catch (e) {
      const err = e instanceof Error ? e : new Error(String(e));
      error(err);
      throw err;
    } finally {
      pending(false);
    }
  };

  return { execute, pending, error, lastResult };
};

// Usage
const saveUser = svc(asyncAction)(async (user: User) => {
  const res = await fetch('/api/users', {
    method: 'POST',
    body: JSON.stringify(user),
  });
  if (!res.ok) throw new Error('Failed to save');
  return res.json();
});

// In a component
el('button')
  .props({
    onclick: () => saveUser.execute({ name: 'Alice' }),
    disabled: saveUser.pending,
  })(
    computed(() => saveUser.pending() ? 'Saving...' : 'Save')
  );

// Show errors
match(saveUser.error, (err) =>
  err ? el('div').props({ className: 'error' })(err.message) : null
);
```

---

## Computed Collections

When working with reactive lists, pre-compute common derived views:

```typescript
const todoList = (svc: SignalsSvc) => () => {
  const { signal, computed } = svc;

  const items = signal<Todo[]>([]);

  // Pre-computed views - computed once, cached automatically
  const active = computed(() => items().filter(t => !t.done));
  const completed = computed(() => items().filter(t => t.done));

  const counts = computed(() => ({
    total: items().length,
    active: active().length,
    completed: completed().length,
  }));

  const allDone = computed(() =>
    items().length > 0 && completed().length === items().length
  );

  return {
    items,
    active,
    completed,
    counts,
    allDone,
    // Actions...
    add: (text: string) => items(arr => [...arr, { id: crypto.randomUUID(), text, done: false }]),
    toggle: (id: string) => items(arr => arr.map(t => t.id === id ? { ...t, done: !t.done } : t)),
    remove: (id: string) => items(arr => arr.filter(t => t.id !== id)),
    clear: () => items(arr => arr.filter(t => !t.done)),
  };
};
```

Consumers can read whichever view they need:

```typescript
// Only re-renders when active items change
const ActiveList = (svc: Service, todos: ReturnType<typeof todoList>) => {
  const { el, map } = svc;
  return map(todos.active, t => t.id, TodoItem);
};

// Only re-renders when counts change
const Stats = (svc: Service, todos: ReturnType<typeof todoList>) => {
  const { el, computed } = svc;
  return el('div')(
    computed(() => `${todos.counts().active} items left`)
  );
};
```

---

## Element Partial Application

Pre-bind commonly used element tags:

```typescript
const svc = compose(SignalModule, createElModule(adapter));
const { el } = svc;

// Partial application - call el() once per tag
const div = el('div');
const button = el('button');
const input = el('input');
const span = el('span');

// Use without repeating tag names
const Form = () =>
  div.props({ className: 'form' })(
    div.props({ className: 'field' })(
      input.props({ type: 'text', placeholder: 'Name' })(),
    ),
    button.props({ type: 'submit' })('Submit')
  );
```

This is especially useful in files with many elements of the same type.

---

## Service Factory

For applications that need multiple isolated instances:

```typescript
// Define service creation as a factory
const createService = () => {
  const adapter = createDOMAdapter();
  return compose(
    SignalModule, ComputedModule, EffectModule,
    createElModule(adapter),
    createMapModule(adapter),
    createMatchModule(adapter),
  );
};

// Each call creates a fresh service with its own state
const app1 = createService();
const app2 = createService();

// Mount separate instances
mount(App(app1), document.getElementById('app1')!);
mount(App(app2), document.getElementById('app2')!);
```

This is useful for:
- Embedding multiple independent widgets on a page
- Testing with isolated services
- SSR where each request needs fresh state

---

## Behaviors

A **behavior** is a portable function that encapsulates reactive logic without any UI. It receives a service, returns a factory, and that factory returns an API of signals, computeds, and actions.

Think of behaviors as headless componentsâ€”all the state and logic, none of the markup.

---

## The Shape

```typescript
type SignalsSvc = {
  signal: <T>(initial: T) => Writable<T>;
  computed: <T>(fn: () => T) => Readable<T>;
  effect: (fn: () => void | (() => void)) => () => void;
};

const behaviorName = (svc: SignalsSvc) => (options?: Options) => {
  // Create reactive state
  // Define actions
  // Return the API
  return { ... };
};
```

Three levels:
1. **Service injection**: `(svc) =>` â€” receives primitives
2. **Factory**: `(options?) =>` â€” configures the instance
3. **API**: `{ ... }` â€” the reactive interface consumers use

---

## A Simple Example: Counter

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const { signal, computed } = svc;

  const count = signal(initial);
  const doubled = computed(() => count() * 2);

  return {
    count,
    doubled,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
    reset: () => count(initial),
  };
};
```

Usage with `use()`:

```typescript
const App = (svc: Service) => {
  const { el, use, computed } = svc;
  const { count, increment, decrement } = use(counter)(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: decrement })('-'),
    el('button').props({ onclick: increment })('+')
  );
};
```

The behavior handles state. The component handles rendering. Clean separation.

---

## Composing Behaviors

Behaviors can use other behaviors. This is where the pattern shines.

### Disclosure (open/close)

```typescript
const disclosure = (svc: SignalsSvc) => (initialOpen = false) => {
  const { signal, computed } = svc;
  const isOpen = signal(initialOpen);

  return {
    isOpen,
    open: () => isOpen(true),
    close: () => isOpen(false),
    toggle: () => isOpen(!isOpen()),
    // Accessibility props
    triggerProps: computed(() => ({
      'aria-expanded': String(isOpen()),
    })),
    contentProps: computed(() => ({
      hidden: !isOpen(),
    })),
  };
};
```

### Dropdown (disclosure + keyboard)

```typescript
const dropdown = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {
  const disc = disclosure(svc)(options?.initialOpen ?? false);

  // Add keyboard handling
  const onKeyDown = (e: KeyboardEvent) => {
    switch (e.key) {
      case 'Escape':
        disc.close();
        break;
      case 'Enter':
      case ' ':
        e.preventDefault();
        disc.toggle();
        break;
    }
  };

  return {
    ...disc,
    triggerProps: svc.computed(() => ({
      ...disc.triggerProps(),
      onkeydown: onKeyDown,
    })),
  };
};
```

### Modal (disclosure + focus trap + scroll lock)

```typescript
const modal = (svc: SignalsSvc) => (options?: { initialOpen?: boolean }) => {
  const { signal, effect } = svc;

  const disc = disclosure(svc)(options?.initialOpen ?? false);
  const previousFocus = signal<HTMLElement | null>(null);

  // Focus trap and scroll lock as an effect
  effect(() => {
    if (disc.isOpen()) {
      // Save current focus
      previousFocus(document.activeElement as HTMLElement);
      // Lock scroll
      document.body.style.overflow = 'hidden';
    } else {
      // Restore scroll
      document.body.style.overflow = '';
      // Restore focus
      previousFocus()?.focus();
    }
  });

  return {
    ...disc,
    // Close on backdrop click
    backdropProps: svc.computed(() => ({
      onclick: disc.close,
    })),
    // Prevent close when clicking modal content
    contentProps: svc.computed(() => ({
      ...disc.contentProps(),
      onclick: (e: Event) => e.stopPropagation(),
    })),
  };
};
```

Same `disclosure` behavior, three different use cases. The logic is shared; the semantics differ.

---

## Behaviors with Options

Use options for configuration that affects behavior:

```typescript
type PaginationOptions = {
  totalItems: number;
  pageSize?: number;
  initialPage?: number;
};

const pagination = (svc: SignalsSvc) => (options: PaginationOptions) => {
  const { signal, computed } = svc;

  const pageSize = options.pageSize ?? 10;
  const currentPage = signal(options.initialPage ?? 1);

  const totalPages = computed(() =>
    Math.ceil(options.totalItems / pageSize)
  );

  const hasNext = computed(() => currentPage() < totalPages());
  const hasPrev = computed(() => currentPage() > 1);

  return {
    currentPage,
    totalPages,
    hasNext,
    hasPrev,
    next: () => hasNext() && currentPage(currentPage() + 1),
    prev: () => hasPrev() && currentPage(currentPage() - 1),
    goTo: (page: number) => {
      if (page >= 1 && page <= totalPages()) {
        currentPage(page);
      }
    },
  };
};
```

---

## Behaviors with Reactive Options

When options need to be reactive, accept signals:

```typescript
import type { Readable } from '@rimitive/signals';

type SearchOptions = {
  query: Readable<string>;
  debounceMs?: number;
};

const search = (svc: SignalsSvc) => (options: SearchOptions) => {
  const { signal, computed, effect } = svc;

  const results = signal<SearchResult[]>([]);
  const isSearching = signal(false);

  let timeoutId: number | undefined;

  effect(() => {
    const q = options.query();

    clearTimeout(timeoutId);

    if (!q) {
      results([]);
      return;
    }

    isSearching(true);

    timeoutId = window.setTimeout(async () => {
      const data = await performSearch(q);
      results(data);
      isSearching(false);
    }, options.debounceMs ?? 300);
  });

  return {
    results,
    isSearching,
    resultCount: computed(() => results().length),
  };
};
```

---

## Using Behaviors in React

Behaviors work in React via `@rimitive/react`:

```typescript
import { SignalProvider, createHook, useSubscribe } from '@rimitive/react';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Create hooks from behaviors
const useCounter = createHook(counter);
const useDisclosure = createHook(disclosure);

function ReactDropdown() {
  const disc = useDisclosure(false);

  // Subscribe to signals for React re-renders
  const isOpen = useSubscribe(disc.isOpen);
  const triggerProps = useSubscribe(disc.triggerProps);
  const contentProps = useSubscribe(disc.contentProps);

  return (
    <div>
      <button {...triggerProps} onClick={disc.toggle}>
        Toggle
      </button>
      {isOpen && (
        <div {...contentProps}>
          Dropdown content
        </div>
      )}
    </div>
  );
}

// Wrap app with provider
const svc = compose(SignalModule, ComputedModule, EffectModule)();

function App() {
  return (
    <SignalProvider svc={svc}>
      <ReactDropdown />
    </SignalProvider>
  );
}
```

Same behavior, different framework. The logic stays the same.

---

## Naming Conventions

Rimitive doesn't enforce naming conventions, but here are some that work:

```typescript
// Option 1: Plain names
const counter = (svc) => ...
const disclosure = (svc) => ...

// Option 2: "use" prefix (familiar to React users)
const useCounter = (svc) => ...
const useDisclosure = (svc) => ...

// Option 3: "create" prefix (emphasizes factory nature)
const createCounter = (svc) => ...
const createDisclosure = (svc) => ...
```

---

## When to Use Behaviors

**Good candidates:**
- State that multiple components share (disclosure, selection, pagination)
- Complex state logic (forms, wizards, data fetching)
- Reusable interaction patterns (drag-and-drop, keyboard navigation)
- Anything you'd put in a custom hook in React

**Not necessary for:**
- One-off component state (just use signals directly)
- Pure presentation logic (no state to manage)
- Framework-specific integrations

---

## Testing Behaviors

Behaviors are trivial to testâ€”no DOM, no framework:

```typescript
import { describe, it, expect } from 'vitest';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

describe('counter', () => {
  const createTestSvc = () => compose(SignalModule, ComputedModule, EffectModule)();

  it('increments and decrements', () => {
    const svc = createTestSvc();
    const c = counter(svc)(5);

    expect(c.count()).toBe(5);

    c.increment();
    expect(c.count()).toBe(6);

    c.decrement();
    c.decrement();
    expect(c.count()).toBe(4);
  });

  it('computes doubled', () => {
    const svc = createTestSvc();
    const c = counter(svc)(3);

    expect(c.doubled()).toBe(6);

    c.increment();
    expect(c.doubled()).toBe(8);
  });
});
```

Pure functions, pure tests.

---

## Portability

Most UI logic isn't tied to a specific framework. A dropdown's open/close behavior is the same whether you're rendering to DOM, React, or a canvas. A form's validation logic doesn't care about the view layer.

Rimitive is designed around this insight. The same code can run in different contexts without modification.

---

## The Key: Depend on Contracts, Not Frameworks

A portable component depends on a **service contract**â€”a set of primitives it needsâ€”not a specific framework:

```typescript
// This component depends on { el, signal, computed }
// It doesn't know or care where those come from
const Counter = (svc: { el: ElFactory; signal: SignalFactory; computed: ComputedFactory }) => {
  const { el, signal, computed } = svc;
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('Increment')
  );
};
```

This component works with any service that provides `el`, `signal`, and `computed`â€”whether that's a DOM view service, a test service, or something custom.

---

## Portable Component Pattern

The standard pattern is a function that receives a service and returns a function that takes props:

```typescript
// (svc) => (props) => RefSpec
const Button = (svc: Service) => (props: { label: string; onClick: () => void }) => {
  const { el } = svc;

  return el('button').props({ onclick: props.onClick })(props.label);
};
```

This shape lets you:
- Partially apply the service once
- Call the resulting function multiple times with different props
- Pass the component to `use()` for ergonomic instantiation

```typescript
const App = (svc: Service) => {
  const { el, use } = svc;

  return el('div')(
    use(Button)({ label: 'Save', onClick: handleSave }),
    use(Button)({ label: 'Cancel', onClick: handleCancel })
  );
};
```

---

## Running in Different Contexts

### Rimitive DOM View

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule, BatchModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

// Create adapter and compose service
const adapter = createDOMAdapter();
const svc = compose(
  SignalModule, ComputedModule, EffectModule, BatchModule,
  createElModule(adapter), MountModule
)();

const app = Counter(svc);
document.body.appendChild(svc.mount(app).element!);
```

### Testing Without DOM

For tests, use a mock adapter or compose with test dependencies:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Minimal test service - just signals, no view layer
const testSvc = compose(SignalModule, ComputedModule, EffectModule)();

// Test a behavior directly
const { count, increment } = counter(testSvc)(0);
expect(count()).toBe(0);
increment();
expect(count()).toBe(1);
```

### React (via @rimitive/react)

Portable behaviors work in React through `createHook`:

```typescript
import { SignalProvider, createHook, useSubscribe } from '@rimitive/react';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

// Define a portable behavior
const counter = (svc: { signal: SignalFactory }) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};

// Turn it into a React hook
const useCounter = createHook(counter);

function ReactCounter() {
  const { count, increment } = useCounter(0);
  const value = useSubscribe(count); // Subscribe to trigger re-renders

  return <button onClick={increment}>Count: {value}</button>;
}

// Wrap your app with SignalProvider
const svc = compose(SignalModule, ComputedModule, EffectModule)();

function App() {
  return (
    <SignalProvider svc={svc}>
      <ReactCounter />
    </SignalProvider>
  );
}
```

### Custom Renderer

The same pattern works with any adapter:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { myCanvasAdapter } from './my-canvas-adapter';

const svc = compose(
  SignalModule, ComputedModule, EffectModule,
  createElModule(myCanvasAdapter)
)();

const app = Counter(svc);
// Renders to canvas instead of DOM
```

Same component, different targets.

---

## What Makes Code Portable

### Do: Depend on the service contract

```typescript
const MyComponent = (svc: Service) => {
  const { el, signal, computed } = svc;
  // Use primitives from the service
};
```

### Don't: Import framework-specific code

```typescript
// This is NOT portable
import { signal } from '@rimitive/signals';

const MyComponent = () => {
  const count = signal(0); // Hardcoded dependency
};
```

### Do: Accept dependencies as props or service extensions

```typescript
const DataList = (svc: Service & { fetchData: () => Promise<Item[]> }) => {
  const { el, resource, fetchData } = svc;
  const items = resource(fetchData);
  // ...
};
```

### Don't: Hardcode external dependencies

```typescript
// This is NOT portable
const DataList = (svc: Service) => {
  const items = resource(() => fetch('/api/items')); // Hardcoded URL
};
```

---

## Portable Behaviors vs Portable Components

**Portable behaviors** return reactive state and logicâ€”no UI:

```typescript
const counter = (svc: { signal: SignalFactory }) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};
```

**Portable components** return UI specs:

```typescript
const Counter = (svc: Service) => () => {
  const { el, signal, computed } = svc;
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => count())),
    el('button').props({ onclick: () => count(count() + 1) })('+')
  );
};
```

Behaviors are more portable than components because they have no UI coupling. A behavior can be used in Rimitive views, React, Vue, or anywhere else that can consume signals.

---

## Type Safety

Define your service contracts with TypeScript:

```typescript
import type { SignalFactory, ComputedFactory } from '@rimitive/signals';
import type { ElFactory } from '@rimitive/view/el';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

// Minimal contract for a component
type MinimalSvc = {
  signal: SignalFactory;
  computed: ComputedFactory;
  el: ElFactory<DOMAdapterConfig>;
};

// Component declares exactly what it needs
const MyComponent = (svc: MinimalSvc) => { /* ... */ };
```

This makes dependencies explicit and enables better tree-shakingâ€”if a component only needs `signal` and `el`, it doesn't pull in `effect`, `resource`, etc.

---

## Testing Portable Code

Portable code is easy to test because you control the service:

```typescript
import { describe, it, expect } from 'vitest';
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

describe('counter behavior', () => {
  it('increments count', () => {
    const svc = compose(SignalModule, ComputedModule, EffectModule)();
    const { count, increment } = counter(svc)(0);

    expect(count()).toBe(0);
    increment();
    expect(count()).toBe(1);
  });
});
```

No DOM mocking, no framework test utilitiesâ€”just functions and assertions.

---

## Shared State

Other frameworks have "context"â€”a way to pass values down the component tree without threading them through every intermediate component. In React, it's `createContext` and `useContext`. In Solid, it's similar.

Rimitive doesn't have a separate context primitive. It doesn't need one.

---

## The Pattern: Service Threading

In Rimitive, the **service is the context**. Components receive a service object containing the primitives they need. You can extend that service with additional state at any point in the tree.

```typescript
// Define your app-level shared state
type AppService = Service & {
  theme: Readable<'light' | 'dark'>;
  user: Readable<User | null>;
};

const App = (svc: Service) => {
  const { el, signal } = svc;

  // Create shared state
  const theme = signal<'light' | 'dark'>('light');
  const user = signal<User | null>(null);

  // Extend the service
  const appSvc: AppService = { ...svc, theme, user };

  return el('div')(
    Header(appSvc),
    Main(appSvc),
    Footer(appSvc)
  );
};
```

Child components receive the extended service and can access the shared state directly:

```typescript
const Header = (svc: AppService) => {
  const { el, computed, theme, user } = svc;

  return el('header').props({
    className: computed(() => theme() === 'dark' ? 'header-dark' : 'header-light')
  })(
    el('span')(computed(() => user()?.name ?? 'Guest'))
  );
};
```

No magic or implicit tree traversal. You can see exactly what's being passed where.

---

## Nested Overrides

Need to override a value for a subtree? Extend the service again:

```typescript
const DarkSection = (svc: AppService) => {
  const { el, signal } = svc;

  // Override theme for this subtree
  const darkSvc: AppService = { ...svc, theme: signal('dark') };

  return el('section')(
    // Everything in here sees theme = 'dark'
    ThemedCard(darkSvc),
    ThemedButton(darkSvc)
  );
};
```

---

## With Portable Components

The portable component pattern (`(svc) => (props) => spec`) works naturally with this:

```typescript
// Portable component that expects theme in service
const ThemedButton = ({ el, computed, theme }: AppService) => (props: { label: string }) => {
  return el('button').props({
    className: computed(() => `btn btn-${theme()}`)
  })(props.label);
};

// Usage with `use`
const App = ({ el, use }: AppService) => {
  return el('div')(
    use(ThemedButton)({ label: 'Click me' })
  );
};
```

When you call `use(ThemedButton)`, it passes the current service (including any extensions) to the component.

---

## TypeScript Tips

Define your extended service types explicitly:

```typescript
import type { Service } from './service';
import type { Readable } from '@rimitive/signals/types';

// Base service with your extensions
export type AppService = Service & {
  theme: Readable<'light' | 'dark'>;
  user: Readable<User | null>;
  // add more as needed
};

// For components that only need a subset
export type ThemedService = Service & {
  theme: Readable<'light' | 'dark'>;
};
```

Components declare what they need:

```typescript
// This component works with any service that has `theme`
const ThemedCard = (svc: ThemedService) => { ... };

// This one needs the full app service
const UserProfile = (svc: AppService) => { ... };
```

---

## Why Not a Context Primitive?

I considered adding one. The problem: context in other frameworks works through implicit tree traversalâ€”a component "finds" the nearest provider by walking up the tree at render time.

Rimitive components are just functions returning specs. There's no render cycle or "currently rendering" context to hook into. Any context system would either:

1. Require explicit scope passing (which is what we already have)
2. Add hidden magic that fights Rimitive's design philosophy

The service threading pattern is explicit, type-safe, and composes naturally. It's not as terse as `useContext()`, but you can always see what's happening.

---

## Error Handling

React has Error Boundaries. Solid has `<ErrorBoundary>`. You might expect Rimitive to have something similar.

It doesn'tâ€”because it doesn't need one.

---

## Why No Error Boundary Primitive?

In React and Solid, components are reactive functions that re-run during a render cycle. Errors can happen mid-render, and the framework needs a way to catch them and show fallback UI.

In Rimitive, components are just functions that return specs. They run once, produce a data structure, and that's it. Errors are plain JavaScript errors that propagate normally.

```typescript
const RiskyComponent = (svc: Service) => {
  const { el } = svc;

  // If this throws, it's a normal JS error
  const data = somethingThatMightThrow();

  return el('div')(data.value);
};
```

You handle it with... try/catch:

```typescript
const SafeWrapper = (svc: Service) => {
  const { el } = svc;

  try {
    return RiskyComponent(svc);
  } catch (e) {
    return el('div').props({ className: 'error' })(
      'Something went wrong'
    );
  }
};
```

---

## Handling Async Errors

For async operations, use the `resource` primitive. It tracks error state explicitly:

```typescript
const ProductList = (svc: Service) => {
  const { el, resource, match } = svc;

  const products = resource((signal) =>
    fetch('/api/products', { signal }).then(r => r.json())
  );

  return match(products, (state) => {
    if (state.status === 'pending') {
      return el('div')('Loading...');
    }
    if (state.status === 'error') {
      return el('div').props({ className: 'error' })(
        `Failed to load: ${state.error}`
      );
    }
    return el('ul')(
      ...state.value.map(p => el('li')(p.name))
    );
  });
};
```

The error state is part of the resource's reactive value.

---

## Effect Errors

Errors in effects propagate normally. If you need to catch them:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, EffectModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule, EffectModule)();
const { signal, effect } = svc;

const count = signal(0);

effect(() => {
  try {
    riskyOperation(count());
  } catch (e) {
    console.error('Effect failed:', e);
    // Handle gracefully
  }
});
```

Or wrap the risky operation in a function that returns a result type:

```typescript
type Result<T> = { ok: true; value: T } | { ok: false; error: unknown };

const safeRiskyOperation = (n: number): Result<string> => {
  try {
    return { ok: true, value: riskyOperation(n) };
  } catch (e) {
    return { ok: false, error: e };
  }
};

effect(() => {
  const result = safeRiskyOperation(count());
  if (!result.ok) {
    errorState(result.error);
  }
});
```

---

## Creating a Reusable Error Wrapper

If you want an Error Boundary-like pattern, create a behavior:

```typescript
const errorBoundary = (svc: Service) =>
  <T>(
    render: () => T,
    fallback: (error: unknown) => T
  ): T => {
    try {
      return render();
    } catch (e) {
      return fallback(e);
    }
  };

// Usage
const App = (svc: Service) => {
  const { el, use } = svc;
  const withErrorBoundary = use(errorBoundary);

  return el('div')(
    withErrorBoundary(
      () => RiskyComponent(svc),
      (e) => el('div')(`Error: ${e}`)
    )
  );
};
```

But honestly? Just use try/catch. It's JavaScript. It works.

---

## Forms

Forms are one of the most common UI patterns. Rimitive doesn't have a built-in form primitiveâ€”you compose form behavior from signals and computeds.

---

## The Field Pattern

A field is state plus metadata: the value, whether it's been touched, and any validation errors.

```typescript
type FieldOptions<T> = {
  initial: T;
  validate?: (value: T) => string | null;
};

const field = <T>(svc: SignalsSvc) => (opts: FieldOptions<T>) => {
  const { signal, computed } = svc;

  const value = signal(opts.initial);
  const touched = signal(false);

  const error = computed(() => {
    if (!touched()) return null;
    return opts.validate?.(value()) ?? null;
  });

  const valid = computed(() => !error());

  return {
    value,
    touched,
    error,
    valid,
    touch: () => touched(true),
    reset: () => {
      value(opts.initial);
      touched(false);
    },
  };
};
```

Usage:

```typescript
const emailField = svc(field)({
  initial: '',
  validate: (v) => {
    if (!v) return 'Required';
    if (!v.includes('@')) return 'Invalid email';
    return null;
  },
});

// Read state
emailField.value();   // ''
emailField.touched(); // false
emailField.error();   // null (not touched yet)

// User types and blurs
emailField.value('bad');
emailField.touch();
emailField.error();   // 'Invalid email'

// User fixes it
emailField.value('user@example.com');
emailField.error();   // null
emailField.valid();   // true
```

---

## Input Binding

Bind the field to an input element:

```typescript
const EmailInput = (svc: Service) => {
  const { el, on, signal, computed } = svc;

  const email = svc(field)({
    initial: '',
    validate: (v) => v.includes('@') ? null : 'Invalid email',
  });

  return el('div')(
    el('input')
      .props({
        type: 'email',
        value: email.value,
        className: computed(() => email.error() ? 'input-error' : ''),
      })
      .ref(
        on('input', (e) => email.value((e.target as HTMLInputElement).value)),
        on('blur', () => email.touch())
      )(),
    el('span').props({
      className: 'error-message',
      hidden: computed(() => !email.error()),
    })(computed(() => email.error() ?? ''))
  );
};
```

---

## Composing Fields into Forms

A form is a collection of fields with submission logic:

```typescript
type FormOptions<T> = {
  fields: T;
  onSubmit: (values: { [K in keyof T]: T[K] extends { value: Readable<infer V> } ? V : never }) => void | Promise<void>;
};

const form = <T extends Record<string, { value: Readable<unknown>; valid: Readable<boolean>; touch: () => void }>>(
  svc: SignalsSvc
) => (opts: FormOptions<T>) => {
  const { signal, computed } = svc;

  const submitting = signal(false);
  const submitError = signal<string | null>(null);

  const valid = computed(() =>
    Object.values(opts.fields).every((f) => f.valid())
  );

  const submit = async () => {
    // Touch all fields to show errors
    Object.values(opts.fields).forEach((f) => f.touch());

    if (!valid()) return;

    submitting(true);
    submitError(null);

    try {
      const values = Object.fromEntries(
        Object.entries(opts.fields).map(([k, f]) => [k, f.value()])
      );
      await opts.onSubmit(values as Parameters<typeof opts.onSubmit>[0]);
    } catch (e) {
      submitError(e instanceof Error ? e.message : 'Submission failed');
    } finally {
      submitting(false);
    }
  };

  return {
    fields: opts.fields,
    valid,
    submitting,
    submitError,
    submit,
  };
};
```

---

## Full Form Example

```typescript
const SignupForm = (svc: Service) => {
  const { el, on, computed, match } = svc;

  // Create fields
  const email = svc(field)({
    initial: '',
    validate: (v) => {
      if (!v) return 'Email is required';
      if (!v.includes('@')) return 'Invalid email';
      return null;
    },
  });

  const password = svc(field)({
    initial: '',
    validate: (v) => {
      if (!v) return 'Password is required';
      if (v.length < 8) return 'Password must be at least 8 characters';
      return null;
    },
  });

  // Create form
  const signup = svc(form)({
    fields: { email, password },
    onSubmit: async (values) => {
      await fetch('/api/signup', {
        method: 'POST',
        body: JSON.stringify(values),
      });
    },
  });

  // Field renderer helper
  const renderField = (
    label: string,
    type: string,
    f: ReturnType<ReturnType<typeof field<string>>>
  ) => el('div').props({ className: 'field' })(
    el('label')(label),
    el('input')
      .props({
        type,
        value: f.value,
        disabled: signup.submitting,
      })
      .ref(
        on('input', (e) => f.value((e.target as HTMLInputElement).value)),
        on('blur', () => f.touch())
      )(),
    match(f.error, (err) =>
      err ? el('span').props({ className: 'error' })(err) : null
    )
  );

  return el('form')
    .props({
      onsubmit: (e: Event) => {
        e.preventDefault();
        signup.submit();
      },
    })(
      renderField('Email', 'email', email),
      renderField('Password', 'password', password),

      // Submit error
      match(signup.submitError, (err) =>
        err ? el('div').props({ className: 'submit-error' })(err) : null
      ),

      // Submit button
      el('button')
        .props({
          type: 'submit',
          disabled: computed(() => signup.submitting() || !signup.valid()),
        })(
          computed(() => signup.submitting() ? 'Signing up...' : 'Sign Up')
        )
    );
};
```

---

## Validation Patterns

### Synchronous Validation

Most validation is synchronousâ€”check the value, return an error or null:

```typescript
const required = (msg = 'Required') => (v: string) => v ? null : msg;

const minLength = (n: number) => (v: string) =>
  v.length >= n ? null : `Must be at least ${n} characters`;

const pattern = (re: RegExp, msg: string) => (v: string) =>
  re.test(v) ? null : msg;

// Compose validators
const compose = <T>(...validators: ((v: T) => string | null)[]) => (v: T) => {
  for (const validate of validators) {
    const error = validate(v);
    if (error) return error;
  }
  return null;
};

// Usage
const username = svc(field)({
  initial: '',
  validate: compose(
    required('Username is required'),
    minLength(3),
    pattern(/^[a-z0-9_]+$/, 'Only lowercase letters, numbers, and underscores')
  ),
});
```

### Async Validation

For validation that requires a server check (e.g., username availability):

```typescript
const asyncField = <T>(svc: SignalsSvc) => (opts: {
  initial: T;
  validate?: (value: T) => string | null;
  asyncValidate?: (value: T) => Promise<string | null>;
  debounceMs?: number;
}) => {
  const { signal, computed, effect } = svc;

  const base = field(svc)(opts);
  const asyncError = signal<string | null>(null);
  const validating = signal(false);

  let timeout: number | undefined;

  // Run async validation when value changes
  effect(() => {
    const v = base.value();
    const syncError = opts.validate?.(v);

    // Skip async if sync fails
    if (syncError || !opts.asyncValidate) {
      asyncError(null);
      return;
    }

    clearTimeout(timeout);
    validating(true);

    timeout = window.setTimeout(async () => {
      try {
        const err = await opts.asyncValidate!(v);
        asyncError(err);
      } finally {
        validating(false);
      }
    }, opts.debounceMs ?? 300);
  });

  return {
    ...base,
    validating,
    error: computed(() => base.error() ?? asyncError()),
    valid: computed(() => !base.error() && !asyncError() && !validating()),
  };
};

// Usage
const username = svc(asyncField)({
  initial: '',
  validate: required('Username is required'),
  asyncValidate: async (v) => {
    const res = await fetch(`/api/check-username?q=${v}`);
    const { available } = await res.json();
    return available ? null : 'Username is taken';
  },
  debounceMs: 500,
});
```

---

## Dependent Fields

When one field's validation depends on another:

```typescript
const password = svc(field)({
  initial: '',
  validate: minLength(8),
});

const confirmPassword = svc(field)({
  initial: '',
  validate: (v) => {
    if (!v) return 'Required';
    if (v !== password.value()) return 'Passwords do not match';
    return null;
  },
});
```

---

## Field Arrays

For dynamic lists of fields (e.g., adding/removing tags):

```typescript
const fieldArray = <T>(svc: SignalsSvc) => (opts: {
  initial: T[];
  validateItem?: (value: T) => string | null;
}) => {
  const { signal, computed } = svc;

  const items = signal(
    opts.initial.map((v) => field(svc)({ initial: v, validate: opts.validateItem }))
  );

  const values = computed(() => items().map((f) => f.value()));
  const valid = computed(() => items().every((f) => f.valid()));

  return {
    items,
    values,
    valid,
    add: (value: T) => {
      items([...items(), field(svc)({ initial: value, validate: opts.validateItem })]);
    },
    remove: (index: number) => {
      items(items().filter((_, i) => i !== index));
    },
  };
};

// Usage
const tags = svc(fieldArray)({
  initial: ['javascript', 'typescript'],
  validateItem: (v) => v.length > 0 ? null : 'Tag cannot be empty',
});

tags.add('react');
tags.remove(0);
tags.values(); // ['typescript', 'react']
```

---

## When to Use This Pattern

**Good for:**
- Login/signup forms
- Settings pages
- Any form with validation feedback
- Multi-step wizards

**Overkill for:**
- Simple search inputs (just use a signal)
- Forms without validation
- One-off inputs that don't need error states

---

## Refs and DOM Access

Sometimes you need direct DOM accessâ€”for focus management, measurements, third-party library integration, or canvas drawing. Rimitive handles this with the `.ref()` method on elements.

---

## Basic Ref Usage

The `.ref()` method takes a callback that runs when the element is mounted:

```typescript
const AutofocusInput = ({ el }: Service) => {
  return el('input').ref((node) => {
    node.focus();
  })();
};
```

---

## Cleanup

Return a cleanup function from the callback:

```typescript
const ResizeObserved = (svc: Service) => {
  const { el, signal } = svc;
  const dimensions = signal({ width: 0, height: 0 });

  return el('div').ref((node) => {
    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      dimensions({ width, height });
    });

    observer.observe(node);

    // Return cleanup function
    return () => observer.disconnect();
  })(
    // ... children
  );
};
```

The cleanup runs when the element is removed from the DOM.

---

## Using Refs in Effects

If you need to access a DOM node from an effect, store it in a signal:

```typescript
const FocusOnCondition = ({ el, signal, effect }: Service) => {
  const inputRef = signal<HTMLInputElement | null>(null);
  const shouldFocus = signal(false);

  effect(() => {
    const node = inputRef();
    if (shouldFocus() && node) {
      node.focus();
    }
  });

  return el('div')(
    el('input').ref((node) => inputRef(node))(),
    el('button').props({
      onclick: () => shouldFocus(true)
    })('Focus Input')
  );
};
```

The signal-as-ref pattern works because:
- The signal holds the node reference
- Effects track the signal
- When the condition changes, the effect runs and has access to the node

---

## Passing Refs to Children

If a parent needs access to a child's DOM node, pass a callback:

```typescript
const Input = ({ el }: Service, props: { onRef?: (node: HTMLInputElement) => void }) => {
  return el('input').ref((node) => {
    props.onRef?.(node);
  })();
};

const Form = ({ el, use }: Service) => {
  let inputNode: HTMLInputElement | null = null;

  return el('form')(
    use(Input)({ onRef: (node) => { inputNode = node; } }),
    el('button').props({
      onclick: () => inputNode?.focus()
    })('Focus Input')
  );
};
```

Or with signals for reactive access:

```typescript
const Form = (svc: Service) => {
  const { el, signal, use } = svc;
  const inputRef = signal<HTMLInputElement | null>(null);

  return el('form')(
    use(Input)({ onRef: (node) => inputRef(node) }),
    el('button').props({
      onclick: () => inputRef()?.focus()
    })('Focus Input')
  );
};
```

---

## Third-Party Library Integration

Use refs to integrate non-reactive libraries:

```typescript
const Chart = (svc: Service, props: { data: Readable<ChartData> }) => {
  const { el, effect } = svc;

  return el('canvas').ref((canvas) => {
    // Initialize chart library
    const chart = new ChartLibrary(canvas, {
      data: props.data()
    });

    // Update chart when data changes
    const disposeEffect = effect(() => {
      chart.update(props.data());
    });

    // Return cleanup
    return () => {
      disposeEffect();
      chart.destroy();
    };
  })();
};
```

---

## Multiple Refs

For collections, store refs in a map:

```typescript
const ScrollableList = (svc: Service) => {
  const { el, signal, map } = svc;

  const items = signal(['a', 'b', 'c', 'd', 'e']);
  const itemRefs = new Map<string, HTMLElement>();

  const scrollToItem = (id: string) => {
    itemRefs.get(id)?.scrollIntoView({ behavior: 'smooth' });
  };

  return el('div')(
    el('div')(
      ...['a', 'b', 'c', 'd', 'e'].map(id =>
        el('button').props({ onclick: () => scrollToItem(id) })(`Go to ${id}`)
      )
    ),
    el('div').props({ style: 'height: 200px; overflow: auto' })(
      map(items, (item) =>
        el('div').props({ style: 'height: 100px' }).ref((node) => {
          itemRefs.set(item(), node);
          return () => itemRefs.delete(item());
        })(item)
      )
    )
  );
};
```

---

## Why Not `createRef()`?

Some frameworks have a standalone `createRef()` that returns an object with a `.current` property. Rimitive doesn't have this because:

1. The callback pattern is more explicit about timing
2. A signal holding the node serves the same purpose and integrates with reactivity
3. It's one less API to learn

If you want the `.current` pattern, it's trivial to create:

```typescript
const createRef = <T>() => {
  let current: T | null = null;
  return {
    get current() { return current; },
    set current(v: T | null) { current = v; },
    callback: (node: T) => { current = node; }
  };
};

// Usage
const ref = createRef<HTMLInputElement>();
el('input').ref(ref.callback)();
// later: ref.current?.focus()
```

But the signal pattern is usually better because it's reactive.

---

## Composition Over Stores

SolidJS has `createStore`. Vue has `reactive()`. These provide "deep reactivity"â€”you can mutate nested properties and the framework tracks the changes automatically.

Rimitive doesn't have stores. This is intentional.

---

## Why No Stores?

Deep reactivity requires proxies. Proxies have costs:

- **Magic behavior**: Property access triggers invisible tracking. Mutations trigger invisible updates. Hard to debug.
- **Performance overhead**: Every property access goes through the proxy trap.
- **Complexity**: Edge cases around arrays, Maps, Sets, class instances, etc.
- **Encourages sprawl**: Big nested state objects instead of focused, composable units.

There's nothing saying you can't create your own primitiveâ€”it's just that rimitive doesn't ship one by default.

---

## The Alternative: Composition

Instead of one big store, compose focused behaviors:

```typescript
// Instead of this:
const store = createStore({
  user: {
    profile: { name: '', avatar: '' },
    settings: { theme: 'light', notifications: true }
  },
  cart: {
    items: [],
    total: 0
  }
});

// Do this:
const userProfile = (svc: SignalsSvc) => () => {
  const name = svc.signal('');
  const avatar = svc.signal('');
  return {
    name,
    avatar,
    setName: (n: string) => name(n),
    setAvatar: (a: string) => avatar(a),
  };
};

const userSettings = (svc: SignalsSvc) => () => {
  const theme = svc.signal<'light' | 'dark'>('light');
  const notifications = svc.signal(true);
  return {
    theme,
    notifications,
    toggleTheme: () => theme(theme() === 'light' ? 'dark' : 'light'),
  };
};

const cart = (svc: SignalsSvc) => () => {
  const items = svc.signal<CartItem[]>([]);
  const total = svc.computed(() =>
    items().reduce((sum, item) => sum + item.price * item.qty, 0)
  );
  return {
    items,
    total,
    addItem: (item: CartItem) => items([...items(), item]),
    removeItem: (id: string) => items(items().filter(i => i.id !== id)),
  };
};
```

Each behavior:
- Has a clear, focused purpose
- Encapsulates its own logic
- Is independently testable
- Can be composed with others
- Is portable

---

## Composing Behaviors

Behaviors can depend on other behaviors by calling them directly:

```typescript
const checkout = (svc: SignalsSvc) => () => {
  const { computed } = svc;

  // Call other behaviors directly with the service
  const c = cart(svc)();
  const profile = userProfile(svc)();

  const canCheckout = computed(() =>
    c.items().length > 0 && profile.name() !== ''
  );

  const submit = async () => {
    if (!canCheckout()) return;
    await submitOrder({
      items: c.items(),
      customer: profile.name(),
    });
  };

  return { canCheckout, submit };
};
```

---

## Working with Arrays

For reactive arrays, use a signal holding an array:

```typescript
const todoList = ({ signal }: SignalsSvc) => () => {
  const items = signal<Todo[]>([]);

  return {
    items,
    add: (text: string) => {
      items([...items(), { id: crypto.randomUUID(), text, done: false }]);
    },
    toggle: (id: string) => {
      items(items().map(t =>
        t.id === id ? { ...t, done: !t.done } : t
      ));
    },
    remove: (id: string) => {
      items(items().filter(t => t.id !== id));
    },
  };
};
```

This follows an immutable pattern which is:
- Explicit (you see the update happening)
- Debuggable (you can log the before/after)
- Predictable (no proxy magic)

---

## When You Really Want Nested Updates

If you genuinely need to update nested data, create a focused updater:

```typescript
const nestedSettings = (svc: SignalsSvc) => () => {
  const settings = svc.signal({
    display: { theme: 'light', fontSize: 14 },
    privacy: { shareData: false, analytics: true },
  });

  // Focused updaters for specific paths
  const setTheme = (theme: string) => {
    settings({
      ...settings(),
      display: { ...settings().display, theme }
    });
  };

  const setFontSize = (size: number) => {
    settings({
      ...settings(),
      display: { ...settings().display, fontSize: size }
    });
  };

  // Or a generic path updater if you really need it
  const update = <K extends keyof Settings>(
    section: K,
    updates: Partial<Settings[K]>
  ) => {
    settings({
      ...settings(),
      [section]: { ...settings()[section], ...updates }
    });
  };

  return { settings, setTheme, setFontSize, update };
};
```

---

## But I Really Want Proxies

If you're convinced you need proxy-based stores, you can build them on top of Rimitive's primitives. The signals are thereâ€”wrap them in proxies if you want.

Or use an external store library and connect it via effects:

```typescript
import { createStore } from 'some-store-library';

const externalStore = createStore({ count: 0 });

const bridged = (svc: SignalsSvc) => () => {
  const count = svc.signal(externalStore.getState().count);

  // Sync from external store to signal
  externalStore.subscribe((state) => {
    count(state.count);
  });

  return { count };
};
```

But consider: if you're reaching for proxies, you might be fighting the framework. Rimitive's composition model works best when you embrace it.

---

## Async Loading States

React has Suspense. Solid has `<Suspense>` and `<Show>`. These handle async loading states declaratively.

Rimitive handles async state explicitly through two primitives: `resource` for reactive data fetching with automatic refetch, and `load` for simpler async boundaries. Both use `match` for rendering. No magic, no special componentsâ€”just reactive state.

---

## The Resource Pattern

The `resource` primitive wraps async operations and exposes their state reactively:

```typescript
const ProductList = (svc: Service) => {
  const { el, resource, match } = svc;

  const products = resource((signal) =>
    fetch('/api/products', { signal }).then(r => r.json())
  );

  // products() returns { status: 'pending' | 'ready' | 'error', value?, error? }
};
```

---

## Rendering Different States

Use `match` to render based on state:

```typescript
return match(products, (state) => {
  switch (state.status) {
    case 'pending':
      return Spinner(svc);
    case 'error':
      return ErrorMessage(svc, state.error);
    case 'ready':
      return ProductGrid(svc, state.value);
  }
});
```

Or use the convenience accessors:

```typescript
return el('div')(
  match(products.loading, (loading) =>
    loading
      ? Spinner(svc)
      : match(products.error, (error) =>
          error
            ? ErrorMessage(svc, error)
            : ProductGrid(svc, products.data()!)
        )
  )
);
```

The explicit approach is more verbose but clearer about what's happening.

---

## A Show Helper

If you want something closer to Solid's `<Show>`, create a simple helper:

```typescript
const show = <T, R>(
  when: () => T | null | undefined | false,
  render: (value: T) => R,
  fallback?: () => R
): R | undefined => {
  const value = when();
  if (value) return render(value);
  return fallback?.();
};

// Usage
return el('div')(
  show(
    () => products.data(),
    (data) => ProductGrid(svc, data),
    () => Spinner(svc)
  )
);
```

But this is just a functionâ€”nothing special about it.

---

## Multiple Resources

When loading multiple resources, handle them together:

```typescript
const Dashboard = (svc: Service) => {
  const { el, resource, computed, match } = svc;

  const user = resource((s) => fetchUser(s));
  const stats = resource((s) => fetchStats(s));
  const notifications = resource((s) => fetchNotifications(s));

  // Combine loading states
  const allLoading = computed(() =>
    user.loading() || stats.loading() || notifications.loading()
  );

  const anyError = computed(() =>
    user.error() || stats.error() || notifications.error()
  );

  return match(allLoading, (loading) => {
    if (loading) return Spinner(svc);

    const error = anyError();
    if (error) return ErrorMessage(svc, error);

    return el('div')(
      UserHeader(svc, user.data()!),
      StatsPanel(svc, stats.data()!),
      NotificationList(svc, notifications.data()!)
    );
  });
};
```

---

## Dependent Resources

When one resource depends on another:

```typescript
const ProductDetail = (svc: Service) => {
  const { el, resource, computed, match } = svc;

  const productId = svc.params.id; // from router

  const product = resource((s) =>
    fetch(`/api/products/${productId()}`, { signal: s }).then(r => r.json())
  );

  // Reviews depend on product being loaded
  const reviews = resource((s) => {
    const p = product.data();
    if (!p) return Promise.resolve([]); // No product yet, return empty

    return fetch(`/api/products/${p.id}/reviews`, { signal: s })
      .then(r => r.json());
  });

  return match(product, (state) => {
    if (state.status !== 'ready') {
      return state.status === 'pending' ? Spinner(svc) : ErrorMessage(svc, state.error);
    }

    return el('div')(
      ProductInfo(svc, state.value),
      match(reviews, (reviewState) =>
        reviewState.status === 'pending'
          ? el('div')('Loading reviews...')
          : reviewState.status === 'error'
            ? el('div')('Failed to load reviews')
            : ReviewList(svc, reviewState.value)
      )
    );
  });
};
```

---

## Refetching

Resources track dependencies and refetch automatically:

```typescript
const category = signal('electronics');

const products = resource((s) =>
  fetch(`/api/products?category=${category()}`, { signal: s })
    .then(r => r.json())
);

// Change category -> products automatically refetches
category('clothing');
```

Manual refetch is also available:

```typescript
el('button').props({
  onclick: () => products.refetch()
})('Refresh')
```

---

## The Load Pattern

For simpler async boundariesâ€”especially in SSR scenariosâ€”use `load()`:

```typescript
const ProductList = (svc: Service) => {
  const { el, load, match } = svc;

  return load(
    () => fetch('/api/products').then(r => r.json()),
    (state) => match(state.status, (status) => {
      switch (status) {
        case 'pending':
          return Spinner(svc);
        case 'error':
          return ErrorMessage(svc, state.error());
        case 'ready':
          return ProductGrid(svc, state.data()!);
      }
    })
  );
};
```

The key difference: `load()` takes a fetcher and a renderer. The renderer receives a state object with reactive properties (`status`, `data`, `error`) that you read by calling them.

### When to use each

**Use `resource`** when you need:
- Automatic refetching when dependencies change
- AbortController integration for request cancellation
- A reactive value you can pass around and read anywhere

**Use `load`** when you need:
- Simple one-shot data fetching
- SSR streaming with explicit data boundaries
- Direct control over the loading UI in one place

```typescript
// load() is ideal for SSR - data and UI are co-located
const Page = (svc: Service) => {
  const { el, load, match } = svc;

  return el('main')(
    load(
      () => fetchPageData(),
      (state) => match(state.status, (status) =>
        status === 'ready'
          ? PageContent(svc, state.data()!)
          : status === 'error'
            ? ErrorFallback(svc)
            : LoadingSkeleton(svc)
      )
    )
  );
};
```

---

## Cleanup

Resources should be disposed when no longer needed:

```typescript
const ProductPanel = (svc: Service) => {
  const { el, resource } = svc;

  const products = resource((s) => fetchProducts(s));

  // Cleanup when element is removed
  return el('div').ref(() => products.dispose)(
    // ... content
  );
};
```

---

## Package Reference

- [@rimitive/core](https://github.com/hejhi/rimitive/tree/main/packages/rimitive): Core composition (`compose`, `defineModule`, `merge`)
- [@rimitive/signals](https://github.com/hejhi/rimitive/tree/main/packages/signals): Reactive primitives (`signal`, `computed`, `effect`, `batch`)
- [@rimitive/view](https://github.com/hejhi/rimitive/tree/main/packages/view): UI primitives (`el`, `map`, `match`, `portal`, `load`)
- [@rimitive/router](https://github.com/hejhi/rimitive/tree/main/packages/router): Reactive routing (`matches`, `navigate()`, `query`)
- [@rimitive/resource](https://github.com/hejhi/rimitive/tree/main/packages/resource): Async data fetching with `resource()`
- [@rimitive/ssr](https://github.com/hejhi/rimitive/tree/main/packages/ssr): Server-side rendering and streaming
- [@rimitive/react](https://github.com/hejhi/rimitive/tree/main/packages/react): React bindings
