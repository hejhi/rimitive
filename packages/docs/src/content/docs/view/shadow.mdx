---
title: shadow()
description: Render children into an encapsulated shadow DOM.
---

The `shadow()` function renders children into a shadow root attached to the parent element—creating an isolated DOM subtree with encapsulated styles.

## Syntax

```typescript
shadow(options)(...children)
shadow(options).ref(callback)(...children)
shadow(options).props(newOptions)(...children)
```

### Parameters

**`options`** (optional)
: Configuration for the shadow root:
- `mode`: `'open'` or `'closed'` — whether the shadow root is accessible via `element.shadowRoot`
- `styles`: CSS string or array of strings to inject into the shadow root
- `delegatesFocus`: Whether to delegate focus to the shadow tree

**`children`**
: Element specs to render inside the shadow root.

### Return value

A spec for use with `mount()` or as a child of other elements.

## Description

Shadow DOM provides style encapsulation—styles defined inside the shadow root don't leak out, and parent styles don't leak in (with some exceptions like inherited properties).

```typescript
el('div').props({ className: 'host' })(
  shadow({ mode: 'open', styles: '.inner { color: blue; }' })(
    el('p').props({ className: 'inner' })('Styled inside shadow')
  )
)
```

The `.inner` class only exists inside this shadow root. External `.inner` styles won't affect it.

### Mode

- **`open`**: The shadow root is accessible via `element.shadowRoot`. Use this for most cases.
- **`closed`**: The shadow root is not accessible externally. Use for true encapsulation where you don't want consumers inspecting or modifying the shadow tree.

```typescript
// Open - shadowRoot is accessible
el('div')(shadow({ mode: 'open' })(content))
// element.shadowRoot returns the ShadowRoot

// Closed - shadowRoot is hidden
el('div')(shadow({ mode: 'closed' })(content))
// element.shadowRoot returns null
```

### Lifecycle with .ref()

Use `.ref()` to access the shadow root for imperative setup:

```typescript
el('div')(
  shadow({ mode: 'open' })
    .ref((shadowRoot) => {
      // Setup code runs when shadow is attached
      const editor = createCodeMirror({ root: shadowRoot });

      // Return cleanup function
      return () => editor.destroy();
    })
    (el('div').props({ className: 'editor-container' })())
)
```

Multiple `.ref()` callbacks can be chained:

```typescript
shadow({ mode: 'open' })
  .ref(setupEditor)
  .ref(setupTheme)
  .ref(trackAnalytics)
  (content)
```

### Updating options with .props()

Use `.props()` to update shadow options:

```typescript
const baseShadow = shadow({ mode: 'open' });

// Add styles later
baseShadow.props({ styles: css })(content)

// Or use a function to merge
baseShadow.props((current) => ({
  ...current,
  styles: [...(current.styles || []), additionalCss]
}))(content)
```

## Examples

### Encapsulated component

```typescript
const Card = (title: string, body: string) => {
  const styles = `
    .card {
      padding: 1rem;
      border: 1px solid #ccc;
      border-radius: 8px;
    }
    .title {
      font-weight: bold;
      margin-bottom: 0.5rem;
    }
  `;

  return el('div')(
    shadow({ mode: 'open', styles })(
      el('div').props({ className: 'card' })(
        el('div').props({ className: 'title' })(title),
        el('div')(body)
      )
    )
  );
};
```

### Third-party library integration

```typescript
const CodeEditor = (initialCode: string, onChange: (code: string) => void) => {
  return el('div').props({ className: 'editor-host' })(
    shadow({ mode: 'open' })
      .ref((shadowRoot) => {
        // Initialize CodeMirror inside the shadow root
        const editor = CodeMirror(shadowRoot, {
          value: initialCode,
          mode: 'javascript',
        });

        editor.on('change', () => onChange(editor.getValue()));

        return () => editor.toTextArea(); // cleanup
      })
      ()
  );
};
```

### Multiple style sources

```typescript
const baseStyles = `
  :host { display: block; }
  * { box-sizing: border-box; }
`;

const themeStyles = `
  .container { background: var(--bg, white); }
`;

const componentStyles = `
  .button { padding: 0.5rem 1rem; }
`;

el('custom-element')(
  shadow({
    mode: 'open',
    styles: [baseStyles, themeStyles, componentStyles]
  })(
    el('div').props({ className: 'container' })(
      el('button').props({ className: 'button' })('Click')
    )
  )
)
```

### Reactive content inside shadow

Signals and computed values work inside shadow DOM:

```typescript
const Counter = () => {
  const count = signal(0);

  return el('div')(
    shadow({ mode: 'open', styles: '.count { font-size: 2rem; }' })(
      el('span').props({ className: 'count' })(
        () => `Count: ${count()}`
      ),
      el('button').props({
        onclick: () => count(count() + 1)
      })('Increment')
    )
  );
};
```

## See also

- [el()](/view/el) — Create elements that can host shadow roots
- [portal()](/view/portal) — Render to different DOM locations (different use case)
