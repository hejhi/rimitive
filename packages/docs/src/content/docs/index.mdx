---
title: Write UI behaviors once. Use everywhere.
description: Lattice is a framework-agnostic state management library that lets you build truly reusable UI components that work in React, Vue, Svelte, and vanilla JavaScript.
template: splash
hero:
  title: Write UI behaviors once. <br/> Use everywhere.
  tagline: Stop rewriting the same dropdown, modal, or form logic for every framework. Build it once with Lattice and use it in React, Vue, Svelte, or vanilla JavaScript.
  actions:
    - text: Get Started in 5 Minutes
      link: /guides/getting-started/
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/yourusername/lattice
      icon: external
---

import { Card, CardGrid, Tabs, TabItem, Aside } from '@astrojs/starlight/components';

## The Problem We All Face

You've built an amazing dropdown component for your React app. Now your Vue team wants it. Then the Svelte team. Before you know it, you're maintaining three versions of the same component, fixing the same bugs three times, and adding features in triplicate.

**Sound familiar?**

## One Behavior, Every Framework

<Tabs>
  <TabItem label="React">
    ```tsx
    import { useSliceValues } from '@lattice/runtime/react';
    import { createDropdown } from './behaviors/dropdown';

    function Dropdown() {
      const { isOpen, toggle } = useSliceValues(createDropdown);
      return (
        <div>
          <button onClick={toggle}>Menu</button>
          {isOpen() && <div>Content</div>}
        </div>
      );
    }
    ```
  </TabItem>
  <TabItem label="Vue">
    ```vue
    <script setup>
    import { useSliceValues } from '@lattice/runtime/vue';
    import { createDropdown } from './behaviors/dropdown';

    const { isOpen, toggle } = useSliceValues(createDropdown);
    </script>

    <template>
      <div>
        <button @click="toggle">Menu</button>
        <div v-if="isOpen()">Content</div>
      </div>
    </template>
    ```
  </TabItem>
</Tabs>

The **same behavior code** powers all three components. Write once, test once, maintain once.

## Why Teams Choose Lattice

<CardGrid>
  <Card title="ðŸš€ Blazing Fast" icon="rocket">
    Our benchmarks show Lattice with store-react is **110x faster** than Redux and **6x faster** than Zustand for state updates.
  </Card>
  <Card title="ðŸ”§ Use Your Existing Tools" icon="puzzle">
    Lattice wraps your favorite state library. Keep using Redux DevTools, Zustand middleware, or Vue's reactivity. We enhance, not replace.
  </Card>
  <Card title="ðŸ“¦ Tiny Footprint" icon="document">
    Core + Runtime is just 1.5KB gzipped! While slightly larger than Zustand (588B), Lattice enables true cross-framework portability that no other solution offers.
  </Card>
  <Card title="ðŸ§© Composable Architecture" icon="star">
    Import only what you need. Just want state? Import `createStore` (0.1KB). Need composition? Add `compose` (+0.2KB). Build exactly what your app requires.
  </Card>
</CardGrid>

## The Development Experience

When you write a behavior once in Lattice, you get:

- **Unified testing** - Test the behavior logic once, not once per framework
- **Single source of truth** - Bug fixes and features propagate everywhere  
- **Consistent behavior** - The same interaction patterns across all your apps
- **Faster iteration** - Change the behavior logic and see it update everywhere instantly

## Composable by Design

Lattice isn't a monolithic library. Import only what you need:

```typescript
// Need just state management? (0.1 KB)
import { createStore } from '@lattice/core/store';

// Need composition too? (0.3 KB total)
import { createStore } from '@lattice/core/store';
import { compose } from '@lattice/core/compose';

// Building a full app? (1.5 KB total)
import { createSlice, compose } from '@lattice/core';
import { useSliceValues } from '@lattice/runtime';
```

<Aside>
  Every Lattice feature is available as a separate import. Build exactly what your app needs, nothing more.
</Aside>

## Start Building in 5 Minutes

```bash
npm install @lattice/core @lattice/runtime
```

Create your first portable behavior:

```typescript
import { createSlice } from '@lattice/core';

export const createCounter = createSlice(({ get, set }) => ({
  count: () => get().count || 0,
  increment: () => set({ count: get().count + 1 }),
  decrement: () => set({ count: get().count - 1 })
}));
```

That's it. This counter now works in any framework.

<Card title="Ready to stop writing the same code three times?" icon="rocket">
  <div class="sl-flex actions">
    <a href="/guides/getting-started/" class="action primary">
      Get Started â†’
    </a>
    <a href="/guides/examples/" class="action">
      See Examples
    </a>
  </div>
</Card>

---

<div class="sl-flex social-links">
  <a href="https://github.com/yourusername/lattice">GitHub</a>
  <a href="https://twitter.com/lattice">Twitter</a>
  <a href="/discord">Discord</a>
</div>