---
title: Lattice
description: An experimental collection of composable reactive primitives.
template: splash
hero:
  title: Lattice
  tagline: Portable reactive specs, composable services.
  actions:
    - text: Read the Docs
      link: /start-here/quick-start/
      icon: right-arrow
      variant: primary
    - text: GitHub
      link: https://github.com/hfour/lattice
      icon: external
---

**DISCLAIMER:**

This is a personal project in early development. I'm sharing it because the ideas might be interesting to others exploring similar problems.

## What is this?

Lattice is an exploration of an idea: defining reactivity, components, and UIs as **specifications** and **services**, with a functional api.

A **spec** is a portable specification or definition—it describes _what_ something is (a behavior, a UI, a component) without being tied to any particular runtime, renderer, or framework. A **service** is a composed set of primitives (signals, effects, element builders) that can "hydrate" a spec into a reactive instance.

```
spec + service = reactive instance
```

Most UI libraries couple these together. A React component is both the definition and the runtime. A Solid component assumes Solid's reactivity. I wanted to see what happens when you pull them apart—when specs are just functions that _receive_ well-defined, explicit, strongly typed reactive primitives rather than implicitly assuming them.

The result is an experimental set of packages for defining portable specs, composing services to hydrate them, and binding them to other frameworks:

- **Specs** — behavior functions, view blueprints (`RefSpec`), fragment definitions
- **Services** — composed reactive or UI primitives like `signal`, `computed`, `effect`, `el`, `map`, `match`
- **Adapters** — plug different rendering targets (DOM, SSR, Canvas) into the same specs

Lattice is just as much a pattern as it is a set of (tiny, tree-shakeable, performant, composable) libraries. It also requires no build and has no external dependencies (either 3rd party _or_ the DOM for that matter, unless you're using a DOM renderer or preset), so can be run anywhere where javascript exists.

---

## Quick Example

Here's a simple counter. `App` is a spec of a UI component—it returns a `RefSpec` describing the UI. `mount` hydrates it into the DOM.

```typescript
import { createDOMSvc } from '@lattice/view/presets/dom';

const { el, signal, computed, mount } = createDOMSvc();

const App = () => {
  const count = signal(0);

  return el('div')(
    el('p').props({ textContent: computed(() => `Count: ${count()}`) }),
    el('button').props({ onclick: () => count(count() + 1) })('Increment')
  );
};

mount(App(), document.body);
```

The preset (`createDOMSvc`) bundles signals and DOM view primitives together. But you can also compose services yourself:

```typescript
import { createSignalsSvc } from '@lattice/signals/presets/core';
import { createDOMViewSvc } from '@lattice/view/presets/dom';

// Shared signals service
const signals = createSignalsSvc();

// View services that use the same signals
const dom = createDOMViewSvc(signals);
const canvas = createCanvasViewSvc(signals); // your custom adapter

// Same signal, multiple rendering targets
const position = signals.signal({ x: 0, y: 0 });
```

Or go lower and compose individual primitives, or even swap out the entire underlying reactive system, if you want, by replacing the `helpers` yourself:

```typescript
import { compose } from '@lattice/lattice';
import { Signal, Computed, createHelpers } from '@lattice/signals';

const helpers = createHelpers();
const svc = compose({ signal: Signal(), computed: Computed() }, helpers);
```

Same idea at different levels: specs receive services, services are composed from primitives.

---

## Portable Behavior Specs

Part of the impetus for this library was exploring the idea of defining strongly typed reactive behavior ahead of time, while decoupling it from a UI component. I've always been inspired by [downshift](https://www.downshift-js.com/use-select/):

> You have a custom select dropdown in your application and you want it to perform exactly the same as the native HTML select in terms of accessibility and functionality. For consistency reasons, you want it to follow the ARIA design pattern for a select. You also want this solution to be simple to use and flexible so you can tailor it to your needs.

And [jotai atoms](https://jotai.org/docs/core/atom):

> The atom function is to create an atom config. We call it "atom config" as it's just a definition and it doesn't yet hold a value. We may also call it just "atom" if the context is clear.

Along with the extensibility and determinism of [ProseMirror](https://prosemirror.net), as well as the reactive FRP-ish algorithmic _beauty_ and performance of [alien-signals](https://github.com/stackblitz/alien-signals) and [Reactively](https://github.com/milomg/reactively), of which the Lattice signals library is (**strongly**) modeled after (hybrid push/pull and graph coloring with a slightly different implementation and a couple twists here and there).

But basically, the idea that there should be a way to capture these reactive patterns and UIs without coupling them to each other, or to a framework, or even to a rendering environment.

Lattice enables the creation of headless "behaviors" (a reactive behavioral spec, if you will)—simple functions that encapsulate reactive behavior, receive a service, and return a reactive api. This spec defines _what_ the behavior is; the service provides _how_ it becomes reactive.

Define the spec once:

```typescript
// behaviors/counter.ts
export const counter =
  (svc: ReactiveSvc) =>
  (initial = 0) => {
    const count = svc.signal(initial);
    const doubled = svc.computed(() => count() * 2);

    return {
      count,
      doubled,
      increment: () => count(count() + 1),
    };
  };
```

Use in Lattice views:

```typescript
const { use, el, computed } = createDOMSvc();

// `use` hydrates the spec with the current service
function Counter() {
  const c = use(counter);

  return el('button').props({ onclick: c.increment })(
    computed(() => `Count: ${c.count()}`)
  );
}
```

Or in React:

```tsx
import { createHook, useSubscribe } from '@lattice/react';

// createHook hydrates the spec and hooks it into React's reactive model, but at the end of the day,
// `counter` is receiving a reactive service
const useCounter = createHook(counter);

function Counter() {
  const c = useCounter(10);
  const count = useSubscribe(c.count);
  return <button onClick={c.increment}>Count: {count}</button>;
}
```

Same spec, different services. The behavior is portable.

A **very important distinction**, though: in Lattice, functions (or components) that create or return specs are **not** reactive closures, like in most frameworks. Instead, we use reactive primitives to define our own brightly lit reactive boundaries.

**There is no concept of "re-renders" in functions that return specs**, despite the resemblence of these functions to other reactive frameworks. Reactivity only exists within the primitives themselves, as defined by their own api. This allows complete freedom in terms of what you decide to do within these functions, as long as you provide the service at the right time, in the right shape.

---

## Composing Specs

Specs can of course compose other specs as well. Consider open/close state—the same logic applies to accordions, dropdowns, modals, tooltips, and collapsible sections. We can capture that pattern once:

```typescript
// behaviors/disclosure.ts
export const disclosure =
  ({ signal, computed }: ReactiveSvc) =>
  (initialOpen = false) => {
    const isOpen = signal(initialOpen);

    return {
      isOpen,
      open: () => isOpen(true),
      close: () => isOpen(false),
      toggle: () => isOpen(!isOpen()),
      triggerProps: computed(() => ({
        'aria-expanded': isOpen(),
      })),
      contentProps: computed(() => ({
        hidden: !isOpen(),
      })),
    };
  };
```

Now a `dropdown` spec can compose this with keyboard handling:

```typescript
// behaviors/dropdown.ts
export const dropdown = ({ use }: ReactiveSvc) => {
  // Provide the disclosure spec with the same reactive service, via the `use` helper, and gain access
  // to the underlying behavior to compose in
  const useDisclosure = use(disclosure);

  return (options?: { initialOpen?: boolean }) => {
    const { close, isOpen, toggle, triggerProps, contentProps } = useDisclosure(
      options?.initialOpen ?? false
    );

    const handlers = {
      onKeyDown: (e: KeyboardEvent) => {
        if (e.key === 'Escape') close();
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggle();
        }
      },
    };

    return { isOpen, toggle, triggerProps, contentProps, handlers };
  };
};
```

The same `disclosure` spec could be composed into an accordion, modal, or tooltip—each adding its own semantics on top of the shared open/close logic.

---

## Specs Everywhere

This pattern also extends to views. When you write `el('div')(...)`, you're not _creating_ a DOM element—you're creating a `RefSpec`, a blueprint _of_ a dom element. The spec becomes a real element only when hydrated with an adapter.

```typescript
// This returns a RefSpec, not a DOM element
// It is STRONGLY TYPED. `props` for `el` are all the valid dom attributes for a button, in this case
const Button = (label: string) =>
  el('button').props({ className: 'btn' })(label);

// The spec can be used multiple times
const save = Button('Save');
const cancel = Button('Cancel');

// mount() turns the specs into real DOM
mount(el('div')(save, cancel), document.body);
```

The API returns specs everywhere:

- Behavior functions return reactive state specs
- `el()` returns `RefSpec` (element blueprints)
- `map()` and `match()` return fragment specs

The spec/service separation is what enables portability and extensability. The same spec can be provided with different services (DOM adapter, SSR adapter, test adapter) or composed into larger specs before "hydration". Speaking of hydration, this model lends itself really well to ssr and islands. The lattice `island` library uses [linkedom](https://github.com/WebReflection/linkedom) under the hood by creating a renderer for it. But we also have a separate renderer for hydration of islands in the client, and we can dynamically swap them based on the environment.

But again, it's completely decoupled. You can easily write your own ssr library, or even swap out the renderer on ours if you want. Or swap in a different hydration strategy. It all depends on how low-level you want to go, but you essentially own the entire system (with the exception of the lattice compositional package itself, though...it's so tiny, honestly you could just rewrite that too if you wanted).

---

## Layers

The packages are organized in layers. You can stay at the highest level (presets) or go deeper for more control.

- Highest level: Bundled services. Import, call, use (`createDOMSvc()`, `createSignalsSvc()`)
- Medium level: Compose services yourself. Share signals across adapters, add instrumentation (`compose()`, `createHelpers()`)
- Low level: Define new primitives using the same patterns (`defineService()`)

---

## Packages

| Package            | Purpose                                                         |
| ------------------ | --------------------------------------------------------------- |
| `@lattice/signals` | Reactive primitives: signal, computed, effect, batch, subscribe |
| `@lattice/view`    | View specs with adapter system                                  |
| `@lattice/router`  | Routing with nested layouts                                     |
| `@lattice/islands` | SSR and partial hydration                                       |
| `@lattice/react`   | React bindings for hydrating specs                              |
| `@lattice/lattice` | Service composition layer                                       |

---

## Status

This is alpha software. I'm using it to explore ideas around specs, services, and composable reactivity. If you're interested in these problems, feel free to look around. I test the _hell_ out of it and benchmark everything, but it's not battle-tested in production anywhere yet, so the usual disclaimers apply.
