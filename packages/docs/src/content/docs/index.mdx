---
title: Rimitive
description: Type-safe reactive primitives, atomic tooling, and compositional patterns you can use anywhere
template: splash
hero:
  image:
    file: ../../assets/rimitive-logo.png
  title: Rimitive
  tagline: Type-safe reactive primitives, atomic tooling, and compositional patterns you can use anywhere
  actions:
    - text: Get Started
      link: /guides/getting-started/
      icon: right-arrow
      variant: primary
    - text: GitHub
      link: https://github.com/hejhi/rimitive
      icon: external
---

import { LinkCard } from '@astrojs/starlight/components';

## Reactivity With Pizzazz

Rimitive grows with you:
- from your most simple state management use cases
- to your UI
- to routing
- to SSR with streaming and beyond

...without forcing you commit to any framework, build, or transpilation. Everything is opt-in, swappable, and fully customizable ðŸ› ï¸.

## Start with Simple State

Everything in Rimitive starts with a **reactive service**:

```typescript
const { signal, computed, effect } = compose(
  SignalModule,
  ComputedModule,
  EffectModule
);

const you = signal('ðŸ«¸');
const rimitive = signal('ðŸ«·');
const highFive = computed(() => `${you()}ðŸ’¥${rimitive()}`);

effect(() => console.log(highFive())); // ðŸ«¸ðŸ’¥ðŸ«·
```

## Add a UI

The service composes all the modules you want to use from Rimitive, using dependency injection under the hood:

```ts
const { signal, computed, el, mount } = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // Add these ðŸ‘‡
  createElModule(createDOMAdapter()),
  MountModule
);

const App = () => {
  const together = signal(false);

  return el('div')(
    el('p').props({
      textContent: computed(() => (together() ? 'ðŸ«¸ðŸ’¥ðŸ«·' : 'ðŸ«¸   ðŸ«·')),
    }),
    el('button').props({ onclick: () => together(!together()) })('High five!')
  );
};

document.body.appendChild(mount(App()).element!);
```

## Indulge in the Tooling

```ts
const { router, el, match } = compose(
  // ... signal modules, view modules, and ðŸ‘‡
  createRouterModule([
    { id: 'ready', path: '' },
    { id: 'high-five', path: 'high-five' },
    { id: 'celebrate', path: 'celebrate/:style' },
  ])
);

// Routes are reactive and pair nicely with `match`
match(router.matches, (routes) => {
  const route = routes[0];
  switch (route?.id) {
    case 'ready': return Ready();        // ðŸ«¸   ðŸ«·
    case 'high-five': return HighFive(); // ðŸ«¸ðŸ’¥ðŸ«·
    case 'celebrate': return Celebrate({ style: route.params.style }); // ðŸŽ‰
    default: return Lost();              // ðŸ¤·
  }
});

// Navigate programmatically
router.navigate('/celebrate/reactively');
```

Routing, async resources, SSR, streamingâ€”building off the same primitives.

## What Makes It Different

**Reactivity lives in the primitives, not in components.** No component-level re-renders, reconciliation, rules, builds, transpilation, or magical closures. They return a **spec** of a reactive UI that can be mounted and unmounted. That's it! 

**Portable Components and Behaviors.** Your reactive logic isn't tied to a component model. Write a `disclosure` behavior once, use it in Rimitive views, React, or anything else that speaks signals.

**Transparent architecture.** Every layer is swappable: the reactive graph, the scheduler, the renderer. Rimitive's own modules are built with `defineModule()`â€”the same tool you have.

---

<LinkCard
  title="Getting Started"
  href="/guides/getting-started/"
/>
