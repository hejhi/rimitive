---
title: "lattice package"
sidebar:
  label: "lattice"
  badge:
    text: "pkg"
    variant: "success"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../../) &gt; [@lattice/lattice](../)

## lattice package

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[compose(modules)](../compose/)


</td><td>

Compose modules into a unified context.

Resolves the dependency graph automatically - you only need to pass the modules you want, and their dependencies are included transitively.

Returns a `use()` function that provides access to the composed context: - `use()` - Returns the context directly - `use(callback)` - Passes the context to callback and returns its result


</td></tr>
<tr><td>

[compose(args)](../compose/)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](../createinstrumentation/)


</td><td>

Create an instrumentation context from configuration.

This is the main entry point for setting up instrumentation. Returns `undefined` if instrumentation is disabled, allowing safe optional chaining in production.

Type overloads provide precise return types: - `enabled: false` → always returns `undefined` - `enabled: true` with providers → always returns `InstrumentationContext` - Otherwise → `InstrumentationContext | undefined`


</td></tr>
<tr><td>

[createInstrumentation(config)](../createinstrumentation/)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](../createinstrumentation/)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](../createinstrumentation/)


</td><td>


</td></tr>
<tr><td>

[defineModule(definition)](../definemodule/)


</td><td>

Define a module - the fundamental building block of Lattice composition.

Modules declare dependencies on other modules and provide a create function that receives resolved dependencies and returns the implementation.


</td></tr>
<tr><td>

[devtoolsProvider(options)](../devtoolsprovider/)


</td><td>

Create a DevTools instrumentation provider.

Sends instrumentation events to the Lattice DevTools browser extension via `window.postMessage`<!-- -->. In debug mode, also logs to the console.


</td></tr>
<tr><td>

[extend(use, extender)](../extend/)


</td><td>

Extend a composed context with additional functionality.

Takes a `Use<TSvc>` and an extender function, returning a new `Use<TExtended>`<!-- -->.


</td></tr>
<tr><td>

[isDevtoolsAvailable()](../isdevtoolsavailable/)


</td><td>

Check if Lattice DevTools extension is available in the current environment.


</td></tr>
<tr><td>

[isModule(value)](../ismodule/)


</td><td>

Check if a value is a Module


</td></tr>
</tbody></table>

## Interfaces

<table><thead><tr><th>

Interface


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[AnyModule](../anymodule/)


</td><td>

Base module interface for dependency arrays. Uses interface + method syntax for bivariant function parameters. This allows Module<specific> to be assignable to AnyModule.


</td></tr>
<tr><td>

[Module](../module/)


</td><td>

A module definition - the unit of composition in Lattice.

Modules declare their dependencies and provide a create function that receives resolved dependencies and returns the implementation.


</td></tr>
<tr><td>

[ModuleDefinition](../moduledefinition/)


</td><td>

Input type for defineModule - same as Module but without status and with optional dependencies.


</td></tr>
</tbody></table>

## Variables

<table><thead><tr><th>

Variable


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[STATUS\_MODULE](../status_module/)


</td><td>

Status constant for module type discrimination


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ComposedContext](../composedcontext/)


</td><td>

The composed context type from a tuple of Modules.

Maps module names to their implementations and adds a `dispose()` method.


</td></tr>
<tr><td>

[ComposeOptions](../composeoptions/)


</td><td>

Options for composing modules


</td></tr>
<tr><td>

[DevtoolsProviderOptions](../devtoolsprovideroptions/)


</td><td>

Options for the DevTools instrumentation provider.


</td></tr>
<tr><td>

[InstrumentationConfig](../instrumentationconfig/)


</td><td>

Configuration for creating an instrumentation context.


</td></tr>
<tr><td>

[InstrumentationContext](../instrumentationcontext/)


</td><td>

Instrumentation context for debugging and profiling.

Passed to the `instrument` hook of modules when instrumentation is enabled.


</td></tr>
<tr><td>

[InstrumentationEvent](../instrumentationevent/)


</td><td>

An instrumentation event emitted by services.


</td></tr>
<tr><td>

[InstrumentationProvider](../instrumentationprovider/)


</td><td>

An instrumentation provider that receives and processes events.

Providers are the output targets for instrumentation data. Examples: DevTools, logging, analytics, performance monitoring.


</td></tr>
<tr><td>

[ModuleDeps](../moduledeps/)


</td><td>

Helper type to extract the deps type from a Module


</td></tr>
<tr><td>

[ModuleImpl](../moduleimpl/)


</td><td>

Helper type to extract the implementation type from a Module


</td></tr>
<tr><td>

[ModuleName](../modulename/)


</td><td>

Helper type to extract the name from a Module


</td></tr>
<tr><td>

[ServiceContext](../servicecontext/)


</td><td>

Context provided to modules for lifecycle management.

Passed to `init`<!-- -->, `destroy`<!-- -->, and `instrument` hooks.


</td></tr>
<tr><td>

[ServiceImpl](../serviceimpl/)


</td><td>

Extract the implementation type from a Module.


</td></tr>
<tr><td>

[ServiceName](../servicename/)


</td><td>

Extract the name from a Module.


</td></tr>
<tr><td>

[UnionToIntersection](../uniontointersection/)


</td><td>

Utility type: Convert a union to an intersection. Used internally to combine types.


</td></tr>
<tr><td>

[Use](../use/)


</td><td>

A callable returned by `compose()` that provides access to the module context.

Can be called in two ways: - `use()` - Returns the context directly - `use(callback)` - Passes the context to callback and returns its result


</td></tr>
</tbody></table>

