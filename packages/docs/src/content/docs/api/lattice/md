---
title: "lattice package"
sidebar:
  label: "lattice"
  badge:
    text: "pkg"
    variant: "success"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../../) &gt; [@lattice/lattice](../)

## lattice package

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[compose(factories, deps, options)](../compose/)


</td><td>

Compose service factories into a unified context with shared dependencies.

This is the primary way to create a Lattice context. It supports three patterns:

\*\*Pattern 1: Factory object + deps\*\* (recommended for most cases) Pass an object of service factories and shared dependencies.


</td></tr>
<tr><td>

[compose(services)](../compose/)


</td><td>


</td></tr>
<tr><td>

[compose(options, services)](../compose/)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](../createinstrumentation/)


</td><td>

Create an instrumentation context from configuration.

This is the main entry point for setting up instrumentation. Returns `undefined` if instrumentation is disabled, allowing safe optional chaining in production.

Type overloads provide precise return types: - `enabled: false` → always returns `undefined` - `enabled: true` with providers → always returns `InstrumentationContext` - Otherwise → `InstrumentationContext | undefined`


</td></tr>
<tr><td>

[createInstrumentation(config)](../createinstrumentation/)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](../createinstrumentation/)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](../createinstrumentation/)


</td><td>


</td></tr>
<tr><td>

[defineService(factory)](../defineservice/)


</td><td>

Define a composable service factory with dependency injection.

This is the foundational building block for creating Lattice services. It implements a double-function pattern: 1. Outer function receives dependencies (injected at composition time) 2. Inner function receives user arguments (passed when creating instances)

The returned factory has a `.create(deps)` method that wires dependencies.


</td></tr>
<tr><td>

[devtoolsProvider(options)](../devtoolsprovider/)


</td><td>

Create a DevTools instrumentation provider.

Sends instrumentation events to the Lattice DevTools browser extension via `window.postMessage`<!-- -->. In debug mode, also logs to the console.


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[CreateContextOptions](../createcontextoptions/)


</td><td>

Options for creating a composed context


</td></tr>
<tr><td>

[DefinedService](../definedservice/)


</td><td>

A service factory returned by `defineService()`<!-- -->.

Has a `.create(deps)` method that wires dependencies. This is what you pass to `compose()`<!-- -->.


</td></tr>
<tr><td>

[DevtoolsProviderOptions](../devtoolsprovideroptions/)


</td><td>

Options for the DevTools instrumentation provider.


</td></tr>
<tr><td>

[ExtractDeps](../extractdeps/)


</td><td>

Extract the combined dependency type from a record of DefinedServices.

Used by `compose()` to infer the required deps parameter.


</td></tr>
<tr><td>

[InstrumentationConfig](../instrumentationconfig/)


</td><td>

Configuration for creating an instrumentation context.


</td></tr>
<tr><td>

[InstrumentationContext](../instrumentationcontext/)


</td><td>

Instrumentation context for debugging and profiling.

Passed to the `instrument` hook of services when instrumentation is enabled.


</td></tr>
<tr><td>

[InstrumentationEvent](../instrumentationevent/)


</td><td>

An instrumentation event emitted by services.


</td></tr>
<tr><td>

[InstrumentationProvider](../instrumentationprovider/)


</td><td>

An instrumentation provider that receives and processes events.

Providers are the output targets for instrumentation data. Examples: DevTools, logging, analytics, performance monitoring.


</td></tr>
<tr><td>

[LatticeContext](../latticecontext/)


</td><td>

The composed context type for a tuple of ServiceDefinitions.

Maps service names to their implementations and adds a `dispose()` method.


</td></tr>
<tr><td>

[Service](../service/)


</td><td>

A factory that creates service instances with injected dependencies.

Services are created by `defineService` and have a `.create(deps)` method that wires dependencies and returns a `ServiceDefinition`<!-- -->.


</td></tr>
<tr><td>

[ServiceContext](../servicecontext/)


</td><td>

Context provided to services for lifecycle management.

Passed to `init`<!-- -->, `destroy`<!-- -->, `adapt`<!-- -->, and `instrument` hooks.


</td></tr>
<tr><td>

[ServiceDefinition](../servicedefinition/)


</td><td>

A service definition that can be composed into a Lattice context.

ServiceDefinitions are the building blocks of Lattice composition. They describe an implementation plus optional lifecycle hooks.


</td></tr>
<tr><td>

[ServiceImpl](../serviceimpl/)


</td><td>

Extract the implementation type from a ServiceDefinition.


</td></tr>
<tr><td>

[ServiceName](../servicename/)


</td><td>

Extract the name from a ServiceDefinition.


</td></tr>
<tr><td>

[Svc](../svc/)


</td><td>

The composed context type for object-based composition.

Extracts impl types from service factories, preserving key names. This is the return type of `compose({ signal: Signal(), ... }, deps)`<!-- -->.


</td></tr>
<tr><td>

[UnionToIntersection](../uniontointersection/)


</td><td>

Utility type: Convert a union to an intersection. Used internally to combine dependency requirements.


</td></tr>
</tbody></table>

