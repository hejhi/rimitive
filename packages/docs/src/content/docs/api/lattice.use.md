<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@lattice/lattice](./lattice.md) &gt; [Use](./lattice.use.md)

## Use type

A callable returned by `compose()` that provides access to the module context.

`Use` is both a function AND an object with all service properties: - Call `use(fn)` to invoke a portable/behavior with the service context - Access `use.signal`<!-- -->, `use.el`<!-- -->, etc. directly as properties

When you call `use(fn)`<!-- -->, the callback receives the `Use` object itself, allowing nested portables to call other portables.

**Signature:**

```typescript
export type Use<TSvc> = {
    <TResult>(fn: (svc: Use<TSvc>) => TResult): TResult;
} & TSvc;
```
**References:** [Use](./lattice.use.md)

## Example


```ts
import { compose } from '@lattice/lattice';
import { SignalModule, ComputedModule } from '@lattice/signals/extend';

const svc = compose(SignalModule, ComputedModule);

// Access services directly as properties
const count = svc.signal(0);
const doubled = svc.computed(() => count() * 2);

// Or invoke a portable/behavior
const Counter = svc((ctx) => () => {
  const count = ctx.signal(0);
  return { value: count };
});

// Inside a portable, you can do both:
const MyComponent = svc((ctx) => {
  // Call ctx() with another portable (ctx is also callable)
  const behavior = ctx(someBehavior);

  // Access services directly
  const { signal, el } = ctx;

  return () => { ... };
});
```

