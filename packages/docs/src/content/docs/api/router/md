---
title: "router package"
sidebar:
  label: "router"
  badge:
    text: "pkg"
    variant: "success"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../) &gt; [@lattice/router](./)

## router package

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[connect(wrapper)](./connect/)


</td><td>

Standalone connect function - doesn't require a router instance

Creates a connected component that receives route context (children, params) when mounted via router.mount(). Works identically on server and client.


</td></tr>
<tr><td>

[createLocationFactory()](./createlocationfactory/)


</td><td>

Create location factory that provides reactive access to URL state


</td></tr>
<tr><td>

[createRouter(viewSvc, config)](./createrouter/)


</td><td>

Create a router instance

The router is a separate app-level service that takes a view service as input. It manages navigation state and provides routing primitives.


</td></tr>
<tr><td>

[defineRoutes(rootPath, rootComponent)](./defineroutes/)


</td><td>

Define routes without requiring a router instance


</td></tr>
<tr><td>

[Link(props)](./link/)


</td><td>

Link builder function

Link is inherently DOM-coupled (uses window.history, MouseEvent, href, onclick). Routers are web browser concepts - no need for adapter abstraction here.


</td></tr>
<tr><td>

[matchPath(pattern, path)](./matchpath/)


</td><td>

Matches a URL path against a route pattern (exact match)

Supports exact string matching, path parameters using :paramName syntax, and wildcard '\*' for catch-all


</td></tr>
</tbody></table>

## Variables

<table><thead><tr><th>

Variable


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[STATUS\_ROUTE\_SPEC](./status_route_spec/)


</td><td>

Status bit for route specs - next power of 2 after STATUS\_COMMENT (16)


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ConnectedComponent\_2](./connectedcomponent_2/)


</td><td>

Connected component type - a function that receives route context


</td></tr>
<tr><td>

[ConnectedComponent](./connectedcomponent/)


</td><td>

A connected component that can be instantiated with route context


</td></tr>
<tr><td>

[ConnectedSvc](./connectedsvc/)


</td><td>

Connected service - merged view service + route service

This is the service passed to connected components, enabling them to use whatever adapter is provided (hydrating or regular) rather than pulling from a singleton.


</td></tr>
<tr><td>

[ConnectMethod](./connectmethod/)


</td><td>

The connect impl signature


</td></tr>
<tr><td>

[DefineRoutesContext](./defineroutescontext/)


</td><td>


</td></tr>
<tr><td>

[ElMethod\_2](./elmethod_2/)


</td><td>


</td></tr>
<tr><td>

[ElMethod](./elmethod/)


</td><td>


</td></tr>
<tr><td>

[LinkFactory](./linkfactory/)


</td><td>

Link factory type

Link is DOM-only - no need for generic adapter abstraction


</td></tr>
<tr><td>

[LinkOpts](./linkopts/)


</td><td>

Options passed to Link factory

Link is DOM-only - routing with window.history is a web browser concept


</td></tr>
<tr><td>

[LocationFactory](./locationfactory/)


</td><td>

Location factory type


</td></tr>
<tr><td>

[LocationOpts](./locationopts/)


</td><td>

Options passed to location factory


</td></tr>
<tr><td>

[LocationSvc](./locationsvc/)


</td><td>

Location - reactive access to URL components


</td></tr>
<tr><td>

[MatchFunction](./matchfunction/)


</td><td>

Match function type


</td></tr>
<tr><td>

[RootContext](./rootcontext/)


</td><td>

Root context returned by router.root() Provides scoped route creation and a create method for finalizing the route tree


</td></tr>
<tr><td>

[RootMethod](./rootmethod/)


</td><td>

Root method signature - defines the always-rendered root layout


</td></tr>
<tr><td>

[RouteBuilder](./routebuilder/)


</td><td>

A route builder - returned by route() before children are applied


</td></tr>
<tr><td>

[RouteContext](./routecontext/)


</td><td>

Route context passed to connect wrapper

Contains route-specific data (children, params) for routing. Service injection is handled separately via the svc() middleware pattern.


</td></tr>
<tr><td>

[RouteMatch](./routematch/)


</td><td>

Matched route information


</td></tr>
<tr><td>

[RouteMetadata](./routemetadata/)


</td><td>

Route-specific metadata


</td></tr>
<tr><td>

[RouteMethod](./routemethod/)


</td><td>

Route method signature


</td></tr>
<tr><td>

[RouteNode](./routenode/)


</td><td>

A single route node in the tree


</td></tr>
<tr><td>

[RouteParams](./routeparams/)


</td><td>

Route parameter map extracted from path patterns e.g., '/products/:id' -<!-- -->&gt; { id: string }


</td></tr>
<tr><td>

[Router](./router/)


</td><td>

Router object returned by createRouter Generic over TConfig for type safety with adapter-specific implementations


</td></tr>
<tr><td>

[RouterConfig](./routerconfig/)


</td><td>

Router configuration


</td></tr>
<tr><td>

[RouteSpec](./routespec/)


</td><td>

RouteSpec wraps a RefSpec with routing metadata Uses true wrapper pattern - delegates to internal RefSpec via closure Status is ONLY STATUS\_ROUTE\_SPEC (32) - not combined with STATUS\_REF\_SPEC The wrapped RefSpec is kept internal and accessed via delegation

Note: Does not extend RefSpec to avoid status type conflict. Instead, provides same create type through delegation.


</td></tr>
<tr><td>

[RouteSvc](./routesvc/)


</td><td>

Route - navigation and path signals


</td></tr>
<tr><td>

[RouteTree](./routetree/)


</td><td>

The complete route tree returned by defineRoutes().create()


</td></tr>
<tr><td>

[ViewSvc](./viewsvc/)


</td><td>

View service that the router depends on


</td></tr>
</tbody></table>

