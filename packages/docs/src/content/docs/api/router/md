---
title: "router package"
sidebar:
  label: "router"
  badge:
    text: "pkg"
    variant: "success"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../../) &gt; [@lattice/router](../)

## router package

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[composePath(parentPath, childPath)](../composepath/)


</td><td>

Compose a parent path with a child path


</td></tr>
<tr><td>

[connect(wrapper)](../connect/)


</td><td>

Standalone connect function - doesn't require a router instance

Creates a connected component that receives the service and route context as separate arguments. This keeps the service "owned" by the user while making route-specific data explicit.


</td></tr>
<tr><td>

[createLegacyRouter(viewSvc, config)](../createlegacyrouter/)


</td><td>

Create a router instance

The router is a separate app-level service that takes a view service as input. It manages navigation state and provides routing primitives.


</td></tr>
<tr><td>

[createLocationFactory(opts)](../createlocationfactory/)


</td><td>

Create a location factory that provides reactive access to URL state


</td></tr>
<tr><td>

[createRouter(deps, routes, options)](../createrouter/)


</td><td>

Create a router instance


</td></tr>
<tr><td>

[defineRoutes(rootPath, rootComponent)](../defineroutes/)


</td><td>

Define routes without requiring a router instance


</td></tr>
<tr><td>

[Link(props)](../link/)


</td><td>

Link builder function

Link is inherently DOM-coupled (uses window.history, MouseEvent, href, onclick). Routers are web browser concepts - no need for adapter abstraction here.


</td></tr>
<tr><td>

[matchPath(pattern, path)](../matchpath/)


</td><td>

Matches a URL path against a route pattern (exact match)

Supports exact string matching, path parameters using :paramName syntax, and wildcard '\*' for catch-all


</td></tr>
<tr><td>

[matchPathPrefix(pattern, path)](../matchpathprefix/)


</td><td>

Matches a URL path against a route pattern (prefix match for parent routes)

Used for routes with children - matches if the path starts with the pattern


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ConnectedComponent\_2](../connectedcomponent/)


</td><td>

Connected component type - a function that receives route context


</td></tr>
<tr><td>

[ConnectedComponent](../connectedcomponent/)


</td><td>

A connected component that can be instantiated with route context


</td></tr>
<tr><td>

[ConnectedSvc](../connectedsvc/)


</td><td>

Connected service - merged view service + route service

This is the service passed to connected components, enabling them to use whatever adapter is provided (hydrating or regular) rather than pulling from a singleton.


</td></tr>
<tr><td>

[ConnectMethod](../connectmethod/)


</td><td>

The connect impl signature

Connected components receive the service and route context as separate arguments. This keeps the service "owned" by the user while making route-specific data explicit.


</td></tr>
<tr><td>

[DefineRoutesContext](../defineroutescontext/)


</td><td>


</td></tr>
<tr><td>

[LegacyRouter](../legacyrouter/)


</td><td>

Router object returned by createRouter Generic over TConfig for type safety with adapter-specific implementations


</td></tr>
<tr><td>

[LinkFunction](../linkfunction/)


</td><td>

Link function type

Link is DOM-only - no need for generic adapter abstraction


</td></tr>
<tr><td>

[LinkOpts](../linkopts/)


</td><td>

Options passed to Link factory

Link is DOM-only - routing with window.history is a web browser concept


</td></tr>
<tr><td>

[LocationFactory](../locationfactory/)


</td><td>

Location factory type


</td></tr>
<tr><td>

[LocationOpts](../locationopts/)


</td><td>

Options passed to location factory


</td></tr>
<tr><td>

[LocationSvc](../locationsvc/)


</td><td>

Location - reactive access to URL components


</td></tr>
<tr><td>

[MatchedRoute](../matchedroute/)


</td><td>

A matched route with its extracted parameters


</td></tr>
<tr><td>

[MatchFunction](../matchfunction/)


</td><td>

Match function type


</td></tr>
<tr><td>

[RootContext](../rootcontext/)


</td><td>

Root context returned by router.root() Provides scoped route creation and a create method for finalizing the route tree


</td></tr>
<tr><td>

[RootMethod](../rootmethod/)


</td><td>

Root method signature - defines the always-rendered root layout


</td></tr>
<tr><td>

[Route](../route/)


</td><td>

Route wraps a RefSpec with routing metadata for path composition. Delegates to internal RefSpec via closure.


</td></tr>
<tr><td>

[RouteBuilder](../routebuilder/)


</td><td>

A route builder - returned by route() before children are applied


</td></tr>
<tr><td>

[RouteConfig](../routeconfig/)


</td><td>

Route configuration - pure data, no components


</td></tr>
<tr><td>

[RouteContext](../routecontext/)


</td><td>

Route context - route-specific data (children, params)

Passed as the second argument to connected components. Kept separate from the service to maintain explicit ownership.


</td></tr>
<tr><td>

[RouteMatch](../routematch/)


</td><td>

Matched route information


</td></tr>
<tr><td>

[RouteMetadata](../routemetadata/)


</td><td>

Route-specific metadata


</td></tr>
<tr><td>

[RouteMethod](../routemethod/)


</td><td>

Route method signature


</td></tr>
<tr><td>

[RouteNode](../routenode/)


</td><td>

A single route node in the tree


</td></tr>
<tr><td>

[RouteParams](../routeparams/)


</td><td>

Route parameter map extracted from path patterns e.g., '/products/:id' -<!-- -->&gt; { id: string }


</td></tr>
<tr><td>

[Router](../router/)


</td><td>

Router instance - reactive state + navigation


</td></tr>
<tr><td>

[RouterConfig](../routerconfig/)


</td><td>

Router configuration


</td></tr>
<tr><td>

[RouterDeps](../routerdeps/)


</td><td>

Dependencies for creating the router These come from the signals module


</td></tr>
<tr><td>

[RouterOptions](../routeroptions/)


</td><td>

Router configuration


</td></tr>
<tr><td>

[RouteSvc](../routesvc/)


</td><td>

Route - navigation and path signals


</td></tr>
<tr><td>

[RouteTree](../routetree/)


</td><td>

The complete route tree returned by defineRoutes().create()


</td></tr>
<tr><td>

[ViewSvc](../viewsvc/)


</td><td>

View service that the router depends on


</td></tr>
</tbody></table>

