---
title: "router package"
sidebar:
  label: "router"
  badge:
    text: "pkg"
    variant: "success"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../../) &gt; [@lattice/router](../)

## router package

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[composePath(parentPath, childPath)](../composepath/)


</td><td>

Compose a parent path with a child path


</td></tr>
<tr><td>

[createLocationFactory(opts)](../createlocationfactory/)


</td><td>

Create a location factory that provides reactive access to URL state


</td></tr>
<tr><td>

[createRouter(deps, routes, options)](../createrouter/)


</td><td>

Create a router instance


</td></tr>
<tr><td>

[createRouterModule(routes, options)](../createroutermodule/)


</td><td>

Create a Router module for use with compose().

Like createElModule(adapter), this takes configuration at module creation time and returns a Module that can be composed with other modules.


</td></tr>
<tr><td>

[Link(props)](../link/)


</td><td>

Link builder function

Link is inherently DOM-coupled (uses window.history, MouseEvent, href, onclick). Routers are web browser concepts - no need for adapter abstraction here.


</td></tr>
<tr><td>

[matchPath(pattern, path)](../matchpath/)


</td><td>

Matches a URL path against a route pattern (exact match)

Supports exact string matching, path parameters using :paramName syntax, and wildcard '\*' for catch-all


</td></tr>
<tr><td>

[matchPathPrefix(pattern, path)](../matchpathprefix/)


</td><td>

Matches a URL path against a route pattern (prefix match for parent routes)

Used for routes with children - matches if the path starts with the pattern


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[LinkFunction](../linkfunction/)


</td><td>

Link function type

Link is DOM-only - no need for generic adapter abstraction


</td></tr>
<tr><td>

[LinkOpts](../linkopts/)


</td><td>

Options passed to Link factory

Link is DOM-only - routing with window.history is a web browser concept


</td></tr>
<tr><td>

[LocationFactory](../locationfactory/)


</td><td>

Location factory type


</td></tr>
<tr><td>

[LocationOpts](../locationopts/)


</td><td>

Options passed to location factory


</td></tr>
<tr><td>

[LocationSvc](../locationsvc/)


</td><td>

Location - reactive access to URL components


</td></tr>
<tr><td>

[MatchedRoute](../matchedroute/)


</td><td>

A matched route with its extracted parameters


</td></tr>
<tr><td>

[MatchFunction](../matchfunction/)


</td><td>

Match function type


</td></tr>
<tr><td>

[Route](../route/)


</td><td>

Route wraps a RefSpec with routing metadata for path composition. Delegates to internal RefSpec via closure.


</td></tr>
<tr><td>

[RouteConfig](../routeconfig/)


</td><td>

Route configuration - pure data, no components


</td></tr>
<tr><td>

[RouteMatch](../routematch/)


</td><td>

Matched route information


</td></tr>
<tr><td>

[RouteMetadata](../routemetadata/)


</td><td>

Route-specific metadata


</td></tr>
<tr><td>

[RouteParams](../routeparams/)


</td><td>

Route parameter map extracted from path patterns e.g., '/products/:id' -<!-- -->&gt; { id: string }


</td></tr>
<tr><td>

[Router](../router/)


</td><td>

Router instance - reactive state + navigation


</td></tr>
<tr><td>

[RouterDeps](../routerdeps/)


</td><td>

Dependencies for creating the router These come from the signals module


</td></tr>
<tr><td>

[RouterOptions](../routeroptions/)


</td><td>

Router configuration


</td></tr>
</tbody></table>

