---
title: "MatchFactory type"
sidebar:
  label: "MatchFactory"
  badge:
    text: "type"
    variant: "note"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../) &gt; [@lattice/view](./) &gt; MatchFactory

## MatchFactory type

Match factory type - reactive element switching based on a reactive value

Takes a signal, computed, or () =<!-- -->&gt; T and a matcher function. When the reactive value changes, the current element is disposed and replaced with a new one from the matcher.

The matcher function is NOT a reactive scope - it's a pure function that receives the current value and returns a RefSpec.

Uses function overloads with Writable<T> first to ensure proper type inference when passing signals directly (without arrow function wrapper).

**Signature:**

```typescript
export type MatchFactory<TBaseElement> = ServiceDefinition<'match', {
    <T, TElement extends TBaseElement>(reactive: Writable<T>, matcher: (value: T) => RefSpec<TElement> | null): RefSpec<TElement>;
    <T, TElement extends TBaseElement>(reactive: () => T, matcher: (value: T) => RefSpec<TElement> | null): RefSpec<TElement>;
}>;
```
**References:** [ServiceDefinition](../lattice/servicedefinition/)<!-- -->, [Writable](../signals/writable/)<!-- -->, [RefSpec](./refspec/)

## Example


```ts
// Signal passed directly - type infers correctly
match(dialog.isOpen, (isOpen) =>
  isOpen ? OpenDialog() : null
)

// Computed or arrow function also works
match(currentTab, (tab) =>
  tab === 'home' ? HomePage() : SettingsPage()
)
```

