---
title: "createLoader() function"
sidebar:
  label: "createLoader()"
  badge:
    text: "fn"
    variant: "tip"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../../) &gt; [@lattice/view](../) &gt; createLoader

## createLoader() function

Create a loader for managing async data boundaries.

On the server: - Create loader without initial data - Use load() with IDs to create async boundaries - After render, call getData() to get all resolved data - Serialize data to a script tag in your HTML

On the client: - Create loader with initial data from the script tag - Same load() calls will use cached data instead of fetching

**Signature:**

```typescript
export declare function createLoader(opts: {
    signal: SignalFactory;
    initialData?: Record<string, unknown>;
    onResolve?: (id: string, data: unknown) => void;
}): Loader;
```

## Parameters

<table><thead><tr><th>

Parameter


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

opts


</td><td>

{ signal: [SignalFactory](../../signals/signalfactory/)<!-- -->; initialData?: Record&lt;string, unknown&gt;; onResolve?: (id: string, data: unknown) =&gt; void; }


</td><td>


</td></tr>
</tbody></table>

**Returns:**

[Loader](../loader/)

## Example 1

Basic usage

```ts
// Server
const loader = createLoader({ signal });
const { load } = loader;

const App = () => load('stats', () => fetchStats(), (state) =>
  match(state.status, (s) => s === 'ready' ? Stats(state.data()!) : Loading())
);

// After render
const data = loader.getData();
// Add to HTML: <script>window.__DATA__ = ${JSON.stringify(data)}</script>

// Client
const loader = createLoader({ signal, initialData: window.__DATA__ });
const { load } = loader;
// Same App component - uses cached data, no re-fetch
```

## Example 2

SSR streaming

```ts
const loader = createLoader({
  signal,
  onResolve: (id, data) => {
    // Stream chunk to client as each boundary resolves
    const html = renderFragment(id);
    stream.write(`<script>__LATTICE_HYDRATE__("${id}", ${JSON.stringify(html)})</script>`);
  }
});
```

