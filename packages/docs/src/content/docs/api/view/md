---
title: 'view package'
sidebar:
  label: 'view'
  badge:
    text: 'pkg'
    variant: 'success'
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../../) &gt; [@lattice/view](../)

## view package

## Functions

<table><thead><tr><th>

Function

</th><th>

Description

</th></tr></thead>
<tbody><tr><td>

[createDOMView()](../createdomsvc/)

</td><td>

Create a fully-configured DOM app service

Returns a flat service with all signals and view primitives, plus DOM-specific helpers (on, t) and a mount function.

</td></tr>
<tr><td>

[createDOMView({ signal, computed, effect, batch, })](../createdomviewsvc/)

</td><td>

Create DOM view service (view primitives only, no signals)

Use this when you need to share signals between multiple adapters (e.g., DOM + Canvas in the same app).

</td></tr>
<tr><td>

[createView(adapter, { effect, signal, computed, batch })](../createviewsvc/)

</td><td>

Create a view service for a given adapter and signal implementation

Combines the default view primitives (el, map, match, portal) with an adapter and signal system to create a complete view service.

</td></tr>
<tr><td>

[defaultExtensions()](../defaultextensions/)

</td><td>

Create the default set of view extensions

Returns an object with el, map, match, and portal services that can be composed.

</td></tr>
<tr><td>

[El(props)](../el/)

</td><td>

El primitive - instantiatable extension using the create pattern Similar to Signal() in signals preset

Generic over: - TConfig: The renderer configuration (inferred from renderer) - TElement: Base element type - TText: Text node type

</td></tr>
<tr><td>

[Map_2(props)](../map_2/)

</td><td>

Map primitive - instantiatable extension using the create pattern Similar to Signal() in signals preset

</td></tr>
<tr><td>

[Match(props)](../match/)

</td><td>

Match primitive - switches between different elements based on reactive value

Takes a Reactive<T> (signal, computed, or any () =<!-- -->&gt; T) and rebuilds children when the value changes. Use for polymorphic rendering where the value determines WHAT to render.

For simple show/hide based on truthiness, use when() instead - it's more efficient as it doesn't rebuild the parent.

Usage:

```typescript
const currentTab = signal<'home' | 'settings'>('home');

// Switch between different views based on tab
match(currentTab, (tab) => (tab === 'home' ? HomePage() : SettingsPage()));

// With computed
const viewMode = computed(() => (user().isAdmin ? 'admin' : 'user'));
match(viewMode, (mode) => (mode === 'admin' ? AdminPanel() : UserPanel()));
```

The matcher function is called with the current reactive value and must return a RefSpec. It is NOT a reactive tracking scope - it's a pure mapping function.

</td></tr>
<tr><td>

[Portal(props)](../portal/)

</td><td>

Portal primitive - renders content into a different DOM location

Creates a fragment in the logical tree that attaches its children to a different DOM location (target element). This enables modals, tooltips, and other overlay patterns while preserving: - Reactive scope inheritance - Automatic cleanup when logical parent disposes

</td></tr>
</tbody></table>

## Variables

<table><thead><tr><th>

Variable

</th><th>

Description

</th></tr></thead>
<tbody><tr><td>

[STATUS_COMMENT](../status_comment/)

</td><td>

</td></tr>
<tr><td>

[STATUS_ELEMENT](../status_element/)

</td><td>

Status bits for node ref type discrimination Using powers of 2 for bitwise operations

</td></tr>
<tr><td>

[STATUS_FRAGMENT](../status_fragment/)

</td><td>

</td></tr>
<tr><td>

[STATUS_NODE_MASK](../status_node_mask/)

</td><td>

Composite bit masks for checking types

</td></tr>
<tr><td>

[STATUS_REF_SPEC](../status_ref_spec/)

</td><td>

</td></tr>
<tr><td>

[STATUS_SPEC_MASK](../status_spec_mask/)

</td><td>

</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias

</th><th>

Description

</th></tr></thead>
<tbody><tr><td>

[Adapter](../adapter/)

</td><td>

Adapter type - core tree operations

Generic over: - TConfig: The adapter configuration (elements, events, baseElement)

\#\# Lifecycle Hooks

The adapter supports six symmetric lifecycle hooks across three phases:

\| Phase \| Before \| After (on) \| \|\-\-\-\-\-\-\-\-\-\|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--\|\-\-\-\-\-\-\-\-\-\-\-\-\| \| Create \| beforeCreate \| onCreate \| \| Attach \| beforeAttach \| onAttach \| \| Destroy \| beforeDestroy \| onDestroy \|

Node type (element vs fragment) is determined by `ref.status`<!-- -->: - STATUS_ELEMENT (1): Element node with actual DOM element - STATUS_FRAGMENT (2): Fragment node (logical container, no DOM element)

\#\#\# Hydration

For hydration-specific position tracking, use the HydrationAdapter extension which adds `seekToPosition` and `skipContent` methods.

</td></tr>
<tr><td>

[AdapterConfig](../adapterconfig/)

</td><td>

AdapterConfig defines the type-level contract for a tree adapter: - props: Maps tag names to their prop types for el() autocomplete - elements: Maps tag names to their node types for RefSpec<!-- -->&lt;<!-- -->T<!-- -->&gt; (e.g., 'div' -<!-- -->&gt; HTMLDivElement) - events: Maps event names to their event object types (e.g., 'click' -<!-- -->&gt; MouseEvent) - baseElement: Base node type for this adapter (e.g., Node for DOM)

Separating `props` from `elements` allows adapters to have clean prop autocomplete without exposing internal node properties (like canvas's bounds, dirty, etc).

Note: Text is just another node type created via createNode('text', { value: '...' }<!-- -->)

</td></tr>
<tr><td>

[AddEventListener](../addeventlistener/)

</td><td>

Type of the addEventListener helper returned by createAddEventListener

</td></tr>
<tr><td>

[BaseRef](../baseref/)

</td><td>

</td></tr>
<tr><td>

[ComponentFactory](../componentfactory/)

</td><td>

Component factory type - dynamically typed based on actual service Supports both RefSpec (elements) and NodeRef (fragments) returns Preserves element type inference through TElement generic

</td></tr>
<tr><td>

[CreateScopes](../createscopes/)

</td><td>

Public scope API for managing element lifecycles and cleanup.

</td></tr>
<tr><td>

[DefaultExtensions](../defaultextensions/)

</td><td>

The set of instantiable services created by defaultExtensions().

Each property is a service that can be composed with compose(). Use this type when extending the default view primitives.

</td></tr>
<tr><td>

[DisposableNode](../disposablenode/)

</td><td>

Linked list node for tracking dispose functions Used by RenderScope to track cleanup functions

</td></tr>
<tr><td>

[DOMAdapterConfig](../domadapterconfig/)

</td><td>

DOM adapter configuration type

Provides type-safe props and elements for standard HTML tags plus text nodes.

</td></tr>
<tr><td>

[DOMSvc](../domsvc/)

</td><td>

Full DOM service type - signals + view + use

</td></tr>
<tr><td>

[DOMViewSvc](../domviewsvc/)

</td><td>

DOM View service type - view primitives + on + mount

</td></tr>
<tr><td>

[ElementProps](../elementprops/)

</td><td>

Props for an element - type-safe based on the renderer's props configuration Each prop can be either a static value or a Reactive value

The type provides autocomplete for known element properties while allowing arbitrary attributes (data-\*, aria-\*, custom attributes) via index signature. This matches real DOM behavior where any attribute can be set on any element.

Generic over: - TConfig: The renderer configuration - Tag: The element tag name (must be a key in TConfig\['props'\])

</td></tr>
<tr><td>

[ElementRef](../elementref/)

</td><td>

Element ref node - wraps created elements for tree structure Forms doubly-linked list with prev/next pointers for efficient sibling traversal Links to parent for tree traversal Tracks child NodeRefs for tree walking (needed for SSR fragment detection)

</td></tr>
<tr><td>

[ElFactory](../elfactory/)

</td><td>

ServiceDefinition for the el primitive. This is what gets composed into a service context.

</td></tr>
<tr><td>

[ElOpts](../elopts/)

</td><td>

Options passed to el factory

Generic over: - TConfig: The renderer configuration - TElement: Base element type - TText: Text node type

</td></tr>
<tr><td>

[ElProps](../elprops/)

</td><td>

</td></tr>
<tr><td>

[ElRefSpecChild](../elrefspecchild/)

</td><td>

Valid child types for an element

Note: Bare functions are not supported. For dynamic content, use map() or other reconciliation helpers that provide efficient updates.

The TElement parameter is kept for API consistency, but child RefSpecs/FragmentRefs use `unknown` since any element can be a child of any other element at runtime. Using `unknown` (the top type) allows proper variance - any RefSpec<T> is assignable to RefSpec<unknown>.

</td></tr>
<tr><td>

[ElService](../elservice/)

</td><td>

The instantiable service returned by El().

Use this type when building custom view service compositions:

</td></tr>
<tr><td>

[FragmentRef](../fragmentref/)

</td><td>

Fragment ref node - logical container in the tree (no DOM element) Fragments participate in parent's doubly-linked list and own their own child list

</td></tr>
<tr><td>

[LifecycleCallback](../lifecyclecallback/)

</td><td>

Lifecycle callback for element connection/disconnection

</td></tr>
<tr><td>

[LinkedNode](../linkednode/)

</td><td>

Linked nodes - nodes that form doubly-linked lists Elements are actual DOM nodes in the list Fragments are logical nodes that own their own child lists

</td></tr>
<tr><td>

[MapFactory](../mapfactory/)

</td><td>

Map factory type

Items can be a static array or a reactive signal of array. The render callback receives a signal wrapping each item, enabling reactive updates without recreating elements.

When the source array updates, map pushes new values into the item signals, triggering reactive updates in computeds that read them.

Note: Uses function overloads with Writable first to ensure proper type inference when passing signals directly.

</td></tr>
<tr><td>

[MapOpts](../mapopts/)

</td><td>

</td></tr>
<tr><td>

[MapProps](../mapprops/)

</td><td>

</td></tr>
<tr><td>

[MapService](../mapservice/)

</td><td>

The instantiable service returned by Map().

Use this type when building custom view service compositions:

</td></tr>
<tr><td>

[MatchFactory](../matchfactory/)

</td><td>

Match factory type - reactive element switching based on a reactive value

Takes a signal, computed, or () =<!-- -->&gt; T and a matcher function. When the reactive value changes, the current element is disposed and replaced with a new one from the matcher.

The matcher function is NOT a reactive scope - it's a pure function that receives the current value and returns a RefSpec.

Uses function overloads with Writable<T> first to ensure proper type inference when passing signals directly (without arrow function wrapper).

</td></tr>
<tr><td>

[MatchOpts](../matchopts/)

</td><td>

Options passed to Match factory

</td></tr>
<tr><td>

[MatchProps](../matchprops/)

</td><td>

</td></tr>
<tr><td>

[MatchService](../matchservice/)

</td><td>

The instantiable service returned by Match().

Use this type when building custom view service compositions:

</td></tr>
<tr><td>

[NodeRef](../noderef/)

</td><td>

Ref node - union of element/fragment tracking nodes

</td></tr>
<tr><td>

[ParentContext](../parentcontext/)

</td><td>

Parent context passed to RefSpec.create() for adapter composition Allows child RefSpecs to know their parent's adapter and element

Note: adapter uses 'unknown' for variance - any Adapter<T> is assignable

</td></tr>
<tr><td>

[PortalFactory](../portalfactory/)

</td><td>

Portal factory type - renders children into a target element

Takes an optional target (element, getter, or signal) and a child RefSpec. The child is rendered into the target element.

Generic over: - TBaseElement: The base element type from renderer config

</td></tr>
<tr><td>

[PortalOpts](../portalopts/)

</td><td>

Options passed to Portal factory

</td></tr>
<tr><td>

[PortalProps](../portalprops/)

</td><td>

</td></tr>
<tr><td>

[PortalService](../portalservice/)

</td><td>

The instantiable service returned by Portal().

Use this type when building custom view service compositions:

</td></tr>
<tr><td>

[PortalTarget](../portaltarget/)

</td><td>

Portal target - where content should be rendered - undefined: use default (document.body) - Element: use directly - () =<!-- -->&gt; Element \| null: getter/signal (called to resolve target)

</td></tr>
<tr><td>

[ReactiveProps](../reactiveprops/)

</td><td>

Makes each property in T accept either the value or a Reactive<value>

</td></tr>
<tr><td>

[RefSpec](../refspec/)

</td><td>

Ref spec - a specification/blueprint for a ref that can be instantiated multiple times Extends Service to provide uniform context injection pattern

</td></tr>
<tr><td>

[RenderScope](../renderscope/)

</td><td>

</td></tr>
<tr><td>

[TagFactory](../tagfactory/)

</td><td>

Tag factory - returned from el(tag) Callable with children to create RefSpec, or use .props()/.ref() to configure

Generic over: - TConfig: The renderer configuration - Tag: The element tag name (must exist in both props and elements)

</td></tr>
<tr><td>

[Use](../use/)

</td><td>

Type of the use helper returned by createUse

</td></tr>
<tr><td>

[ViewSvc_2](../viewsvc/)

</td><td>

View service type - composed from defaultExtensions

</td></tr>
<tr><td>

[ViewSvc](../viewsvc/)

</td><td>

View service type for a given adapter config

</td></tr>
</tbody></table>
