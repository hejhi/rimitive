---
title: "view package"
sidebar:
  label: "view"
  badge:
    text: "pkg"
    variant: "success"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../../) &gt; [@rimitive/view](../)

## view package

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[createLoader(opts)](../createloader/)


</td><td>

Create a loader for managing async data boundaries.

On the server: - Create loader without initial data - Use load() with IDs to create async boundaries - After render, call getData() to get all resolved data - Serialize data to a script tag in your HTML

On the client: - Create loader with initial data from the script tag - Same load() calls will use cached data instead of fetching


</td></tr>
<tr><td>

[createLoadFactory({ signal })](../createloadfactory/)


</td><td>

Create a load factory with the given dependencies.


</td></tr>
<tr><td>

[createShadowFactory({ scopedEffect, onCleanup, adapter, })](../createshadowfactory/)


</td><td>

Create a shadow factory with the given dependencies.


</td></tr>
<tr><td>

[createShadowModule(adapter)](../createshadowmodule/)


</td><td>

Create a Shadow module for a given adapter.


</td></tr>
<tr><td>

[getAsyncMeta(node)](../getasyncmeta/)


</td><td>

Get async metadata from a node


</td></tr>
<tr><td>

[isAsyncFragment(value)](../isasyncfragment/)


</td><td>

Check if a value is an async fragment


</td></tr>
<tr><td>

[mount(modules)](../mount/)


</td><td>

Mount modules and render a component with automatic effect scoping.

Takes modules (same as compose()), and wraps the effect function so that effects created within the component tree are automatically disposed when the returned unmount function is called.


</td></tr>
</tbody></table>

## Variables

<table><thead><tr><th>

Variable


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ASYNC\_FRAGMENT](../async_fragment/)


</td><td>

Symbol marking async fragments created by load()


</td></tr>
<tr><td>

[LoadModule](../loadmodule/)


</td><td>

Load module - provides the load() factory for async data boundaries.


</td></tr>
<tr><td>

[STATUS\_COMMENT](../status_comment/)


</td><td>


</td></tr>
<tr><td>

[STATUS\_ELEMENT](../status_element/)


</td><td>

Status bits for node ref type discrimination Using powers of 2 for bitwise operations


</td></tr>
<tr><td>

[STATUS\_FRAGMENT](../status_fragment/)


</td><td>


</td></tr>
<tr><td>

[STATUS\_NODE\_MASK](../status_node_mask/)


</td><td>

Composite bit masks for checking types


</td></tr>
<tr><td>

[STATUS\_REF\_SPEC](../status_ref_spec/)


</td><td>


</td></tr>
<tr><td>

[STATUS\_SPEC\_MASK](../status_spec_mask/)


</td><td>


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[Adapter](../adapter/)


</td><td>

Adapter type - core tree operations

Generic over: - TConfig: The tree configuration (nodes, attributes, node)

\#\# Lifecycle Hooks

The adapter supports six symmetric lifecycle hooks across three phases:

\| Phase \| Before \| After (on) \| \|\-\-\-\-\-\-\-\-\-\|\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--\|\-\-\-\-\-\-\-\-\-\-\-\-\| \| Create \| beforeCreate \| onCreate \| \| Attach \| beforeAttach \| onAttach \| \| Destroy \| beforeDestroy \| onDestroy \|

Node type (element vs fragment) is determined by `ref.status`<!-- -->: - STATUS\_ELEMENT (1): Element node with actual tree node - STATUS\_FRAGMENT (2): Fragment node (logical container, no tree node)

\#\#\# Hydration

For hydration-specific position tracking, use the HydrationAdapter extension which adds `seekToPosition` and `skipContent` methods.


</td></tr>
<tr><td>

[AsyncFragment](../asyncfragment/)


</td><td>

Node with async metadata


</td></tr>
<tr><td>

[AsyncMeta](../asyncmeta/)


</td><td>

Async fragment metadata for SSR introspection


</td></tr>
<tr><td>

[BaseRef](../baseref/)


</td><td>


</td></tr>
<tr><td>

[CreateScopes](../createscopes/)


</td><td>

Public scope API for managing element lifecycles and cleanup.


</td></tr>
<tr><td>

[DisposableNode](../disposablenode/)


</td><td>

Linked list node for tracking dispose functions Used by RenderScope to track cleanup functions


</td></tr>
<tr><td>

[ElementRef](../elementref/)


</td><td>

Element ref node - wraps created elements for tree structure Forms doubly-linked list with prev/next pointers for efficient sibling traversal Links to parent for tree traversal Tracks child NodeRefs for tree walking (needed for SSR fragment detection)


</td></tr>
<tr><td>

[ElRefSpecChild](../elrefspecchild/)


</td><td>

Valid child types for an element

Note: Bare functions are not supported. For dynamic content, use map() or other reconciliation helpers that provide efficient updates.

The TElement parameter is kept for API consistency, but child RefSpecs/FragmentRefs use `unknown` since any element can be a child of any other element at runtime. Using `unknown` (the top type) allows proper variance - any RefSpec<T> is assignable to RefSpec<unknown>.


</td></tr>
<tr><td>

[FragmentRef](../fragmentref/)


</td><td>

Fragment ref node - logical container in the tree (no DOM element) Fragments participate in parent's doubly-linked list and own their own child list


</td></tr>
<tr><td>

[LifecycleCallback](../lifecyclecallback/)


</td><td>

Lifecycle callback for element connection/disconnection


</td></tr>
<tr><td>

[LinkedNode](../linkednode/)


</td><td>

Linked nodes - nodes that form doubly-linked lists Elements are actual DOM nodes in the list Fragments are logical nodes that own their own child lists


</td></tr>
<tr><td>

[Loader](../loader/)


</td><td>

Loader instance returned by createLoader


</td></tr>
<tr><td>

[LoaderOpts](../loaderopts/)


</td><td>

Options for creating a loader module


</td></tr>
<tr><td>

[LoadFactory](../loadfactory/)


</td><td>

Load factory type - creates async boundaries with fetcher/renderer pattern

The renderer receives a state object with reactive properties: - status: Reactive<!-- -->&lt;<!-- -->'pending' \| 'ready' \| 'error'<!-- -->&gt; - data: Reactive<!-- -->&lt;<!-- -->T \| undefined<!-- -->&gt; - error: Reactive<!-- -->&lt;<!-- -->unknown \| undefined<!-- -->&gt;

User controls how to render based on state - typically using match() on state.status.


</td></tr>
<tr><td>

[LoadFn](../loadfn/)


</td><td>

Load function with explicit ID for data lookup


</td></tr>
<tr><td>

[LoadOpts](../loadopts/)


</td><td>

Options for createLoadFactory


</td></tr>
<tr><td>

[LoadState](../loadstate/)


</td><td>

Load state object with reactive properties


</td></tr>
<tr><td>

[LoadStatus](../loadstatus/)


</td><td>

Load status values


</td></tr>
<tr><td>

[MountFn](../mountfn/)


</td><td>

Mount function type - returned by mount(...modules)


</td></tr>
<tr><td>

[NodeOf](../nodeof/)


</td><td>

Union of all node types in the config. Used for adapter method parameters where any node type is accepted.


</td></tr>
<tr><td>

[NodeRef](../noderef/)


</td><td>

Ref node - union of element/fragment tracking nodes


</td></tr>
<tr><td>

[NodeType](../nodetype/)


</td><td>

Get a specific node type from the config's nodes map.


</td></tr>
<tr><td>

[ParentContext](../parentcontext/)


</td><td>

Parent context passed to RefSpec.create() for adapter composition Allows child RefSpecs to know their parent's adapter and element

Note: adapter uses 'unknown' for variance - any Adapter<T> is assignable


</td></tr>
<tr><td>

[PortableComponent](../portablecomponent/)


</td><td>

A portable component - a function that receives a service and returns a factory that produces a RefSpec when called.


</td></tr>
<tr><td>

[PortalOpts](../portalopts/)


</td><td>

Options passed to Portal factory


</td></tr>
<tr><td>

[PortalTarget](../portaltarget/)


</td><td>

Portal target - where content should be rendered - undefined: use default (document.body) - Element: use directly - () =<!-- -->&gt; Element \| null: getter/signal (called to resolve target)


</td></tr>
<tr><td>

[RefSpec](../refspec/)


</td><td>

Ref spec - a specification/blueprint for a ref that can be instantiated multiple times Extends Service to provide uniform context injection pattern


</td></tr>
<tr><td>

[RenderScope](../renderscope/)


</td><td>


</td></tr>
<tr><td>

[ServiceFromModules](../servicefrommodules/)


</td><td>

Extract the service type from a tuple of modules. Uses ContainsLazy to handle async module composition.


</td></tr>
<tr><td>

[ShadowFactory](../shadowfactory/)


</td><td>

Shadow factory - returned from shadow(options) Callable with children to create RefSpec, or use .ref() to access shadow root


</td></tr>
<tr><td>

[ShadowLifecycleCallback](../shadowlifecyclecallback/)


</td><td>

Lifecycle callback for shadow - receives the shadow root


</td></tr>
<tr><td>

[ShadowMode](../shadowmode/)


</td><td>

Shadow DOM mode


</td></tr>
<tr><td>

[ShadowOptions](../shadowoptions/)


</td><td>

Options for creating a shadow root


</td></tr>
<tr><td>

[ShadowOpts](../shadowopts/)


</td><td>

Options passed to shadow factory creator


</td></tr>
<tr><td>

[ShadowService](../shadowservice/)


</td><td>

Shadow service type - creates shadow factories


</td></tr>
<tr><td>

[TreeConfig](../treeconfig/)


</td><td>

TreeConfig defines the type-level contract for a tree adapter: - attributes: Maps tag names to their attribute types for el() autocomplete - nodes: Maps tag names to their node types for RefSpec<!-- -->&lt;<!-- -->T<!-- -->&gt; (e.g., 'div' -<!-- -->&gt; HTMLDivElement)

The base node type is derived automatically as the union of all node types in `nodes`<!-- -->. Use `NodeOf<TConfig>` to access it.

Separating `attributes` from `nodes` allows adapters to have clean attribute autocomplete without exposing internal node properties (like canvas's bounds, dirty, etc).

Note: Text is just another node type created via createNode('text', { value: '...' }<!-- -->)


</td></tr>
</tbody></table>

