---
title: "islands package"
sidebar:
  label: "islands"
  badge:
    text: "pkg"
    variant: "success"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../) &gt; [@lattice/islands](./)

## islands package

## Classes

<table><thead><tr><th>

Class


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[HydrationMismatch](./hydrationmismatch/)


</td><td>

Hydration mismatch error


</td></tr>
</tbody></table>

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[createIsland()](./createisland/)


</td><td>

Create a typed island factory

Returns an `island` function with Service and Context types baked in. Props are inferred from the factory function's parameter annotation.


</td></tr>
<tr><td>

[createIslandsApp(options)](./createislandsapp/)


</td><td>

Create an islands app for client-side hydration

Accepts signals, adapter, and view as dependencies - does not create them internally. This allows maximum composability and custom extensions.

For server-side rendering, import from '<!-- -->@<!-- -->lattice/islands/server':

```ts
import { createIslandsApp } from '@lattice/islands/server';
```


</td></tr>
<tr><td>

[island(id, factory)](./island/)


</td><td>

Mark a component as an island

Islands are interactive components that ship JavaScript to the client. During SSR, islands register themselves for hydration. On the client, islands hydrate from server-rendered HTML.

Island components receive two arguments: 1. svc - The user-defined service svc (el, signal, computed, etc.) 2. getContext - Getter function that returns user-defined context (or undefined)


</td></tr>
<tr><td>

[island(id, strategy, factory)](./island_1/)


</td><td>

Mark a component as an island with custom hydration strategy


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ClientApp](./clientapp/)


</td><td>

Client app - for hydration and SPA


</td></tr>
<tr><td>

[ClientOptions](./clientoptions/)


</td><td>

Client app options - accepts primitives as dependencies


</td></tr>
<tr><td>

[GetContext](./getcontext/)


</td><td>

Context getter type - passed to island factories as second argument

Islands receive a getter function that returns user-defined context. On server: static, from SSR setup On client: reactive, called on init and navigation (popstate)

If no context is configured, the getter returns undefined.


</td></tr>
<tr><td>

[HybridAdapter](./hybridadapter/)


</td><td>

Hybrid adapter type (from createIslandsAdapter)


</td></tr>
<tr><td>

[IslandComponent\_2](./islandcomponent_2/)


</td><td>

Island component type for hydrate() Uses unknown for metadata to allow heterogeneous island collections


</td></tr>
<tr><td>

[IslandComponent](./islandcomponent/)


</td><td>

Island component - function that receives props and returns a spec

Islands are created with: island('counter', Component) Components must accept JSON-serializable props only

Note: This is a callable type. The actual functions will satisfy this. The metadata symbol is added by the island() wrapper function.

IMPORTANT: ISLAND\_META and IslandMetaData must be exported from the same entry points as IslandComponent to satisfy TypeScript's portable types requirement (TS2742). See CLAUDE.md "Portable Types Rule" for details.


</td></tr>
<tr><td>

[IslandFactory](./islandfactory/)


</td><td>

Island factory function - returned by createIsland

This is the function you use to define islands. Props are inferred from the inline type annotation on the factory's inner function.


</td></tr>
<tr><td>

[IslandsApp](./islandsapp/)


</td><td>

Islands app shape - matches both ClientApp and ServerApp


</td></tr>
<tr><td>

[IslandsClientService](./islandsclientservice/)


</td><td>

Full service type - signals + views + addEventListener


</td></tr>
<tr><td>

[IslandStrategy](./islandstrategy/)


</td><td>

Island hydration strategy

Customizes behavior when hydration fails (e.g., preserve form inputs, track analytics)


</td></tr>
<tr><td>

[IslandSvc](./islandsvc/)


</td><td>

Island Svc type - the service type available to island components Use this with createIsland<IslandSvc>() for typed islands


</td></tr>
<tr><td>

[ServiceOf](./serviceof/)


</td><td>

Extract the service type from an islands app

Works with both ClientApp and ServerApp from createIslandsApp


</td></tr>
<tr><td>

[SignalsSvc\_2](./signalssvc_2/)


</td><td>

Signals service type


</td></tr>
<tr><td>

[ViewsSvc](./viewssvc/)


</td><td>

View service type


</td></tr>
<tr><td>

[ViewSvc](./viewsvc/)


</td><td>


</td></tr>
</tbody></table>

