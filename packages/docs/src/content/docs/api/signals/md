---
title: "signals package"
sidebar:
  label: "signals"
  badge:
    text: "pkg"
    variant: "success"
---

<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](../) &gt; [@lattice/signals](./)

## signals package

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[Batch(args\_0)](./batch/)


</td><td>

Create a Batch service factory.

Batch groups multiple signal writes into a single update cycle, preventing intermediate effect executions.

\*\*Most users should use the preset instead:\*\*

```ts
import { createSignalsSvc } from '@lattice/signals/presets/core';
const { batch } = createSignalsSvc();
```


</td></tr>
<tr><td>

[Computed(args\_0)](./computed/)


</td><td>

Create a Computed service factory.

Computeds are derived values that automatically track their dependencies and recompute lazily when those dependencies change.

\*\*Most users should use the preset instead:\*\*

```ts
import { createSignalsSvc } from '@lattice/signals/presets/core';
const { computed } = createSignalsSvc();
```


</td></tr>
<tr><td>

[createHelpers()](./createhelpers/)


</td><td>

Create the reactive graph infrastructure (helpers).

This wires together all the low-level machinery: dependency tracking, graph traversal, pull-based updates, and effect scheduling.

Most users should use `createSignalsSvc()` instead, which calls this internally.


</td></tr>
<tr><td>

[createSignalsSvc()](./createsignalssvc/)


</td><td>

Create a fully-configured signals service.

This is the main entry point for using Lattice signals. Returns a service with all primitives wired up and ready to use.


</td></tr>
<tr><td>

[defaultExtensions(extensions)](./defaultextensions/)


</td><td>

Create the default set of signal service factories.

Returns service factories for all core primitives: signal, computed, effect, batch, and subscribe. Pass to `compose()` with helpers to create a working signals service.


</td></tr>
<tr><td>

[Effect(args\_0)](./effect/)


</td><td>

Create an Effect service factory.

Effects are side effects that run when their dependencies change. They run immediately on creation and re-run whenever any dependency changes.

\*\*Most users should use the preset instead:\*\*

```ts
import { createSignalsSvc } from '@lattice/signals/presets/core';
const { effect } = createSignalsSvc();
```


</td></tr>
<tr><td>

[Signal(args\_0)](./signal/)


</td><td>

Create a Signal service factory.

Signals are reactive containers that notify subscribers when their value changes. They are the foundation of the reactivity system.

\*\*Most users should use the preset instead:\*\*

```ts
import { createSignalsSvc } from '@lattice/signals/presets/core';
const { signal } = createSignalsSvc();
```


</td></tr>
<tr><td>

[Subscribe(args\_0)](./subscribe/)


</td><td>

Create a Subscribe service factory.

Subscribe tracks dependencies only from the source function, not the callback. This is useful when you want to react to specific signals without tracking all dependencies used in the callback.

\*\*Most users should use the preset instead:\*\*

```ts
import { createSignalsSvc } from '@lattice/signals/presets/core';
const { subscribe } = createSignalsSvc();
```


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[BatchFactory](./batchfactory/)


</td><td>

ServiceDefinition for the batch primitive. This is what gets composed into a service context.


</td></tr>
<tr><td>

[BatchOptions](./batchoptions/)


</td><td>

Options for customizing Batch behavior.


</td></tr>
<tr><td>

[BatchService](./batchservice/)


</td><td>

The instantiable service returned by Batch().


</td></tr>
<tr><td>

[ComputedFactory](./computedfactory/)


</td><td>

ServiceDefinition for the computed primitive. This is what gets composed into a service context.


</td></tr>
<tr><td>

[ComputedFunction](./computedfunction/)


</td><td>

Computed function type - a callable that derives values from other reactives.

Computeds are lazy: they only recompute when read and their dependencies have changed. Use `.peek()` to read without tracking dependencies.


</td></tr>
<tr><td>

[ComputedOptions](./computedoptions/)


</td><td>

Options for customizing Computed behavior.


</td></tr>
<tr><td>

[ComputedService](./computedservice/)


</td><td>

The instantiable service returned by Computed().


</td></tr>
<tr><td>

[Consumer](./consumer/)


</td><td>

Consumer tracking state - tracks the currently active consumer during reactive reads


</td></tr>
<tr><td>

[DefaultExtensions](./defaultextensions/)


</td><td>

The set of instantiable services created by defaultExtensions().

Each property is a service that can be composed with compose(). Use this type when extending the default signal primitives:


</td></tr>
<tr><td>

[EffectFactory](./effectfactory/)


</td><td>

ServiceDefinition for the effect primitive. This is what gets composed into a service context.


</td></tr>
<tr><td>

[EffectOptions](./effectoptions/)


</td><td>

Options for customizing Effect behavior.


</td></tr>
<tr><td>

[EffectService](./effectservice/)


</td><td>

The instantiable service returned by Effect().


</td></tr>
<tr><td>

[GraphEdges](./graphedges/)


</td><td>


</td></tr>
<tr><td>

[GraphTraversal](./graphtraversal/)


</td><td>


</td></tr>
<tr><td>

[PullPropagator](./pullpropagator/)


</td><td>


</td></tr>
<tr><td>

[Reactive](./reactive/)


</td><td>

Union type for any reactive value (readable or writable).

Use this when a function accepts either signals or computeds.


</td></tr>
<tr><td>

[Readable](./readable/)


</td><td>

A readable reactive value (signal or computed).

Call with no arguments to read the current value. Reading inside a reactive context (effect, computed) creates a dependency.


</td></tr>
<tr><td>

[Scheduler](./scheduler/)


</td><td>


</td></tr>
<tr><td>

[SignalFactory](./signalfactory/)


</td><td>

ServiceDefinition for the signal primitive. This is what gets composed into a service context.


</td></tr>
<tr><td>

[SignalFunction](./signalfunction/)


</td><td>

Signal function type - a callable that acts as both getter and setter.

Call with no arguments to read, call with a value to write. Use `.peek()` to read without tracking dependencies.


</td></tr>
<tr><td>

[SignalOptions](./signaloptions/)


</td><td>

Options for customizing Signal behavior.


</td></tr>
<tr><td>

[SignalService](./signalservice/)


</td><td>

The instantiable service returned by Signal().


</td></tr>
<tr><td>

[SignalsSvc](./signalssvc/)


</td><td>

The type of the signals service returned by `createSignalsSvc()`<!-- -->.

Contains all signal primitives: `signal`<!-- -->, `computed`<!-- -->, `effect`<!-- -->, `batch`<!-- -->, `subscribe`<!-- -->, plus a `dispose()` method for cleanup.


</td></tr>
<tr><td>

[SubscribeCallback](./subscribecallback/)


</td><td>

Callback invoked when the source value changes


</td></tr>
<tr><td>

[SubscribeFactory](./subscribefactory/)


</td><td>

ServiceDefinition for the subscribe primitive. This is what gets composed into a service context.


</td></tr>
<tr><td>

[SubscribeFunction](./subscribefunction/)


</td><td>

Subscribe function type - tracks source dependencies, calls callback on change.


</td></tr>
<tr><td>

[SubscribeOptions](./subscribeoptions/)


</td><td>

Options for customizing Subscribe behavior.


</td></tr>
<tr><td>

[SubscribeService](./subscribeservice/)


</td><td>

The instantiable service returned by Subscribe().


</td></tr>
<tr><td>

[UnsubscribeFunction](./unsubscribefunction/)


</td><td>

Function to stop the subscription


</td></tr>
<tr><td>

[Visit](./visit/)


</td><td>


</td></tr>
<tr><td>

[Writable](./writable/)


</td><td>

A writable reactive value (signal).

Call with no arguments to read, call with a value to write. Writing notifies all subscribers.


</td></tr>
</tbody></table>

