<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@lattice/lattice](./lattice.md)

## lattice package

## Functions

<table><thead><tr><th>

Function


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[compose(modules)](./lattice.compose.md)


</td><td>

Compose modules into a unified context.

Resolves the dependency graph automatically - you only need to pass the modules you want, and their dependencies are included transitively.

Returns a `use()` function that provides access to the composed context: - `use()` - Returns the context directly - `use(callback)` - Passes the context to callback and returns its result


</td></tr>
<tr><td>

[compose(args)](./lattice.compose_1.md)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](./lattice.createinstrumentation.md)


</td><td>

Create an instrumentation context from configuration.

This is the main entry point for setting up instrumentation. Returns `undefined` if instrumentation is disabled, allowing safe optional chaining in production.

Type overloads provide precise return types: - `enabled: false` → always returns `undefined` - `enabled: true` with providers → always returns `InstrumentationContext` - Otherwise → `InstrumentationContext | undefined`


</td></tr>
<tr><td>

[createInstrumentation(config)](./lattice.createinstrumentation_1.md)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](./lattice.createinstrumentation_2.md)


</td><td>


</td></tr>
<tr><td>

[createInstrumentation(config)](./lattice.createinstrumentation_3.md)


</td><td>


</td></tr>
<tr><td>

[defineModule(definition)](./lattice.definemodule.md)


</td><td>

Define a module - the fundamental building block of Lattice composition.

Modules declare dependencies on other modules and provide a create function that receives resolved dependencies and returns the implementation.


</td></tr>
<tr><td>

[devtoolsProvider(options)](./lattice.devtoolsprovider.md)


</td><td>

Create a DevTools instrumentation provider.

Sends instrumentation events to the Lattice DevTools browser extension via `window.postMessage`<!-- -->. In debug mode, also logs to the console.


</td></tr>
<tr><td>

[isDevtoolsAvailable()](./lattice.isdevtoolsavailable.md)


</td><td>

Check if Lattice DevTools extension is available in the current environment.


</td></tr>
<tr><td>

[isModule(value)](./lattice.ismodule.md)


</td><td>

Check if a value is a Module


</td></tr>
<tr><td>

[merge(base, additions)](./lattice.merge.md)


</td><td>

Merge additional properties into a Use context.

Creates a new `Use` that has all properties from the base plus the additions. The base service instances are preserved (not cloned), so you stay on the same reactive graph.


</td></tr>
</tbody></table>

## Interfaces

<table><thead><tr><th>

Interface


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[AnyModule](./lattice.anymodule.md)


</td><td>

Base module interface for dependency arrays. Uses interface + method syntax for bivariant function parameters. This allows Module<specific> to be assignable to AnyModule.


</td></tr>
<tr><td>

[Module](./lattice.module.md)


</td><td>

A module definition - the unit of composition in Lattice.

Modules declare their dependencies and provide a create function that receives resolved dependencies and returns the implementation.


</td></tr>
<tr><td>

[ModuleDefinition](./lattice.moduledefinition.md)


</td><td>

Input type for defineModule - same as Module but without status and with optional dependencies.


</td></tr>
</tbody></table>

## Variables

<table><thead><tr><th>

Variable


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[STATUS\_MODULE](./lattice.status_module.md)


</td><td>

Status constant for module type discrimination


</td></tr>
</tbody></table>

## Type Aliases

<table><thead><tr><th>

Type Alias


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

[ComposedContext](./lattice.composedcontext.md)


</td><td>

The composed context type from a tuple of Modules.

Maps module names to their implementations and adds a `dispose()` method.


</td></tr>
<tr><td>

[ComposeOptions](./lattice.composeoptions.md)


</td><td>

Options for composing modules


</td></tr>
<tr><td>

[DevtoolsProviderOptions](./lattice.devtoolsprovideroptions.md)


</td><td>

Options for the DevTools instrumentation provider.


</td></tr>
<tr><td>

[InstrumentationConfig](./lattice.instrumentationconfig.md)


</td><td>

Configuration for creating an instrumentation context.


</td></tr>
<tr><td>

[InstrumentationContext](./lattice.instrumentationcontext.md)


</td><td>

Instrumentation context for debugging and profiling.

Passed to the `instrument` hook of modules when instrumentation is enabled.


</td></tr>
<tr><td>

[InstrumentationEvent](./lattice.instrumentationevent.md)


</td><td>

An instrumentation event emitted by services.


</td></tr>
<tr><td>

[InstrumentationProvider](./lattice.instrumentationprovider.md)


</td><td>

An instrumentation provider that receives and processes events.

Providers are the output targets for instrumentation data. Examples: DevTools, logging, analytics, performance monitoring.


</td></tr>
<tr><td>

[ModuleDeps](./lattice.moduledeps.md)


</td><td>

Helper type to extract the deps type from a Module


</td></tr>
<tr><td>

[ModuleImpl](./lattice.moduleimpl.md)


</td><td>

Helper type to extract the implementation type from a Module


</td></tr>
<tr><td>

[ModuleName](./lattice.modulename.md)


</td><td>

Helper type to extract the name from a Module


</td></tr>
<tr><td>

[ServiceContext](./lattice.servicecontext.md)


</td><td>

Context provided to modules for lifecycle management.

Passed to `init`<!-- -->, `destroy`<!-- -->, and `instrument` hooks.


</td></tr>
<tr><td>

[ServiceImpl](./lattice.serviceimpl.md)


</td><td>

Extract the implementation type from a Module.


</td></tr>
<tr><td>

[ServiceName](./lattice.servicename.md)


</td><td>

Extract the name from a Module.


</td></tr>
<tr><td>

[UnionToIntersection](./lattice.uniontointersection.md)


</td><td>

Utility type: Convert a union to an intersection. Used internally to combine types.


</td></tr>
<tr><td>

[Use](./lattice.use.md)


</td><td>

A callable returned by `compose()` that provides access to the module context.

`Use` is both a function AND an object with all service properties: - Call `use(fn)` to invoke a portable/behavior with the service context - Access `use.signal`<!-- -->, `use.el`<!-- -->, etc. directly as properties

When you call `use(fn)`<!-- -->, the callback receives the `Use` object itself, allowing nested portables to call other portables.


</td></tr>
</tbody></table>

