---
title: Client Hydration
description: Make server-rendered HTML interactive with hydration.
---

import { Aside } from '@astrojs/starlight/components';

This guide covers hydrating server-rendered HTML on the client. Read [Server Rendering](/guides/server-rendering) first to set up the server side.

---

## What is Hydration?

The browser already has HTML on screen from the serverâ€”now we need to make it interactive. Instead of creating new DOM elements (which would cause a flash), the hydration adapter _walks_ the existing DOM and attaches your event listeners and reactive bindings.

After hydration completes, we fall back to a normal DOM adapter for subsequent updates.

---

## Setting Up Hydration

The key is `createHydrationAdapter()`, which takes a hydration adapter as the first argument and the fallback DOM adapter as the second:

```typescript
// client.ts
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import {
  createDOMHydrationAdapter,
  createHydrationAdapter,
} from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

// ðŸ‘‡ Create hydration adapter that walks existing DOM
const hydrationAdapter = createHydrationAdapter(
  createDOMHydrationAdapter(document.querySelector('.app')!),
  // Falls back after hydration!
  createDOMAdapter()
);

// Create your service as usual on the client
const service = createService(hydrationAdapter);

// Hydrate - walks existing DOM, wires up reactivity
App(service).create(service);

// Switch to the fallback normal DOM mode for future updates
hydrationAdapter.switchToFallback();
```

### What happens:

1. `createDOMHydrationAdapter` wraps the existing `.app` elementâ€”it will walk the DOM instead of creating new elements
2. `createHydrationAdapter` combines it with a normal `createDOMAdapter()` to use after hydration
3. `App(service).create(service)` runs your app, but instead of building DOM, it attaches signals and event listeners to what's already there
4. `switchToFallback()` switches to the normal adapterâ€”future updates create/modify DOM elements as usual

<Aside type="tip" title="Working Example">
See [`packages/examples/ssr-router/src/client.ts`](https://github.com/hejhi/rimitive/tree/main/packages/examples/ssr-router/src/client.ts) for the complete client setup.
</Aside>

---

## Browser-Only Code

If you have browser-specific code that might run on the server (focus, scroll, animate, etc.), add guards:

```typescript
el('input').ref((el) => {
  if (typeof window !== 'undefined') el.focus();
})()
```

<Aside type="note">
Rimitive effects and refs are synchronous by default and run on the server. However, Rimitive out-of-the-box async or browser-specific effect flush strategies (like `mt`, `raf`, etc.) are noops on the server. They're safe to use, but they won't execute. Any other custom flush strategies should be evaluated on a case-by-case basis.
</Aside>

---

If you have no asynchronous data to fetch and load on the server, this might be enough for your use case and you can stop here. Otherwise, onwards to async.

## Next Steps

This covers basic hydration for synchronous SSR. For async data:

- **[SSR with Data Loading](/guides/ssr-loading)** â€” Fetch data during SSR with `load()`
- **[Streaming SSR](/guides/streaming-ssr)** â€” Send HTML progressively as data loads
