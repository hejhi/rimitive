---
title: Server Rendering
description: Render Rimitive apps on the server for faster first paint.
---

import { Aside } from '@astrojs/starlight/components';

Server-side rendering (SSR) renders your app to HTML on the server before sending it to the browser. Instead of shipping an empty `<div id="app">` and waiting for JavaScript to build the page, users see content immediately.

---

## Why SSR?

**Faster first paint.** Users see content before JavaScript loads. On slow connections or devices, this difference is significant.

**SEO.** Search engines index the HTML you send. Client-rendered apps require crawlers to execute JavaScript, which not all do well.

**Social sharing.** Link previews (OpenGraph, Twitter cards) scrape your HTML. SSR ensures they get real content.

**When to skip SSR:** Internal tools, dashboards, and apps behind auth often don't need SSR. The added complexity isn't worth it if SEO and initial load time aren't priorities.

---

## What is Hydration?

When the browser receives SSR HTML, it displays it immediately...but it's static. Buttons don't work, inputs don't respond. The page needs JavaScript to become interactive.

**Hydration** is the process of making that SSR HTML interactive. Instead of throwing away the static HTML and rebuilding the DOM from scratch (which would cause a flash), hydration walks the existing DOM and attaches event listeners and reactive bindings.

Think of it as "reanimating" the static HTML rather than replacing it.

---

## Basic Setup

For basic SSR, you need:
1. A **server adapter** that creates elements using linkedom instead of the real DOM
2. A **client hydration adapter** that walks existing DOM instead of creating new elements

### Server Adapter

```typescript
import { createDOMServerAdapter } from '@rimitive/ssr/server';

const { adapter, serialize } = createDOMServerAdapter();
```

- The server adapter creates elements using linkedom (a lightweight DOM implementation)
- `serialize` converts elements to HTML strings

### Shared Service

Your service factory takes an adapter, so both server and client can use the same components:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export function createService(adapter: Adapter<DOMAdapterConfig>) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter)
  );
}

export type Service = ReturnType<typeof createService>;
```

### Server

```typescript
// server.ts
import { createServer } from 'node:http';
import { createDOMServerAdapter } from '@rimitive/ssr/server';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer((req, res) => {
  // Create per-request adapter and service
  const { adapter, serialize } = createDOMServerAdapter();
  const service = createService(adapter);

  // Create and render the app
  const root = App(service).create(service);
  const html = serialize(root);

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`<!DOCTYPE html>
<html>
<body>
  <div class="app">${html}</div>
  <script src="/client.js"></script>
</body>
</html>`);
});

server.listen(3000);
```

Key point: Create a fresh adapter and service per request—no shared state between requests.

### Client

```typescript
// client.ts
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import {
  createDOMHydrationAdapter,
  createHydrationAdapter,
} from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

// Create hydration adapter that walks existing DOM
const hydrationAdapter = createHydrationAdapter(
  createDOMHydrationAdapter(document.querySelector('.app')!),
  createDOMAdapter()
);

const service = createService(hydrationAdapter);

// Hydrate - walks existing DOM, wires up reactivity
App(service).create(service);

// Switch to normal DOM mode for future updates
hydrationAdapter.switchToFallback();
```

What happens:
1. `createDOMHydrationAdapter` creates an adapter that walks existing DOM elements
2. `createHydrationAdapter` wraps it with a fallback for post-hydration updates
3. `.create(service)` hydrates the app, connecting signals to existing elements
4. `.switchToFallback()` switches to normal DOM mode for subsequent updates

---

## Browser-Only Code

<Aside type="note">
Unlike many frameworks, Rimitive effects are synchronous _by default_, and synchronous effects will run on the server.

**However!** Client-specific or async flush strategies (like `mt`, `raf`, etc) are server safe but will be **noops** on the server. All of the flush strategies Rimitive provides out of the box (other than default) wouldn't run on the server, but if you're using a 3rd party or writing your own flush strategy, _you_ can decide whether it should or shouldn't.
</Aside>

Default effects and refs run on the server. So, if you have browser-specific code that might break on the server (focus, scroll, animate, etc) or a provided server adapter, add guards:

```typescript
el('input').ref((el) => {
  if (typeof window !== 'undefined') el.focus();
})()
```

---

## Next Steps

This covers basic SSR with synchronous rendering. For async data loading:

- **[SSR with Data Loading](/guides/ssr-loading)** — Fetch data during SSR with `load()`
- **[Streaming SSR](/guides/streaming-ssr)** — Send HTML progressively as data loads
