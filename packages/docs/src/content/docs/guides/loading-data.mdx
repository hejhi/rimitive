---
title: Loading Data
description: Fetch async data with automatic tracking and cancellation.
---

import { Aside } from '@astrojs/starlight/components';
import SearchTags from '../../../components/SearchTags.astro';

<SearchTags tags={["resource", "fetch", "async", "data-loading", "api", "http", "loading-state", "error-state"]} />

Data loading in Rimitive is reactive. When dependencies change, data refetches. When requests overlap, stale ones get cancelled. Let's build up to that.

---

## The Manual Way

You _could_ manage async state yourself with signals and effects:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, effect } = compose(SignalModule, ComputedModule, EffectModule);

// State
const loading = signal(true);
const data = signal<string[]>([]);
const error = signal<Error | null>(null);

// Fetch on mount
effect(() => {
  loading(true);
  fetch('/api/items')
    .then(r => r.json())
    .then(items => {
      data(items);
      loading(false);
    })
    .catch(err => {
      error(err);
      loading(false);
    });
});
```

This works, but you're managing three signals, handling errors, and there's no cancellation. When dependencies change mid-flight, you get race conditions.

---

## The resource() Primitive

`resource()` handles all of that. Add the resource module:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { ResourceModule } from '@rimitive/resource';

const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // Add this ðŸ‘‡
  ResourceModule
);

const { signal, resource } = svc;
```

### Basic Usage

Create a resource with a fetcher function:

```typescript
const items = resource((signal) =>
  fetch('/api/items', { signal }).then(r => r.json())
);
```

The fetcher receives an `AbortSignal`. Pass it to `fetch()` for automatic cancellation.

### Reading State

A resource has multiple ways to read its state:

```typescript
// Full state object
items();
// { status: 'pending' }
// { status: 'ready', value: [...] }
// { status: 'error', error: Error }

// Convenience accessors
items.loading();  // true | false
items.data();     // T | undefined
items.error();    // unknown | undefined
```

All are reactiveâ€”use them in computeds or effects.

---

<SearchTags tags={["reactive-fetch", "auto-refetch", "dependency-tracking", "abort-controller", "cancellation"]} />

## Reactive Dependencies

Here's where resources shine. Read signals inside the fetcher, and the resource refetches when they change:

```typescript
const categoryId = signal(1);

const products = resource((signal) =>
  fetch(`/api/products?category=${categoryId()}`, { signal })
    .then(r => r.json())
);

// Initial fetch: /api/products?category=1

categoryId(2);
// Aborts previous request
// New fetch: /api/products?category=2
```

The previous request is automatically aborted. No race conditions, no stale data.

### Multiple Dependencies

Track as many signals as you need:

```typescript
const category = signal('electronics');
const sortBy = signal('price');
const page = signal(1);

const products = resource((signal) =>
  fetch(
    `/api/products?category=${category()}&sort=${sortBy()}&page=${page()}`,
    { signal }
  ).then(r => r.json())
);

// Any change triggers a refetch
category('books');   // refetch
sortBy('rating');    // refetch
page(2);             // refetch
```

---

<SearchTags tags={["loading-ui", "error-ui", "loading-spinner", "skeleton", "status"]} />

## Rendering Resources

Use `match()` to render based on resource state:

```typescript
type Product = { id: number; name: string; price: number };

const products = resource<Product[]>((signal) =>
  fetch('/api/products', { signal }).then(r => r.json())
);

const ProductList = () =>
  match(products, (state) => {
    switch (state.status) {
      case 'pending':
        return el('div')('Loading...');
      case 'error':
        return el('div')(`Error: ${state.error}`);
      case 'ready':
        return el('ul')(
          map(state.value, (p) => p.id, (product) =>
            el('li')(computed(() => product().name))
          )
        );
    }
  });
```

---

## Refetch and Dispose

### Manual Refetch

Trigger a refetch programmatically:

```typescript
const products = resource((signal) =>
  fetch('/api/products', { signal }).then(r => r.json())
);

// Later...
products.refetch();
```

Useful for "refresh" buttons or after mutations.

### Cleanup

When a resource is no longer needed, dispose it to abort any in-flight request and stop tracking:

```typescript
const products = resource((signal) =>
  fetch('/api/products', { signal }).then(r => r.json())
);

// When done
products.dispose();
```

In components, clean up when the element is removed:

```typescript
const ProductList = () => {
  const products = resource((signal) =>
    fetch('/api/products', { signal }).then(r => r.json())
  );

  return el('div').ref(() => {
    // Cleanup callback runs when element is removed
    return () => products.dispose();
  })(
    // ... render products
  );
};
```

---

## resource() vs load()

Rimitive has two primitives for async data:

| | `resource()` | `load()` |
|---|---|---|
| **Use case** | Client-side data fetching | Server-rendered data with hydration |
| **Reactive deps** | Yesâ€”refetches when signals change | Noâ€”fetches once |
| **Cancellation** | Automatic via AbortSignal | No |
| **SSR support** | No | Yesâ€”data serializes for hydration |

**Use `resource()` when:**
- Building a client-only app
- Data depends on user interaction (filters, pagination, search)
- You need automatic refetching and cancellation

**Use `load()` when:**
- You're doing SSR and want data in the initial HTML
- The data should be fetched on the server and reused on the client
- SEO or first-paint performance matters for this data

In an SSR app, you might use both: `load()` for the initial page data that should be server-rendered, and `resource()` for dynamic data that loads after user interaction.

See the [Server Rendering guide](/guides/server-rendering) for `load()` usage.

<Aside type="tip" title="Working Example">
See [`packages/examples/resource`](https://github.com/hejhi/rimitive/tree/main/packages/examples/resource) for a complete data fetching example with reactive dependencies and automatic cancellation.
</Aside>

