---
title: SSR with Data Loading
description: Fetch async data during server rendering with load().
---

import { Aside } from '@astrojs/starlight/components';

This guide builds on [Server Rendering](/guides/server-rendering) and the basic SSR setup.

When you need to fetch data during SSR (for instance, loading products from a database or user data from an API) use `load()`. The server waits for all data to load, renders the complete HTML, then sends it with the data serialized for hydration.

```
Server: Render HTML â†’ Wait for all load() â†’ Serialize data â†’ Send
Client: Hydrate with serialized data â†’ Interactive (no refetch)
```

---

## Adding the Loader Module

To use `load()`, add `createLoaderModule` to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export type ServiceOptions = {
  loaderData?: Record<string, unknown>;
};

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: ServiceOptions
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    // Add this ðŸ‘‡
    createLoaderModule({
      initialData: options?.loaderData,
    })
  );
}

export type Service = ReturnType<typeof createService>;
```

The `initialData` option lets the client receive pre-fetched data from SSR so it doesn't refetch.

---

## Using load()

`load()` creates async boundaries. It takes three arguments:

1. **id** â€” A unique string for data lookup during hydration
2. **fetcher** â€” An async function that returns data
3. **renderer** â€” A function that receives state and returns UI

```typescript
import type { LoadState, LoadStatus } from '@rimitive/view/load';

type UserData = { name: string; email: string };

const UserProfile = (svc: Service) => {
  const { loader, match, el } = svc;

  return loader.load(
    'user-profile',  // ID for hydration
    () => fetch('/api/user').then(r => r.json()),
    (state: LoadState<UserData>) =>
      match(state.status, (status: LoadStatus) => {
        switch (status) {
          case 'pending':
            return el('div')('Loading...');
          case 'error':
            return el('div')(`Error: ${state.error()}`);
          case 'ready':
            return el('div')(
              el('h1')(state.data()!.name),
              el('p')(state.data()!.email)
            );
        }
      })
  );
};
```

The state object has reactive properties:
- `state.status` â€” `'pending' | 'ready' | 'error'`
- `state.data()` â€” The loaded data (undefined until ready)
- `state.error()` â€” The error (undefined unless error)

### Error Handling

Always handle errors in your renderer. The `error` state catches exceptions from your fetcher:

```typescript
loader.load(
  'stats',
  async () => {
    const res = await fetch('/api/stats');
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    return res.json();
  },
  (state) =>
    match(state.status, (status) => {
      switch (status) {
        case 'pending':
          return Loading();
        case 'error':
          return ErrorDisplay(state.error());
        case 'ready':
          return StatsView(state.data()!);
      }
    })
)
```

---

## Rendering on the Server

Use `renderToStringAsync` to render your app and wait for all `load()` boundaries:

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createDOMServerAdapter,
  renderToStringAsync,
  safeJsonStringify,
} from '@rimitive/ssr/server';
import type { RefSpec } from '@rimitive/view/types';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer(async (req, res) => {
  // Create per-request adapter and service
  const { adapter, serialize, insertFragmentMarkers } = createDOMServerAdapter();
  const service = createService(adapter);

  // Render to string, awaiting all load() boundaries
  const html = await renderToStringAsync(App(service), {
    svc: service,
    mount: (spec: RefSpec<unknown>) => spec.create(service),
    serialize,
    insertFragmentMarkers,
  });

  // Get loader data for hydration
  const loaderData = service.loader.getData();

  // Send HTML with embedded data (safeJsonStringify prevents XSS)
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`<!DOCTYPE html>
<html>
<head>
  <script>window.__RIMITIVE_DATA__ = ${safeJsonStringify(loaderData)}</script>
</head>
<body>
  <div class="app">${html}</div>
  <script src="/client.js"></script>
</body>
</html>`);
});

server.listen(3000);
```

Key points:
- `renderToStringAsync` awaits all `load()` boundaries before returning
- `service.loader.getData()` collects all resolved data
- Data is embedded in a script tag for client hydration

---

## Hydrating on the Client

The client hydrates with the pre-fetched data:

```typescript
// client.ts
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import {
  createDOMHydrationAdapter,
  createHydrationAdapter,
} from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

// Create hydration adapter
const hydrationAdapter = createHydrationAdapter(
  createDOMHydrationAdapter(document.querySelector('.app')!),
  createDOMAdapter()
);

// Get loader data from SSR
const loaderData = window.__RIMITIVE_DATA__;

// Create service with loader data
const service = createService(hydrationAdapter, { loaderData });

// Hydrate - load() uses cached data, no refetch
App(service).create(service);

// Switch to normal DOM mode
hydrationAdapter.switchToFallback();
```

What happens:
1. `loaderData` provides pre-fetched data from SSR
2. When `load()` runs during hydration, it finds data by ID and uses it immediately
3. No network requestsâ€”the data is already there

## When Data Fetching Fails

Server-side errors are caught and rendered as the error state. The client receives the error UI, and the error is preserved in the loader data.

For server-level errors (outside of `load()` boundaries), wrap `renderToStringAsync` in a try/catch:

```typescript
try {
  const html = await renderToStringAsync(appSpec, options);
  // ... send HTML
} catch (err) {
  console.error('SSR failed:', err);
  res.writeHead(500);
  res.end('Internal Server Error');
}
```

---

## Next Steps

With `renderToStringAsync`, the server waits for all data before responding. For pages with slow or independent data sources, you might want to send HTML progressively:

- **[Streaming SSR](/guides/streaming-ssr)** â€” Send the shell immediately, stream data as it loads
