---
title: SSR with Data Loading
description: Fetch async data during server rendering with load().
---

import { Aside } from '@astrojs/starlight/components';

This guide builds on [Server Rendering](/guides/server-rendering). Read that first if you haven't.

---

## Why Async SSR?

Basic SSR works great for static content. But most apps need dataâ€”user profiles, product listings, blog posts. You could fetch this data client-side after hydration, but then:

- Users see loading spinners instead of content
- Search engines index empty placeholders
- The main benefit of SSR (fast first paint with real content) is lost

**Async SSR solves this.** The server fetches data, waits for it, then sends complete HTML. The client receives a fully-rendered page with data already embeddedâ€”no loading spinners or refetching.

Rimitive provides a primitive called `load()` for this. With `load()`, you can mark **boundaries** by wrapping the parts of your UI where async data is needed, and Rimitive handles the restâ€”fetching on the server, serializing the results, and hydrating on the client, without needing to refetch.

<Aside type="tip">
`load()` boundaries can be nested. The server resolves them iterativelyâ€”outer boundaries first, then any inner boundaries that appear after outer data loads.
</Aside>

---

## How It Works

Here's the flow:

```
Server                                          Client
  â”‚                                               â”‚
  â”œâ”€ Render app                                   â”‚
  â”œâ”€ Encounter load() calls                       â”‚
  â”œâ”€ Fetch data for each                          â”‚
  â”œâ”€ Wait for all fetches                         â”‚
  â”œâ”€ Render complete HTML                         â”‚
  â”œâ”€ Serialize data into <script> tag             â”‚
  â”œâ”€ Send HTML â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚
  â”‚                                               â”œâ”€ Display HTML (instant)
  â”‚                                               â”œâ”€ Load JavaScript
  â”‚                                               â”œâ”€ Hydrate with embedded data
  â”‚                                               â”œâ”€ Interactive (no refetch)
```

A `load()` call wraps the parts of your component tree where data needs to be fetched. During SSR, the server finds all these spots, fetches the data, and waits for everything to complete before sending HTML.

The data then travels _with_ the HTML. When `load()` runs during hydration, it finds the data already waiting! No network requests needed.

---

## Adding the Loader Module

To use `load()`, add `createLoaderModule` to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createElModule } from '@rimitive/view/el';
import { createMatchModule } from '@rimitive/view/match';
import { createLoaderModule } from '@rimitive/view/load';
import type { Adapter } from '@rimitive/view/types';
import type { DOMAdapterConfig } from '@rimitive/view/adapters/dom';

export type ServiceOptions = {
  // The fetched data the server is sending back from all our load() async
  // calls on the server, mapped to ids
  hydrationData?: Record<string, unknown>;
};

export function createService(
  adapter: Adapter<DOMAdapterConfig>,
  options?: ServiceOptions
) {
  return compose(
    SignalModule,
    ComputedModule,
    EffectModule,
    createElModule(adapter),
    createMatchModule(adapter),
    // Add this ðŸ‘‡
    createLoaderModule({
      // Provide the hydrationData map as loader initialDataâ€”so, when a given loader runs on
      // the client, it finds its respective data that was fetched from its run on the server!
      initialData: options?.hydrationData,
    })
  );
}

export type Service = ReturnType<typeof createService>;
```

The loader is neatly symmetric:
- when you wrap a part of the UI in a `load()` call, you provide a unique id for it
- when that `load()` runs on the server as part of executing the app server-side:
  - the data returned is associated back to that id provided
  - all resolved loader data gets mapped back to the respective id, put into a map, and sent back to the client
  - that map gets passed into `createLoaderModule()` as its `initialData` to be provided to all `load()` calls created from it
- when any `load()` runs on the client as part of executing the app during hydration, it receives its respective data from `initialData` and knows it can skip that initial fetch

Here's why it matters: when provided _no_ `initialData`, `load()` would behave as if...it had no data yet. But the data has already been rendered by the server and provided to the client as HTML content. So during hydration, the `load()` would fetch, and there would probably be some intermediary loading state as we wiped out the active content there. That's a hydration mismatch!

By passing `initialData`, the client's `load()` calls find its corresponding data immediately, setting up the correct signal states, matching what the server provided. Essentially, syncing the app state to the content that's already rendered!

Not clear yet? The next section might help...

---

## Using load()

`load()` creates async boundariesâ€”a place where your app waits for data. It takes three arguments:

| Argument | Purpose |
|----------|---------|
| `id` | Unique string identifier. The client uses this to find the matching data from SSR. |
| `fetcher` | Async function that returns your data. Runs on server during SSR, skipped on client if data exists. |
| `render` | Function that receives loading state and returns UI for each state. |

Here's an example:

```typescript
const UserProfile = (svc: Service) => {
  const { loader, match, el } = svc;

  return loader.load(
    'user-profile',
    () => fetch('/api/user').then(r => r.json()),
    (state) =>
      match(state.status, (status) => {
        switch (status) {
          case 'pending':
            return el('div')('Loading...');
          case 'error':
            return el('div')(`Error: ${state.error()}`);
          case 'ready':
            const user = state.data()!;
            return el('div')(
              el('h1')(user.name),
              el('p')(user.email)
            );
        }
      })
  );
};
```

### The State Object

The `state` passed to your render function has three reactive properties:

| Property | Type | Description |
|----------|------|-------------|
| `state.status` | `'pending' \| 'ready' \| 'error'` | Current loading state |
| `state.data()` | `T \| undefined` | Your data (stuffed into a signal) |
| `state.error()` | `unknown \| undefined` | The error, if any (also stuffed into a signal) |

<Aside type="tip">
`state.data()` and `state.error()` are signals! This makes them reactiveâ€”your UI updates automatically when they change. Rimitive leverages signals wherever possible to make it easier.
</Aside>

---

## Rendering on the Server

For basic SSR, you call `.create()` and `serialize()` directly. With async data, you need `renderToStringAsync`â€”it walks your component tree, waits for all `load()` boundaries to resolve, then returns the complete HTML.

### What renderToStringAsync Does

1. Mounts your app spec
2. Finds all `load()` boundaries
3. Waits for every fetcher to complete
4. Renders the final HTML with real data (not loading states)

### The Server Adapter

`createDOMServerAdapter()` returns three things:

| Property | Purpose |
|----------|---------|
| `adapter` | Creates elements using linkedom (a lightweight server-side DOM) |
| `serialize` | Converts a DOM element to an HTML string |
| `insertFragmentMarkers` | Adds markers around `load()` boundaries so hydration can find them |

### Complete Server Example

```typescript
// server.ts
import { createServer } from 'node:http';
import {
  createDOMServerAdapter,
  renderToStringAsync,
  safeJsonStringify,
} from '@rimitive/ssr/server';
import { createService } from './service.js';
import { App } from './App.js';

const server = createServer(async (req, res) => {
  // Create fresh adapter and service for each request
  const { adapter, serialize, insertFragmentMarkers } = createDOMServerAdapter();
  const service = createService(adapter);

  // Render and wait for all data
  const html = await renderToStringAsync(App(service), {
    svc: service,
    mount: (spec) => spec.create(service),
    serialize,
    insertFragmentMarkers,
  });

  // Collect all the data that was fetched
  const loaderData = service.loader.getData();

  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(`<!DOCTYPE html>
<html>
<head>
  <script>window.__RIMITIVE_DATA__ = ${safeJsonStringify(loaderData)}</script>
</head>
<body>
  <div class="app">${html}</div>
  <script src="/client.js"></script>
</body>
</html>`);
});

server.listen(3000);
```

<Aside type="caution">
Always use `safeJsonStringify` when embedding data in HTML. Regular `JSON.stringify` is vulnerable to XSS if your data contains `</script>` or similar strings.
</Aside>

### Why Fresh State Per Request?

We create a new adapter and service for every request. If you reuse them, data from one user's request could leak into another's.

---

## Hydrating on the Client

Now for the client side. The browser has already received and displayed the HTMLâ€”we just need to make it interactive and connect the data.

```typescript
// client.ts
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import {
  createDOMHydrationAdapter,
  createHydrationAdapter,
} from '@rimitive/ssr/client';
import { createService } from './service.js';
import { App } from './App.js';

// 1. Create hydration adapter (walks existing DOM instead of creating new elements)
const hydrationAdapter = createHydrationAdapter(
  createDOMHydrationAdapter(document.querySelector('.app')!),
  createDOMAdapter()
);

// 2. Get the data that was embedded in the HTML
const ssrData = window.__RIMITIVE_DATA__;

// 3. Create service with SSR data for hydration
const service = createService(hydrationAdapter, { hydrationData: ssrData });

// 4. Hydrate - this walks the DOM and wires up reactivity
App(service).create(service);

// 5. Switch to normal mode for future updates
hydrationAdapter.switchToFallback();
```

### What Happens During Hydration

1. The hydration adapter walks the existing DOM instead of creating new elements
2. When `load('user-profile', ...)` runs, it looks up `'user-profile'` in `initialData`
3. It finds the data immediatelyâ€”no fetch needed
4. The render function runs with `status: 'ready'` and your real data
5. Event listeners and reactive bindings are attached to existing elements

After hydration completes, the app is fully interactive. Future updates use the normal DOM adapter.

---

## Error Handling

### Errors in load() Boundaries

If a fetcher throws, `load()` catches it and renders the error state. This works the same on server and client:

```typescript
loader.load(
  'might-fail',
  async () => {
    const res = await fetch('/api/flaky');
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  },
  (state) =>
    match(state.status, (status) => {
      switch (status) {
        case 'pending':
          return el('div')('Loading...');
        case 'error':
          return el('div').class('error')(`Failed: ${state.error()}`);
        case 'ready':
          return DataView(state.data()!);
      }
    })
);
```

The error is captured and serializedâ€”the client receives the error UI already rendered, and the error is preserved in the SSR data for hydration.

### Server-Level Errors

For errors outside `load()` boundaries (like a crash during rendering), wrap the whole thing:

```typescript
try {
  const html = await renderToStringAsync(App(service), options);
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end(html);
} catch (err) {
  console.error('SSR failed:', err);
  res.writeHead(500);
  res.end('Internal Server Error');
}
```

---

Async loading with SSR is non-trivial, but it's quite powerful and worth experimenting with!

## Next Steps

With `renderToStringAsync`, the server waits for all data before responding. For pages with slow or independent data sources, you might want to send HTML progressively:

- **[Streaming SSR](/guides/streaming-ssr)** â€” Send the shell immediately, stream data as it loads
