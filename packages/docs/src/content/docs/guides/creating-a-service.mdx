---
title: Creating a Service
description: The most basic Rimitive setupâ€”composing modules into a reactive service.
---

import SearchTags from '../../../components/SearchTags.astro';
import { Aside } from '@astrojs/starlight/components';

<SearchTags tags={["service", "compose", "setup", "configuration", "modules", "dependency-injection"]} />

A service bundles modules into an isolated reactive context.

The simplest example of a reactive service:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule);
const { signal } = svc;
```

- A **service** is the result of calling `compose()`.
- A **module** is what you provide to `compose()`. Modules can depend on other modules and share the same reactive graph.

---

## Adding More Modules

We can add some more modules that _would_ react to signal updates:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(SignalModule, ComputedModule, EffectModule);
```

Then use them:

```ts
const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => {
  console.log('Count is now:', count());
});

// ...etc
```

Reactive dependencies are automatically tracked.

---

## Why `compose()`?

Each `compose()` call creates an independent reactive context with no global leakage. This means:

- **Isolation**: Multiple services don't interfere with each other
- **Testing**: Fresh contexts per test, no cleanup needed
- **Tree-shaking**: Only bundle what you use
- **Extensibility**: Add [view modules](/guides/adding-a-ui), [router](/guides/adding-routing), or [custom modules](/guides/custom-modules) later
