---
title: Creating a Service
description: The most basic Rimitive setup—composing modules into a reactive service.
---

import SearchTags from '../../../components/SearchTags.astro';

<SearchTags tags={["service", "compose", "setup", "configuration", "modules", "dependency-injection"]} />

In Rimitive:
- A **service** is the result of calling `compose()`. It bundles your chosen primitives into an isolated reactive context—no globals, no shared state between services. Think of it as a self-contained reactive toolkit.
- A **module** is what you provide to `compose()`. Each module provides one or more primitives—`SignalModule` provides `signal`, `ComputedModule` provides `computed`, and so on. Modules can depend on other modules, and `compose()` bundles everything up into a service where they all share the same underlying reactive graph.

A simple example:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule } from '@rimitive/signals/extend';

const svc = compose(SignalModule);
const { signal } = svc;
```

This example demonstrates `compose()`, which:
- takes primitive modules
- returns a reactive service with only the primitives you asked for wired up to it (in this case, the signal primitive)

Each service has an encapsulated reactive graph inside of it. Using `svc` to represent the service is a convention you'll see used throughout these docs.

This service wouldn't do much on its own—nothing is connected to react to signal changes yet.

---

## Adding More Primitives

We can add some more primitives that _would_ react to signal updates:

```typescript
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';

const { signal, computed, effect } = compose(SignalModule, ComputedModule, EffectModule);
```

Then use them:

```typescript
const count = signal(0);
const doubled = computed(() => count() * 2);

effect(() => {
  console.log('Count is now:', count());
});

// ...etc
```

Dependencies are automatically tracked in Rimitive, so you don't need to worry about it.

---

## Why `compose()`?

You might wonder: why not just export these functions directly?

Each `compose()` call creates an independent reactive context with no global leakage. This means:

- **Isolation** — Multiple services don't interfere with each other
- **Testing** — Fresh contexts per test, no cleanup needed
- **Tree-shaking** — Only bundle what you use
- **Extensibility** — Add [view modules](/guides/adding-a-ui), [router](/guides/adding-routing), or [custom modules](/guides/custom-modules) later
