---
title: Using a Service
description: Different ways to use a reactive service in your code.
---

import { Aside } from '@astrojs/starlight/components';

Once you've [created a service](/guides/creating-a-service), there are a few ways to use it.

---

## Exporting a Service

You can safely destructure anything in Rimitive from a service, so for simpler use cases, you can export the return of a service:

```typescript
// myService.ts

export const { signal, computed } = compose(SignalModule, ComputedModule);
```

You can also export the service itself, which is callable:

```typescript
// myService.ts

export const svc = compose(SignalModule, ComputedModule);
export type Service = typeof svc;
```

---

## In a Function

Rimitive makes heavy usage of factory functions that look like components or hooks you might be used to from other frameworks:

```typescript
import { signal } from './myService.ts'

const useCounter = () => {
  const count = signal(0);
  const increment = () => count(count() + 1);

  return { count, increment };
};

const counter = useCounter();
counter.increment();
counter.count(); // 1
```

This is a plain function that instantiates reactive state and returns an API. In Rimitive, this pattern is called a ["behavior"](/guides/creating-a-behavior), conventionally prefixed with `use*`.

<Aside type="note">
The `use*` prefix is just a naming convention.
</Aside>

If you want to drive a reactive ui with state, Rimitive also has modules and patterns to help you with that.

Next up though, let's talk more about the [behavior pattern](/guides/creating-a-behavior).
