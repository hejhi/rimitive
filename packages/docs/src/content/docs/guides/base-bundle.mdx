---
title: Minimal Bundle Guide
description: How to use Lattice with the smallest possible bundle size
---

import { Card, Aside, Code } from '@astrojs/starlight/components';

Want the absolute smallest bundle? Here's how to optimize your Lattice usage for size-conscious applications.

## Modular Architecture

Lattice provides multiple entry points depending on your needs:

| Import | What it includes |
|--------|------------------|
| `@lattice/core` | Everything: slices, compose, runtime, subscriptions |
| `@lattice/core/base` | Just createStore + compose |
| `@lattice/core/store` | Just createStore (if you don't need compose) |

<Aside type="tip">
  All imports are fully tree-shakeable - you only pay for what you use!
</Aside>

## Minimal Usage

For the smallest footprint, use the base export:

```typescript
import { createStore, compose } from '@lattice/core/base';

// Create a store with just get/set
const createSlice = createStore({ count: 0 });

const counter = createSlice(({ get, set }) => ({
  value: () => get().count,
  increment: () => set({ count: get().count + 1 })
}));

// That's it! No adapters, no runtime, just pure state management
```

## Ultra-Minimal Usage

If you don't even need composition, import just the store:

```typescript
import { createStore } from '@lattice/core/store';

const createSlice = createStore({ count: 0 });

const counter = createSlice(({ get, set }) => ({
  value: () => get().count,
  increment: () => set({ count: get().count + 1 })
}));
```

<Aside type="note">
  This approach gives you highly optimized state management that's fully tree-shakeable. You'll need to handle subscriptions manually.
</Aside>

## What You Give Up

The minimal exports are tiny but exclude:

- ❌ Framework adapters (Redux, Zustand integration)
- ❌ Runtime hooks (useSliceValues, etc.)
- ❌ Selective subscriptions
- ❌ Memoization utilities
- ❌ TypeScript helpers for complex scenarios

## When to Use Minimal

<Card title="✅ Good for" icon="check">
  - Vanilla JavaScript projects
  - Size-critical applications (embedded, IoT)
  - Simple state management needs
  - Learning Lattice concepts
</Card>

<Card title="❌ Not ideal for" icon="x">
  - React/Vue/Svelte applications (need runtime)
  - Complex state management (need full features)
  - Teams already using Redux/Zustand (need adapters)
</Card>

## Framework Portability Advantage

Here's what Lattice minimal gives you that other solutions don't:

```typescript
// Lattice - Works everywhere
const counter = createSlice(({ get, set }) => ({
  value: () => get().count,
  increment: () => set({ count: get().count + 1 })
}));

// Use in React, Vue, Svelte, or vanilla JS
// Same behavior code, different runtime bindings
```

```typescript
// Other solutions - Framework-specific
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 }))
}));

// Locked to specific frameworks
```

## Migration Path

Start minimal, grow as needed:

```typescript
// 1. Start with base - ultra-minimal
import { createStore } from '@lattice/core/base';

// 2. Need framework support? Add runtime
import { useSliceValues } from '@lattice/runtime';

// 3. Need existing library integration? Use adapters
import { createSlice } from '@lattice/core';
import { createZustandAdapter } from '@lattice/adapter-zustand';
```

## The Strategy

- **Need tiny + portable?** Use `@lattice/core/base`
- **Need framework integration?** Add `@lattice/runtime`
- **Need existing library compatibility?** Use full Lattice + adapters

<Aside type="tip">
  Lattice's modular design means you can start minimal and only add features as you need them - no upfront bundle size penalty!
</Aside>