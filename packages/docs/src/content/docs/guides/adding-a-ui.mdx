---
title: Adding a UI
description: Render reactive state to the DOM with el().
---

import { Aside } from '@astrojs/starlight/components';
import SandboxDir from '../../../components/SandboxDir.astro';


## Extending the Service

You have signals and behaviors, so perhaps now we want to layer on some reactive UI.

Rimitive provides the `view` package that contains view-specific modules, with `el()` being the foundation: `el()` is a function for creating elements. It's renderer-agnostic (DOM, native, canvas, whatever), but we'll use the DOM adapter here since that's probably the most common use case.

Add the view modules to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

export const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // Let's add the `el` and `mount` modules from the `view` package, and provide the
  // DOM adapter to make DOM elements ðŸ‘‡
  createElModule(createDOMAdapter()),
  MountModule
);
export type Service = typeof svc;
```

Notice it's the same compose/service pattern as before, just now with more modules!

---

## Creating Elements

`el()` is curried: `el(tag)(children)`. It's all just factories:

```typescript
// A div tag
el('div')();

// An h1 with text ("Hello, World" are children)
el('h1')('Hello, World');

// A div with `el` children
el('div')(
  el('h1')('Title'),
  el('p')('Some text')
);
```

If you provided a different adapter, then you'd pass different (strongly typed!) strings (like `el("mySpecialElement")`). `el` returns a UI **spec** with a stable reference to the underlying elementâ€”it doesn't "re-render".

---

## Props

Use `.props()` to set reactive attributes and events:

```typescript
const isDisabled = signal(false);

const button = el('button').props({
  className: 'primary',
  disabled: isDisabled,
  onclick: () => console.log('clicked'),
})('Click me');

isDisabled(true);  // button becomes disabled, class changes
```

Props are type-safe, driven by the adapter provided.

---

## Reactive Content

Pass a computed for reactive text:

```typescript
const count = signal(0);

const display = el('div')(
  computed(() => `Count: ${count()}`)
);

count(5);  // display updates to "Count: 5"
```

---

## UI Components

The star of the show, UI components in Rimitive are...just functions that return UI specs:

```typescript
const Greeting = (name: string) =>
  el('div')(
    el('h2')(`Hello, ${name}!`),
    el('p')('Welcome to Rimitive.')
  );

const DoubleGreeting = () => el('div')(
  Greeting('Ada'),
  Greeting('Grace')
);
```

<Aside type="note">
UI "components" in Rimitive are plain functions that return a **spec** for a UI, which can be mounted and unmounted. They never re-render, reconcile, or anything else. Some modules like `map` may contain reconciliation logic if they need it to dynamically or conditionally render children, but it's always encapsulated within the module.
</Aside>

That's it, kind of anticlimactic. Here's a working example:

<SandboxDir dir="adding-a-ui" editorHeight="380px" />

---

## Wrapping Components in Service Functions

Just like behaviors, components can be wrapped in a service function for portability:

```typescript
import type { Service } from './service';
import { counter } from './behaviors/counter';

const Counter = (svc: Service) => {
  const { el, computed } = svc;

  // The service function is so cyute isn't it??
  const useCounter = svc(counter);

  return (initial: number) => {
    const { count, doubled, increment, decrement, reset } = useCounter(initial);

    return el('div')(
      el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),
      el('div')(
        el('button').props({ onclick: decrement })('-'),
        el('button').props({ onclick: increment })('+'),
        el('button').props({ onclick: reset })('Reset')
      )
    );
  };
};

// Components can compose other components in the service function
const Counters = (svc: Service) => {
  const { el } = svc;
  const CounterComponent = svc(Counter);

  return () =>
    el('div')(
      CounterComponent(0),
      CounterComponent(100)
    );
};
```

Same shape as portable behaviors: `(svc) => (args) => result`. This is useful for testing, SSR, or sharing components across different service contexts.

---

## Mounting

Use `mount()` to actually attach to the DOM:

```typescript
const App = () => el('div')(
  el('h1')('My App')
);

const app = mount(App());
document.body.appendChild(app.element!);
```

<Aside type="tip" title="Working Example">
See [`packages/examples/view`](https://github.com/hejhi/rimitive/tree/main/packages/examples/view) for a complete example with behaviors, components, and reactive UI.
</Aside>
