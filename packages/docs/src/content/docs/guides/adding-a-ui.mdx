---
title: Adding a UI
description: Render reactive state to the DOM with el().
---

import { Aside } from '@astrojs/starlight/components';

You have signals, and maybe some behaviors, so perhaps now we want to add a reactive UI on top of it.

Rimitive provides the `view` package that contains view-specific primitives, with `el()` being the foundation: `el()` is a function for creating elements. It's renderer-agnostic (DOM, native, canvas, whatever), but we'll use the DOM adapter here since that's probably the most common use case.

---

## Extending the Service

Add the view modules to your service:

```typescript
// service.ts
import { compose } from '@rimitive/core';
import { SignalModule, ComputedModule, EffectModule } from '@rimitive/signals/extend';
import { createDOMAdapter } from '@rimitive/view/adapters/dom';
import { createElModule } from '@rimitive/view/el';
import { MountModule } from '@rimitive/view/deps/mount';

export const svc = compose(
  SignalModule,
  ComputedModule,
  EffectModule,
  // Let's add the `el` and `mount` primitives from the `view` package, and provide the
  // DOM adapter to make DOM elements ðŸ‘‡
  createElModule(createDOMAdapter()),
  MountModule
);
export type Service = typeof svc;
```

Notice it's the same compose/service pattern as before, just now with more modules!

---

## Creating Elements

`el()` is curried: `el(tag)(children)`. It's all just factories:

```typescript
// A div tag
el('div')();

// An h1 with text ("Hello, World" are children)
el('h1')('Hello, World');

// A div with `el` children
el('div')(
  el('h1')('Title'),
  el('p')('Some text')
);
```

If you provided a different adapter, then you'd pass different (strongly typed!) strings (like `el('mySpecialElement')`).

<Aside type="note">
`el` itself also **never re-renders**. You can pass it reactive children, reactive props, etc and those will all update when needed, but the underlying element is stable. The element is created a single time. There is no VDOM here, only fine-grained updates.

There _are_ other primitives (like `match` and `map`) that can dynamically render `el`. But `el` itself doesn't reconcile or re-render. 

This is **great for performance**, creates a **much simpler mental model**, and if you don't need reconciliation, don't use it! You can still write reactive apps.**.
</Aside>

---

## Props

Use `.props()` to set reactive attributes and events:

```typescript
const isDisabled = signal(false);

const button = el('button').props({
  className: 'primary',
  disabled: isDisabled,
  onclick: () => console.log('clicked'),
})('Click me');

isDisabled(true);  // button becomes disabled, class changes
```

Props are typesafe and typed based on the element. `el('button')` knows about `disabled`, `onclick`, `type`, etc. These types are driven by the adapter provided, so for the DOM you get things like `button`, whatever, but swap it out or customize the adapter and then you can get all sorts of other things, like custom elements, svg or canvas abstractions, hydration abstractions...whatever you want really.

---

## Reactive Content

Pass a computed for reactive text:

```typescript
const count = signal(0);

const display = el('div')(
  computed(() => `Count: ${count()}`)
);

count(5);  // display updates to "Count: 5"
```

---

## UI Components

The star of the show, UI components in rimitive are...just functions that return elements:

```typescript
const Greeting = (name: string) =>
  el('div')(
    el('h2')(`Hello, ${name}!`),
    el('p')('Welcome to Rimitive.')
  );

const DoubleGreeting = () => el('div')(
  Greeting('Ada'),
  Greeting('Grace')
);
```

<Aside type="note">
Again, components in rimitive are not magical reactive closures, and there's no re-rendering of them! They are just functions. Just another pattern. There's no re-rendering, just reactive primitives. You're simply returning an element tree.
</Aside>

That's it, kind of anticlimactic.

---

## With Behaviors

Drive UIs with reactive behavior:

```typescript
import { svc, el, computed } from './service';
import { useCounter } from './behaviors/counter';

const Counter = (initial: number) => {
  const { count, doubled, increment, decrement, reset } = useCounter(initial);

  return el('div')(
    el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),
    el('div')(
      el('button').props({ onclick: decrement })('-'),
      el('button').props({ onclick: increment })('+'),
      el('button').props({ onclick: reset })('Reset')
    )
  );
};
```

Again, `Counter` itself is not a reactive closure, so it's not going to re-render!

But wait, there's more!

---

## Portable Components

Just like behaviors, components can be made portable by wrapping them in a function that receives the service:

```typescript
import type { Service } from './service';
import { counter } from './behaviors/counter';

const Counter = (svc: Service) => {
  const { el, computed } = svc;

  // The service layer is so cyute isn't it??
  const useCounter = svc(counter);

  return (initial: number) => {
    const { count, doubled, increment, decrement, reset } = useCounter(initial);

    return el('div')(
      el('div')(computed(() => `Count: ${count()} (doubled: ${doubled()})`)),
      el('div')(
        el('button').props({ onclick: decrement })('-'),
        el('button').props({ onclick: increment })('+'),
        el('button').props({ onclick: reset })('Reset')
      )
    );
  };
};

// Components can compose both behaviors AND components in the service layer
const Counters = (svc: Service) => {
  const { el, computed } = svc;
  const CounterComponent = svc(Counter);

  return (initial: number) => {
    const { count, doubled, increment, decrement, reset } = useCounter(initial);

    return el('div')(
      CounterComponent(0),
      CounterComponent(100)
    );
  };
};
```

Same shape as portable behaviors: `(svc) => (args) => result`. The outer function is the service layer, the inner function is the component factory.

The service layer is where you wire up your dependenciesâ€”behaviors, other components, whatever you need. Then the inner function just uses them.

This is useful for testing, SSR, or sharing components across different service contexts.

---

## Mounting

Use `mount()` to actually attach to the DOM:

```typescript
const App = () => el('div')(
  el('h1')('My App')
);

const app = mount(App());
document.body.appendChild(app.element!);
```

<Aside type="tip" title="Working Example">
See [`packages/examples/view`](https://github.com/hejhi/rimitive/tree/main/packages/examples/view) for a complete example with behaviors, components, and reactive UI.
</Aside>
