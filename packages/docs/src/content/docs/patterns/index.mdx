---
title: Patterns
description: Common patterns for building Rimitive applications.
---

Rimitive is intentionally minimal. It provides reactive primitives and modules—signals, computed, effects, elements, fragments—and lets you compose them into whatever patterns fit your needs.

---

## Available Patterns

### [Signal Patterns](/patterns/signal-patterns/)
Common patterns for working with signals: updaters, derived actions, debouncing, async actions, and more.

### [Forms](/patterns/forms/)
Patterns for building reactive forms with validation, field composition, and submission handling.

### [Behaviors](/patterns/behaviors/)
Headless, reusable UI logic. State and actions without the markup.

### [Portability](/patterns/portability/)
Write once, run anywhere—Rimitive views, React, custom renderers.

### [Shared State](/patterns/shared-state/)
How to share state across components without prop drilling. Spoiler: the service is the context.

### [Error Handling](/patterns/error-handling/)
How to handle errors in Rimitive applications. Spoiler: use try/catch.

### [Async Loading States](/patterns/async-loading/)
How to handle loading, error, and ready states for async data using resources and match.

### [Composition Over Stores](/patterns/composition-over-stores/)
Why Rimitive doesn't have stores, and what to do instead.

