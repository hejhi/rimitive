---
title: Portability
description: Write once, run anywhere—Lattice views, React, custom renderers.
---

import { Aside } from '@astrojs/starlight/components';

Most UI logic isn't tied to a specific framework. A dropdown's open/close behavior is the same whether you're rendering to DOM, React, or a canvas. A form's validation logic doesn't care about the view layer.

Lattice is designed around this insight. The same code can run in different contexts without modification.

---

## The Key: Depend on Contracts, Not Frameworks

A portable component depends on a **service contract**—a set of primitives it needs—not a specific framework:

```typescript
// This component depends on { el, signal, computed }
// It doesn't know or care where those come from
const Counter = (svc: { el: ElFactory; signal: SignalFactory; computed: ComputedFactory }) => {
  const { el, signal, computed } = svc;
  const count = signal(0);

  return el('div')(
    el('span')(computed(() => `Count: ${count()}`)),
    el('button').props({ onclick: () => count(count() + 1) })('Increment')
  );
};
```

This component works with any service that provides `el`, `signal`, and `computed`—whether that's the DOM view service, a test adapter, or something custom.

---

## Portable Component Pattern

The standard pattern is a function that receives a service and returns a function that takes props:

```typescript
// (svc) => (props) => RefSpec
const Button = (svc: Service) => (props: { label: string; onClick: () => void }) => {
  const { el } = svc;

  return el('button').props({ onclick: props.onClick })(props.label);
};
```

This shape lets you:
- Partially apply the service once
- Call the resulting function multiple times with different props
- Pass the component to `use()` for ergonomic instantiation

```typescript
const App = (svc: Service) => {
  const { el, use } = svc;

  return el('div')(
    use(Button)({ label: 'Save', onClick: handleSave }),
    use(Button)({ label: 'Cancel', onClick: handleCancel })
  );
};
```

---

## Running in Different Contexts

### Lattice DOM View

```typescript
import { createDOMView } from '@lattice/view/presets/dom';

const svc = createDOMView()();
const app = Counter(svc);
document.body.appendChild(svc.mount(app).element!);
```

### Lattice Test Adapter

```typescript
import { createTestView } from '@lattice/view/presets/test';

const svc = createTestView()();
const app = Counter(svc);
// No real DOM—useful for testing
```

### React (via @lattice/react)

```typescript
import { createHook } from '@lattice/react';

// Turn a portable behavior into a React hook
const useCounter = createHook(counterBehavior);

function ReactCounter() {
  const { count, increment } = useCounter();
  return <button onClick={increment}>Count: {count()}</button>;
}
```

### Custom Renderer

```typescript
import { createCanvasView } from './my-canvas-adapter';

const svc = createCanvasView()();
const app = Counter(svc);
// Renders to canvas instead of DOM
```

Same component, different targets.

---

## What Makes Code Portable

### Do: Depend on the service contract

```typescript
const MyComponent = (svc: Service) => {
  const { el, signal, computed } = svc;
  // Use primitives from the service
};
```

### Don't: Import framework-specific code

```typescript
// This is NOT portable
import { signal } from '@lattice/signals';

const MyComponent = () => {
  const count = signal(0); // Hardcoded dependency
};
```

### Do: Accept dependencies as props or service extensions

```typescript
const DataList = (svc: Service & { fetchData: () => Promise<Item[]> }) => {
  const { el, resource, fetchData } = svc;
  const items = resource(fetchData);
  // ...
};
```

### Don't: Hardcode external dependencies

```typescript
// This is NOT portable
const DataList = (svc: Service) => {
  const items = resource(() => fetch('/api/items')); // Hardcoded URL
};
```

---

## Portable Behaviors vs Portable Components

**Portable behaviors** return reactive state and logic—no UI:

```typescript
const counter = (svc: SignalsSvc) => (initial = 0) => {
  const count = svc.signal(initial);
  return {
    count,
    increment: () => count(count() + 1),
    decrement: () => count(count() - 1),
  };
};
```

**Portable components** return UI specs:

```typescript
const Counter = (svc: Service) => () => {
  const { el, use } = svc;
  const { count, increment } = use(counter)();

  return el('div')(
    el('span')(computed(() => count())),
    el('button').props({ onclick: increment })('+')
  );
};
```

Behaviors are more portable than components because they have no UI coupling. A behavior can be used in Lattice views, React, Vue, or anywhere else that can provide the signals service.

---

## Type Safety

Define your service contracts with TypeScript:

```typescript
import type { SignalFactory, ComputedFactory } from '@lattice/signals';
import type { ElFactory } from '@lattice/view';

// Minimal contract for a component
type MinimalSvc = {
  signal: SignalFactory;
  computed: ComputedFactory;
  el: ElFactory<DOMAdapterConfig>;
};

// Component declares exactly what it needs
const MyComponent = (svc: MinimalSvc) => { ... };
```

This makes dependencies explicit and enables better tree-shaking—if a component only needs `signal` and `el`, it doesn't pull in `effect`, `resource`, etc.

---

## Testing Portable Code

Portable code is easy to test because you control the service:

```typescript
import { describe, it, expect } from 'vitest';
import { createTestView } from '@lattice/view/presets/test';

describe('Counter', () => {
  it('increments count', () => {
    const svc = createTestView()();
    const { count, increment } = svc.use(counter)();

    expect(count()).toBe(0);
    increment();
    expect(count()).toBe(1);
  });
});
```

No DOM mocking, no framework test utilities—just functions and assertions.

<Aside type="tip">
Portability isn't about running everywhere—it's about **not being locked in**. Even if you only ever use the DOM adapter, portable code is easier to test, easier to refactor, and easier to reason about.
</Aside>
